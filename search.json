[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Modul AGI",
    "section": "",
    "text": "Willkommen!\nWillkommen im Kurs Angewandte Geoinformatik an der Zürcher Hochschule für Angewandte Wissenschaften (ZHAW). Wir nutzen diese Plattform (modul-agi.github.io) um euch Zugriff auf unsere Übungsunterlagen und Theorieinputs zu gewährleisten.\nDer gesamte Quellcode um dieses Buch zu erstellen ist in dem folgenden github-repo verfügbar: github.com/Modul-AGI.",
    "crumbs": [
      "Willkommen!"
    ]
  },
  {
    "objectID": "A_Unsicherheit/1_Einleitung.html",
    "href": "A_Unsicherheit/1_Einleitung.html",
    "title": "💥 Teil: Unsicherheit",
    "section": "",
    "text": "HinweisÜbungsziele\n\n\n\n\nDu bist in der Lage bei zukünftigen GIS Arbeiten mit der Unsicherheit von Punktdaten umzugehen.\nDu kannst reale räumliche Objekte dahin beurteilen, ob diese grenzscharf oder nur mit einer Unschärfe abgebildet werden können.\nDu kannst mit Fuzzy-Tallness umgehen und diese definieren.\nDu kannst unscharfe Phänomene in deinen zukünftigen Projekten berücksichtigen und deren Unschärfe in den Geoverarbeitungsprozess integrieren und auswerten.\nDu kannst ein Modell mit ModelBuilder erstellen und ausführen.",
    "crumbs": [
      "💥 Teil: Unsicherheit"
    ]
  },
  {
    "objectID": "A_Unsicherheit/2_Datengrundlage.html",
    "href": "A_Unsicherheit/2_Datengrundlage.html",
    "title": "Datengrundlage",
    "section": "",
    "text": "Layer\nAuf Moodle steht ein ArcGIS Pro Project Package (Name: Unsicherheit) mit den heutigen Übungsdaten zum Download zur Verfügung.\nAls Packages aufbereitete ArcGIS Pro Projekte können als File anderen Personen zur Verfügung gestellt werden. Damit können auf elegante Art und Weise die eigenen Projektdaten geteilt werden.\nDas ArcGIS Pro Projekt “Unsicherheit” beinhaltet eine Geodatenbank mit folgenden Feature Classes:\nDie Feature Class Tick_Original beinhaltet die Originalstandorte der via Zecken App gemeldeten Zeckenstiche im Raum Zürich aus dem Zeitraum März 2015 bis Juli 2019. Es handelt sich dabei um 1076 Meldungen. Die anderen 40 Feature Classes mit den Bezeichnungen Tick_Run_1 (bis …40) enthalten die mittels Zufall veränderten Positionen der Originalstandorte (vgl. Abschnitt Datenvorverarbeitung).\nDer Layer Wald_NichtWald beinhaltet die Waldausdehnung innerhalb des Untersuchungsraums. Die Daten stammen aus dem Landschaftsmodell swissTLM3D von swisstopo (Layer Bodenbedeckung).",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Datengrundlage</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/2_Datengrundlage.html#layer",
    "href": "A_Unsicherheit/2_Datengrundlage.html#layer",
    "title": "Datengrundlage",
    "section": "",
    "text": "FC Wald_Nichtwald\n\nWald: 0 = Kein Wald / 1 = Wald\n\nFC Tick_Original\n\nID: ID Zeckenstichmeldung\nacc_: Zoomstufe in Karte während der Erfassung des Stiches in der App\nx_lv95: X Koordinate (CH1903+ LV95)\ny_lv95: Y Koordinate (CH1903+ LV95)\nRun_Nr: 0 (Original)\n\nFC Tick_Run_1 bis Tick_Run_40\n\nID: ID Zeckenstichmeldung (gleich wie in Original)\nacc_: Zoomstufe in Karte während der Erfassung des Stiches in der App (gleich wie in Original)\nx_lv95: X Koordinate (Originalstandort)\ny_lv95: Y Koordinate (Originalstandort)\nRun_Nr_x: X Zufallskoordinate Run Nr\nRun_Nr_y: Y Zufallskoordinate Run Nr\nRun_Nr: Nummer Zufallsdurchgang",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Datengrundlage</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/3_Datenvorverarbeitung.html",
    "href": "A_Unsicherheit/3_Datenvorverarbeitung.html",
    "title": "Datenvorverarbeitung",
    "section": "",
    "text": "Übung 1: Daten erkunden und neues “Resultate” Feature Dataset erstellen\nDa der/die App Nutzer(in) den exakten Standort des Zeckenstichs nur mit eingeschränkter Positionsgenauigkeit erfassen kann (abhängig von Zoomstufe in der Karte und individueller räumlicher Orientierungskompetenz), wird davon ausgegangen, dass die erfassten Standorte über eine Unsicherheit verfügen. Um die Auswirkung dieser Unsicherheit auf den Anteil im Wald liegender Stiche simulieren zu können, wurden die 1076 Originalkoordinaten in 40 Monte Carlo Durchgängen (Runs) zufällig in einem Bereich +/-100 Meter versetzt, bildlich gesprochen wurden die Punkte etwas “verschüttelt”. Diese Zufallskoordinaten wurden in Excel generiert. Die untenstehende Abbildung zeigt beispielhaft für Zeckenstichstandort mit ID 1 (blauer Stern = Originalstandort) die 40 zufälligen Standorte (rote Punkte).\nFolgende Abbildung zeigt exemplarisch wie diese künstlich simulierte Ungenauigkeit eines Punktes Auswirkungen darauf hat, ob ein Punkt sich innerhalb oder ausserhalb des Waldes befindet (orange: Originalstandort). Bei 6 von 40 Durchgängen befindet sich der Standort (ID 15611) innerhalb des Waldes. Die Frage, welche beantwortet werden soll, lautet nun: Wie gross ist die Wahrscheinlichkeit, dass sich der mit einer bekannten Ungenauigkeit erfasste Zeckenstichstandort tatsächlich innerhalb des Waldes befindet? (vgl. Kap. 3 Unsicherheit der gemeldeten Zeckenstiche)\nBezüglich Unsicherheit von Geodaten stellt sich zudem die Frage, wie genau kann die Waldrandgrenze mittels einer Polygongrenze überhaupt abgebildet werden? Handelt es sich um ein Objekt, welches eindeutig klar definiert werden kann (grenzscharf) oder verfügt die Waldrandgrenze selber über eine Unschärfe? (vgl. Kap. 4 Unschärfe des Waldrandes)\nDownloade das ArcGIS Pro Package von Moodle, speichere es lokal auf deinem Computer und entpacke die Datei. Öffne anschliessend das Projekt-File (*.aprx), erkunde die Daten und mache dich mit ihnen vertraut.\nErstelle anschliessend in der Projekt-Geodatenbank Unsicherheit.gdb ein neues Feature Dataset mit dem Namen “Resultate”. Weise dem neuen Feature Dataset das Koordinatensystem CH1903+ LV95 zu.\nIn diesem neuen Feature Dataset sollen nachfolgend alle neu erstellten (Zwischen-)Resultate abgelegt werden.",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvorverarbeitung</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html",
    "href": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html",
    "title": "Unsicherheit der gemeldeten Zeckenstichstandorte",
    "section": "",
    "text": "Übung 2: Zusammenfügen (Append) aller Runs zu einem Datensatz\nDie erste Aufgabe besteht darin, zu untersuchen, wie gross der Einfluss der Erfassungsunsicherheit darauf ist, welcher Anteil der erfassten Zeckenstichstandorte inner- oder ausserhalb des Waldes liegen. Dabei soll der Fokus nur auf der Unsicherheit (der Erfassungsgenauigkeit) der Zeckenstichstandorte liegen.\nKopiere zuerst die Feature Class Tick_Original in das Feature Dataset Resultate. Benenne die kopierte Feature Class in Tick_Append um, ändere auch den Alias. Nutze anschliessend das Geoverarbeitungswerkzeug “Append”, um die soeben kopierten Original-Standorte mit den Zeckenstichstandorten aller Runs zusammenzufügen. Wähle unter Field Matching Type die Option “Use the field map to reconcile field differences”.\nÜberprüfe das Resultat. Die Tick_Append Feature Class sollte anschliessend 44’116 Features beinhalten.",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unsicherheit der gemeldeten Zeckenstichstandorte</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-2-zusammenfügen-append-aller-runs-zu-einem-datensatz",
    "href": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-2-zusammenfügen-append-aller-runs-zu-einem-datensatz",
    "title": "Unsicherheit der gemeldeten Zeckenstichstandorte",
    "section": "",
    "text": "HinweisArcGIS Pro Help: Geoprocessing Tool Append\n\n\n\nhttps://pro.arcgis.com/en/pro-app/latest/tool-reference/data-management/append.htm",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unsicherheit der gemeldeten Zeckenstichstandorte</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-3-summe-der-stiche-innerhalb-der-waldfläche",
    "href": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-3-summe-der-stiche-innerhalb-der-waldfläche",
    "title": "Unsicherheit der gemeldeten Zeckenstichstandorte",
    "section": "Übung 3: Summe der Stiche innerhalb der Waldfläche",
    "text": "Übung 3: Summe der Stiche innerhalb der Waldfläche\nUm zu überprüfen wie viele Stiche sich innerhalb des Waldes befinden, muss zunächst der Punktlayer mit den Stichdaten aller Runs und den Originaldaten (Resultat aus Übung 2) mit dem Wald-Layer überlagert werden. Hierbei bietet sich das Geoverarbeitungswerkzeug “Summarize Within” (GeoAnalytics Desktop Tools) an. Dieses Werkzeug zählt alle Punkte welche sich in den jeweiligen Flächen des Input-Polygons befinden. Ausserdem kann damit eine separate Output Tabelle (Output Grouped Table) generiert werden, welche für jeden Run angibt (Group Field = Run_Nr), wie viele Punkte pro Run inner- oder ausserhalb des Waldes liegen. Hinweis: Speichere die Output Grouped Table direkt auf Datenbank-Ebene und nicht im Feature Dataset Resultate. Ansonsten kann die Ausführung des Werkzeugs zu einem Fehler führen.\n\n\n\n\n\n\nHinweisArcGIS Pro Help: Geoprocessing Tool Summarize Within\n\n\n\nhttps://pro.arcgis.com/en/pro-app/latest/tool-reference/geoanalytics-desktop/summarize-within.htm\n\n\nÜberprüfe anschliessend die beiden generierten Outputs (Tabelle und Feature Class). Welche Informationen sind darin enthalten? Was bedeuten die Werte in den Feldern Join ID, Run_Nr und Count of Points innerhalb der Output Grouped Table?",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unsicherheit der gemeldeten Zeckenstichstandorte</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-4-prozentualer-anteil-der-stiche-innerhalb-des-waldes",
    "href": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-4-prozentualer-anteil-der-stiche-innerhalb-des-waldes",
    "title": "Unsicherheit der gemeldeten Zeckenstichstandorte",
    "section": "Übung 4: Prozentualer Anteil der Stiche innerhalb des Waldes",
    "text": "Übung 4: Prozentualer Anteil der Stiche innerhalb des Waldes\nErweitere die Output Grouped Table (Resultat aus Übung 3) um ein Feld, in dem du anschliessend den prozentualen Anteil der Punkte pro Run innerhalb des Waldes berechnen kannst.\nHinweis: Pro Run gibt es 1076 Features\n\n\n\n\n\n\nHinweisArcGIS Pro Help: Calculate Field\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/data-management/calculate-field.htm",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unsicherheit der gemeldeten Zeckenstichstandorte</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-5-diagramm-bar-chart-mit-prozentualem-anteil-der-individuellen-runs",
    "href": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-5-diagramm-bar-chart-mit-prozentualem-anteil-der-individuellen-runs",
    "title": "Unsicherheit der gemeldeten Zeckenstichstandorte",
    "section": "Übung 5: Diagramm (Bar Chart) mit prozentualem Anteil der individuellen Runs",
    "text": "Übung 5: Diagramm (Bar Chart) mit prozentualem Anteil der individuellen Runs\nErstelle zuerst eine Kopie der Output Grouped Table in der Projekt-Geodatenbank. Entferne nachfolgend in der soeben erstellten Kopie alle Records welche die Summen der Stiche ausserhalb des Waldes beinhalten.\nHinweis: beachte die Werte im Feld Join_ID\n\n\n\n\n\n\nHinweisArcGIS Pro Help: Select Layer By Attribute\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/data-management/select-layer-by-attribute.htm\n\n\nErstelle anschliessend ein Balkendiagramm welches die unterschiedlichen prozentualen Anteile der Stiche innerhalb des Waldes pro Run symbolisiert. Gehe hierfür in das Menüband “Standalone Table” und wähle “Create Chart”.\n\nBeachte die Werte und deren Spannweite. Was bedeuten die Werte? Was für Aussagen bezüglich Unsicherheit (Genauigkeit) können bei den Stichdaten gemacht werden?",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unsicherheit der gemeldeten Zeckenstichstandorte</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-6-berechnung-des-mittelwertes-aller-runs",
    "href": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-6-berechnung-des-mittelwertes-aller-runs",
    "title": "Unsicherheit der gemeldeten Zeckenstichstandorte",
    "section": "Übung 6: Berechnung des Mittelwertes aller Runs",
    "text": "Übung 6: Berechnung des Mittelwertes aller Runs\nNutze die Tabelle der in Übung 3 erstellten Feature Class und berechne den prozentualen Anteil aller Stiche (über alle Runs) welche sich innerhalb des Waldes befinden. Vergleiche diesen Wert mit dem Wert aus den Originaldaten.",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unsicherheit der gemeldeten Zeckenstichstandorte</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html",
    "href": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html",
    "title": "Unschärfe des Waldrandes",
    "section": "",
    "text": "Übung 7: Waldrandlinie aus Waldpolygon erstellen\nNeuere Forschungen haben ergeben, dass sich Zecken vermehrt im Waldrandbereich aufhalten und dadurch insbesondere dort das Risiko von einer Zecke gestochen zu werden besonders hoch ist. Deshalb sind wir interessiert daran, ob Zeckenstiche von App-Nutzern auch vermehrt im Bereich des Waldrandes gemeldet wurden. Im Gegensatz zu den vorherigen Übungen, welche die Erfassungsgenauigkeit von Punktdaten untersuchte, liegt der Fokus nun auf der Unschärfe des Waldrands. Wie wird ein Waldrand überhaupt definiert? Handelt es sich um eine scharf abgegrenzte Linie? Falls ja, wo liegt diese Linie exakt? Sind die Baumkronen, die Krautschicht oder die einzelnen Stämme ausschlaggebend? Oder handelt es sich beim Waldrand um einen Bereich mit einem bestimmten Abstand von einer zu definierenden Waldrandlinie? Wie würdest du in der untenstehenden Abbildung den Waldrand festlegen und wie würdest du dies GIS-technisch umsetzen?\nDie Waldrandlinie kann mit Hilfe des Geoverarbeitungswerkzeug “Polygon to Line” hergeleitet werden. Überlege dir, ob vorgängig eine Selektion im Input Feature notwendig ist.\nBetrachte das Resultat und überlege dir wie genau die digitale Waldrandlinie dem Waldrand in der Realität entspricht? Kann das Objekt Waldrand überhaupt grenzscharf abgebildet werden (vgl. rote Linie in Abbildung)?",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unschärfe des Waldrandes</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-7-waldrandlinie-aus-waldpolygon-erstellen",
    "href": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-7-waldrandlinie-aus-waldpolygon-erstellen",
    "title": "Unschärfe des Waldrandes",
    "section": "",
    "text": "HinweisArcGIS Pro Help: Polygon To Line\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/data-management/polygon-to-line.htm\n\n\n\n\n\n\n\n\n\nAbbildung 4.1: Rote Linie: abgeleitete Waldrandlinie / orange Punkte: Stichstandorte original / blaue Punkte: Stichstandorte 40 Monte Carlo Runs",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unschärfe des Waldrandes</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-8-waldrandbereich-festlegen",
    "href": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-8-waldrandbereich-festlegen",
    "title": "Unschärfe des Waldrandes",
    "section": "Übung 8: Waldrandbereich festlegen",
    "text": "Übung 8: Waldrandbereich festlegen\nWir gehen davon aus, dass ein Waldrand kaum mit einer grenzscharfen Linie repräsentiert werden kann. In der Realität entspricht ein Waldrand wohl eher einem bestimmten Bereich. Der Waldrand an sich hat eine Unschärfe (Vagueness). In der GIS-Welt wird eine solche Unschärfe oft mit einem Puffer mit einem zu definierenden Abstand zu einer Linie (Waldrandlinie) abgebildet.\nErstelle basierend auf der in Übung 7 erstellten Waldrandlinie nun den Waldrandbereich mit einem äusseren und inneren Abstand von 25 Metern. Benutze hierfür das dir bereits bekannte Geoverarbeitungswerkzeug “Buffer”. Achte bei der Umsetzung auf die korrekte Festlegung der Werkzeugparameter.\n\n\n\n\n\n\nHinweisArcGIS Pro Help: Buffer\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/analysis/buffer.htm\n\n\nOptional Analog wie in Übungen 3 bis 5 könntest du nun untersuchen, welchen Einfluss die Unschärfe des Waldrandes darauf hat, ob Zeckenstichstandorte im Waldrandbereich liegen oder nicht.",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unschärfe des Waldrandes</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-9-distanz-zu-waldrandlinie-berechnen",
    "href": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-9-distanz-zu-waldrandlinie-berechnen",
    "title": "Unschärfe des Waldrandes",
    "section": "Übung 9: Distanz zu Waldrandlinie berechnen",
    "text": "Übung 9: Distanz zu Waldrandlinie berechnen\nNun wollen wir diese Unschärfe des Konzepts Waldrand noch erweitern und die grenzscharfe Pufferdistanz aus der vorigen Übung mit einer graduellen Zugehörigkeit (membership function) ersetzen. Hierfür sollen folgende Fuzzy Tallness Werte definiert werden (vgl. Abbildung): Abstand zu Waldrandlinie:\n\n10 Meter = 1\n10 bis 20 = 0.7\n20 bis 30 = 0.4\n&gt; 30 Meter = 0\n\n\nBerechne nun als ersten Schritt für den gesamten Untersuchungsraum den Abstand zur nächstgelegenen Waldrandlinie. Nutze hierfür das Geoverarbeitungswerkzeug “Euclidean Distance”. Lege die Output Cell Size auf 1 Meter fest und definiere in den Environments das Output Coordinate System und den Raum in dem diese globale Rasterfunktion ausgeführt wird (Extent = Untersuchungsgebiet).\n\n\n\n\n\n\nHinweisArcGIS Pro Help: Euclidean Distance\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/spatial-analyst/euclidean-distance.htm\n\n\nDie Ausführung dieser Rasterfunktion kann einige Minuten dauern.",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unschärfe des Waldrandes</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-10-zuweisung-der-fuzzy-tallness-werte",
    "href": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-10-zuweisung-der-fuzzy-tallness-werte",
    "title": "Unschärfe des Waldrandes",
    "section": "Übung 10: Zuweisung der Fuzzy Tallness Werte",
    "text": "Übung 10: Zuweisung der Fuzzy Tallness Werte\nJeder Zelle mit einem Distanzwert soll nun ein Fuzzy Tallness Wert gemäss Abbildung in Übung 9 zugeteilt werden. Verwende hierfür das Geoverarbeitungswerkzeug “Reclassify”.\n\n\n\n\n\n\nHinweisArcGIS Pro Help: Reclassify\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/spatial-analyst/reclassify.htm\n\n\nBeim Reklassifizieren können den neuen Werten nur ganzzahlige Werte zugeteilt werden. Verwende deshalb die Werte 100, 70, 40 und 0 statt 1, 0.7, 0.4 und 0. Nutze anschliessend zuerst das Werkzeug “Float” und dann “Divide” um die ganzzahligen Werte wieder in Kommawerte umzurechnen.\n\nFloat\nDivide",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unschärfe des Waldrandes</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-11-unschärfe-werte-den-stichstandorten-zuweisen",
    "href": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-11-unschärfe-werte-den-stichstandorten-zuweisen",
    "title": "Unschärfe des Waldrandes",
    "section": "Übung 11: Unschärfe-Werte den Stichstandorten zuweisen",
    "text": "Übung 11: Unschärfe-Werte den Stichstandorten zuweisen\nDie für jede Zelle definierten Unschärfe-Werte (membership zum Waldrand) werden nun den Daten mit den Stichstandorten zugeteilt. Dies erfolgt mittels “Extract Values to Points”.\n\n\n\n\n\n\nHinweisArcGIS Pro Help: Extract Values to Points\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/spatial-analyst/extract-values-to-points.htm\n\n\nDabei sollen die Unschärfe-Werte (1 / 0.7 / 0.4 / 0) vorerst nur den Original-Stichstandortdaten zugeteilt werden (Input point feature = Tick_Original). Erstelle eine grafische Visualisierung (bsp. Histogramm).\nBeantworte anschliessend folgende Fragen:\nWie viele Zeckenstiche im Original-Datensatz verfügen über Waldrand Unschärfe-Werte von 1, 0.7, 0.4 und 0 und welche Aussage kannst du damit machen?",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unschärfe des Waldrandes</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/6_Automatisieren-Modelbuilder.html",
    "href": "A_Unsicherheit/6_Automatisieren-Modelbuilder.html",
    "title": "Automatisierung mit ModelBuilder",
    "section": "",
    "text": "Übung 12: Waldrand-Fuzzy-Modell in ModelBuilder erstellen\nModelBuilder ist eine visuelle Programmiersprache für die Erstellung von Geoverarbeitungs-Workflows. ModelBuilder wird zum Modellieren und Automatisieren von räumlichen Analysen und Datenverwaltungsprozessen verwendet. Du kannst Geoverarbeitungsmodelle in ModelBuilder erstellen und ändern, wo ein Modell als ein Schema dargestellt wird, das Sequenzen von Prozessen und Geoverarbeitungswerkzeugen verkettet, indem die Ausgabe eines Prozesses als die Eingabe eines anderen Prozesses verwendet wird.\nMache dich auf der Online Hilfe von ArcGIS Pro mit den Möglichkeiten des ModelBuilders vertraut:\nErstelle ein Modell mit ModelBuilder in dem die 5 Prozesse von Übung 9 bis 11 automatisiert ausgeführt werden können. Das Modell kann anschliessend wie ein normales Werkzeug aufgerufen werden. Als Modellparameter müssen die Fuzzy Tallness Distanzen resp. Werte angepasst sowie ein neuer Output Datensatz erstellt werden können.\nVorgehen:\nMit Hilfe von solchen Modellen kannst du deine Geoverarbeitungsketten auf einfache Art und Weise automatisieren ☺.",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Automatisierung mit ModelBuilder</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/6_Automatisieren-Modelbuilder.html#übung-12-waldrand-fuzzy-modell-in-modelbuilder-erstellen",
    "href": "A_Unsicherheit/6_Automatisieren-Modelbuilder.html#übung-12-waldrand-fuzzy-modell-in-modelbuilder-erstellen",
    "title": "Automatisierung mit ModelBuilder",
    "section": "",
    "text": "Gehe in das Menüband “Analysis”.\nWähle den Button ModelBuilder. Damit wird ein neues, noch leeres Modell erstellt.\nGehe in das Catalog Pane und navigiere zu “Toolboxes &gt; Unsicherheit.tbx” und benenne das Modell sinnvoll (Name und Label). Hinweis: keine Sonderzeichen und Leerschläge erlaubt.\nGehe im Catalog Pane in das Register “History”.\nFüge die letzten 5 Prozesse (Übungen 9 bis 11) nacheinander mittels Drag und Drop dem neuen Modell hinzu.\nKlicke im Modell mit rechter Maustaste auf das Tool Reclassify und wähle im Kontextmenü Create Variable &gt; From Parameter &gt; Reclassification\nKlicke mit rechter Maustaste auf die soeben erstellte Modellvariable und wähle im Kontextmenü “Parameter”. Diese Modellvariable erscheint nun beim Aufrufen des Modells als veränderbarer Parameter, d.h. die Fuzzy Tallness Distanzen und Werte können angepasst werden.\nKlicke mit rechter Maustaste auf den Final Output und definiere ihn ebenfalls als Modellparameter.\nSpeichere das Modell via Menüband ModelBuilder &gt; Save\nGehe im Catalog auf Toolboxes &gt; Unsicherheit.tbx &gt; und öffne dein Modell mittels Doppelklick.\nGebe die Modellparameter ein (Fuzzy Tallness Distanzen & Werte und Output Dataset) und führe das Modell mit Run aus.",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Automatisierung mit ModelBuilder</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/7_Leistungsnachweis.html",
    "href": "A_Unsicherheit/7_Leistungsnachweis.html",
    "title": "Leistungsnachweis",
    "section": "",
    "text": "Als Leistungsnachweis wird eine schriftliche Dokumentation der Lösung dieser Übung erwartet. Die Dokumentation sollte vier A4-Seiten nicht überschreiten und muss Folgendes beinhalten:\n\nName und Vorname der Autorin oder des Autors.\nResultate der Übung aufbereitet mittels ansprechenden Grafiken, Tabellen und evtl. Karten.\nBeantwortung der in dieser Übung enthaltenen Fragen.\nKurze Diskussion der Resultate.\nBeschreibung des ModelBuilder Modells inklusive:\n\nGrafische Abbildung des ModelBuilder Modells\nWelche Modellparameter wurden definiert und weshalb\nStichwortartige Beschreibung was das Modell berechnet\n\n\nAbgabeform und -termin\nLade deine vollständige Dokumentation spätestens bis Freitag 2. Oktober 2024 als PDF über Moodle hoch (Abgabe Leistungsnachweis Datenqualität und Unsicherheit).",
    "crumbs": [
      "💥 Teil: Unsicherheit",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_1/1_Einleitung.html",
    "href": "B_Datenbanken_1/1_Einleitung.html",
    "title": "Datenbanken I",
    "section": "",
    "text": "Ausgangslage\nDie Gärten und Grünanlagen prägen das Bild des Campus Grüental. Eine grosse Vielfalt an verschiedenen einheimischen und exotischen Pflanzenarten lädt zum Verweilen ein. Mitarbeiter und Studierende nutzen den grünen Raum zur Erholung, zum Miteinander und zum Lernen. Nicht nur in den Sommermonaten ist das offene Areal des Campus ein Erlebnis für alle. Für die individuelle Pflege und Wartung der Gärten bedarf es sehr guter Planung. Als Datenbank Spezialist werden Sie beauftragt eine Datenbanklösung zur Verwaltung der Campus Pflanzenwelt zu entwickeln.",
    "crumbs": [
      "Datenbanken I"
    ]
  },
  {
    "objectID": "B_Datenbanken_1/1_Einleitung.html#ausgangslage",
    "href": "B_Datenbanken_1/1_Einleitung.html#ausgangslage",
    "title": "Datenbanken I",
    "section": "",
    "text": "HinweisÜbungsziele\n\n\n\n\nSie lernen ein vorgegebenes Textmodell zu lesen, zu interpretieren und dazu die richtigen Fragen zu stellen, um fehlende Antworten zu bekommen.\nSie können aus dem Textmodell relevante Objekte, Attribute und Beziehungen extrahieren.\nSie können auf der Grundlage eines bestehenden Textmodells ein konzeptuelles Datenmodell mit Hilfe eines ER-Diagramms entwickeln.\nSie können das konzeptuelle Datenmodell zu einem logischen Datenmodell weiter entwickeln, indem Sie Tabellen ableiten und Attribute, Schlüssel und Kardinalitäten identifizieren.",
    "crumbs": [
      "Datenbanken I"
    ]
  },
  {
    "objectID": "B_Datenbanken_1/2_Uebung.html",
    "href": "B_Datenbanken_1/2_Uebung.html",
    "title": "Übung",
    "section": "",
    "text": "Anforderungen Pflanzendatenbank\nSie sind ein Datenbank-Spezialist und werden vom Garten-Team der ZHAW beauftragt eine Datenbanklösung zur Pflege und Verwaltung der Pflanzenwelt auf dem Areal des Campus Grüental zu entwickeln. Hierbei sollen alle Pflanzen des Campus katalogisiert und für verschiedene Nutzergruppen über differenzierte Zugriffsmöglichkeiten mit verschiedenen Informationen zugänglich gemacht werden.\nHierbei müssen folgende Anforderungen eingehalten werden:\nDie Pflanzen müssen mit Familie, Gattung, Art und Sorte erfasst werden. Zusätzlich braucht es Informationen darüber, ob es sich um eine einheimische Pflanze handelt oder nicht. Als weitere Information muss es die Möglichkeit geben die Wuchsform, wie z.B. Staude, Strauch oder Baum zu erfassen. Zu einigen Pflanzen sollen Hinweise zur Pflege oder sonstige Bemerkungen eingegeben werden können.\nZu Lernzwecken sollen Pflanzen verschiedenen Pflanzenlernparcours zugeordnet werden können. Hierzu werden einzelne Pflanzen ausgewählt und einem Kurs zugeordnet. Jede Pflanze kann dabei zu verschiedenen Lernparcours gehören und ein Lernparcours kann unterschiedlich viele Pflanzen beinhalten.\nJede Pflanze auf dem Campus muss verortet werden. Dies bedeutet, dass jeder Pflanze auf dem Campus eine genaue Lage zugewiesen werden kann. Es reicht in dieser ersten Version aus die jeweilige Pflanze als Punkt darzustellen. Flächenartige Gewächse wie Stauden oder Gräser können als Punkt zusammengefasst werden. Linienartige Pflanzen wie Hecken können vernachlässigt werden und brauchen nicht aufgenommen zu werden. Für jede Pflanze ist zusätzlich zur genauen (Punkt-)Lage wichtig zu wissen auf welcher gärtnerischen Fläche (Beet) sich die Pflanze befindet. Zur besseren Planung müssen die Gärtner später abfragen können, welche Pflanzen auf welchem Beet stehen. Für die Flächen ist es ausreichend einen Namen und eine ID zu erfassen.",
    "crumbs": [
      "Datenbanken I",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Übung</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_1/2_Uebung.html#aufgabenstellung",
    "href": "B_Datenbanken_1/2_Uebung.html#aufgabenstellung",
    "title": "Übung",
    "section": "Aufgabenstellung",
    "text": "Aufgabenstellung\n\nSchritt 1\nLesen Sie die Aufgabenstellung gewissenhaft. Skizzieren Sie ein erstes Textmodell (stichwortartig) bei welchem Sie bereits erste Objekte identifizieren und Attribute und Beziehungen ableiten. Überlegen Sie sich, ob es offene Fragen oder Unklarheiten gibt. Sie haben anschliessend die Gelegenheit den Auftraggeber über eventuell ungeklärte Anforderungen zu befragen, um ihr Textmodell zu vervollständigen.\n\n\nSchritt 2 (optional)\nSind alle offenen Fragen geklärt und das Textmodell fertig, entwickeln Sie aus ihrem Textmodell ein konzeptuelles Modell. Identifizieren Sie alle notwendigen Objekte mit den zugehörigen Attributen und zeigen Sie die Kardinalitäten der Objekte untereinander auf. Nutzen Sie hierbei die ER-Modellierung, wie in den Vorlesungsfolien aufgezeigt.\n\n\nSchritt 3\nZum Abschluss erstellen Sie auf der Grundlage ihres konzeptuellen Modells das erforderliche logische Modell. Leiten Sie aus den identifizierten Objekten, Attributen und Kardinalitäten die benötigten Tabellen und Schlüsselattribute ab. Achten Sie im Speziellen darauf wo es räumliche Tabellen sind und wo es sich um Sachdatentabellen handelt. Markieren Sie ausserdem auch alle Schlüssel-Attribute (Primärschlüssel und Fremdschlüssel).",
    "crumbs": [
      "Datenbanken I",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Übung</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/1_Einleitung.html",
    "href": "B_Datenbanken_2/1_Einleitung.html",
    "title": "Datenbanken II",
    "section": "",
    "text": "HinweisÜbungsziele\n\n\n\n\nSie können ein bestehendes logisches Modell auf Datenintegrität prüfen und Konsistenzfehler korrigieren.\nSie können auf der Grundlage eines bestehenden Datenmodells mit Hilfe von pgAdmin und ArcGIS Pro auf eine Server Datenbank zugreifen.\nSie können eine bestehende Server Datenbank mit Hilfe von pgAdmin und ArcGIS Pro mit Daten befüllen.\nSie kennen die grundlegenden Mechanismen von Datenbank-Versionierung und können diese in ArcGIS Pro anwenden.",
    "crumbs": [
      "Datenbanken II"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/2_Uebung_Datenintegritaet.html",
    "href": "B_Datenbanken_2/2_Uebung_Datenintegritaet.html",
    "title": "Datenintegrität",
    "section": "",
    "text": "Übung 1: Datenintegrität und Konsistenz\nSie haben den Auftrag ein Datenmodell zur Speicherung von unterschiedlichen Sozialen Schlüssel-Indikatoren für schweizerische Gemeinden zu überprüfen. Hierbei werden jedes Jahr Datenwerte auf Basis einer Gemeinde erhoben. Diese sollen später in der Datenbank gespeichert und ausgewertet werden können. Wichtig hierbei ist, dass die Daten später in einer Karte visualisiert werden können. Deshalb ist es notwendig, dass Gemeinde-Geometrien ebenfalls in der Datenbank gespeichert werden sollen. Ebenfalls ist es sinnvoll bestimmte Indikatoren auch für den gesamten Kanton hochzurechnen, damit diese als Karte dargestellt werden können. Sie bekommen als erste Grundlage folgendes Datenbankmodell vom Auftraggeber gestellt. Leider gibt es in diesem Modell ein paar Konsistenzfehler.\nUntersuchen Sie das Datenmodell auf Konsistenzfehler und korrigieren Sie diese. Lesen Sie den Aufgabentext aufmerksam und schauen sich die Abbildung an und entwickeln Sie daraus ein passendes logisches Datenmodell, welches alle Regeln der Datenintegrität einhält. Es muss nicht perfekt sein. Es geht in dieser Übung darum etwas Erfahrung im Lesen von gegebenen Modellen zu bekommen.",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenintegrität</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "",
    "text": "Übung 2: Datenbankverbindung zum Server in pgAdmin herstellen\nIn den nächsten Übungen wollen wir eine Beispiel Datenbank mit dem dort bereits implementierten Datenbankmodell abfragen. Hierzu müssen wir in einem ersten Schritt eine Verbindung zum PostgreSQL/PostGIS Datenbankserver herstellen. Hierfür nutzen wir das Datenbank-Administrations-Werkzeug pgAdmin.",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-2-datenbankverbindung-zum-server-in-pgadmin-herstellen",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-2-datenbankverbindung-zum-server-in-pgadmin-herstellen",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "",
    "text": "Starten Sie pgAdmin.\nIm Dashboard klicken Sie auf NEW Server und geben die folgenden Verbindungsparameter ein:\nRegister General: Name: svma-s-01323_waelder_studentNr. Verwenden Sie dabei die Nr. Ihres zugewiesenen Benutzers (siehe Abbildung 9.1)\nRegister Connection (siehe Abbildung 9.2):\n\nHost name/address: svma-s-01323.zhaw.ch\nPort: 5432\nMaintenance database: waelder\nUsername: studentNr (Verwenden Sie hier Ihren zugewiesenen Anmeldenamen)\nPasswort: (Verwenden Sie hier Ihr zugewiesenes Passwort)\n\nAlle anderen Einstellungen können belassen werden. Speichern Sie mit Klick auf Save.\nLassen Sie sich nicht davon verunsichern, dass es bereits einige Einträge hat. Da auf dem Server bereits andere Datenbanken installiert sind, sehen Sie auch diese. Navigieren Sie zu unserer Datenbank “waelder” und verschaffen sich einen Überblick über die vorhandenen Tabellen.\nVerwenden Sie für alle folgenden Übungen diese Datenbankverbindung, wenn nichts anderes angegeben ist (siehe Abbildung 9.2).\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.1: PG Admin Oberfläche\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.2: PG Admin Connection",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-3-verbindung-zur-postgresqlpostgis-datenbank-mit-arcgis-pro-herstellen",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-3-verbindung-zur-postgresqlpostgis-datenbank-mit-arcgis-pro-herstellen",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 3: Verbindung zur PostgreSQL/PostGIS Datenbank mit ArcGIS Pro herstellen",
    "text": "Übung 3: Verbindung zur PostgreSQL/PostGIS Datenbank mit ArcGIS Pro herstellen\nNachdem die Datenbank erstellt wurde und eine Verbindung über pgadmin eingerichtet wurde, benötigen wir auch eine Verbindung von ArcGIS Pro zu der Datenbank.\n\nStarten Sie ArcGIS Pro und erstellen ein neues Projekt mit dem Namen “Datenbankzugriff”\nÖffnen Sie das Catalog-Fenster oder das Register Catalog und wählen Sie “Databases” (siehe Abbildung 9.3).\nIm Kontextmenü (rechte Maustaste) kann eine neue Datenbankverbindung zur Server Datenbank hergestellt werden.\n\nDatabases→Kontextmenü→New Database Connection\n\nGeben Sie im Database Connection Fenster die notwendigen Verbindungsparameter ein (siehe Abbildung 9.4).\n\nDatabase Platform: PostgreSQL\nInstance: svma-s-01323.zhaw.ch\nAuthentication Type: Database authentication\nUser Name: studentNr (Verwenden Sie hier Ihren zugewiesenen Anmeldenamen)\nPassword: (Verwenden Sie hier Ihr zugewiesenes Passwort)\nDatabase: waelder\n\nEin Klick auf OK stellt die Verbindung zur Datenbank her.\nSie können der Datenbankverbindung noch einen sinnvollen Namen geben. Es empfiehlt sich eine Kombination aus dem Servernamen, der verbundenen Datenbank und dem Benutzer. Z.B. “svma-s-01323_waelder_student1”\nUnter dem Eintrag “Databases” im Catalog gibt es jetzt eine neue Datenbankverbindung zur Datenbank (siehe Abbildung 9.5).\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.3: Neue Datenbankverbindung in ArcGIS Pro\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.4: Notwendige Verbindungsparameter eingeben\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.5: Neue Datenbankverbindung ist erstellt",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-4-datenbank-schemata-für-arcgis-pro-benutzer",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-4-datenbank-schemata-für-arcgis-pro-benutzer",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 4: Datenbank Schemata für ArcGIS Pro Benutzer",
    "text": "Übung 4: Datenbank Schemata für ArcGIS Pro Benutzer\nNachdem die Datenbank erstellt wurde und alle Verbindungen eingerichtet sind, ist die Datenbank startklar. ArcGIS pro nutzt für die Daten jeweils ein eigenes Schema. Das Schema hat dabei den Namen des Datenbank Admin Users.\n\nNutzen Sie wieder die Verbindung mit der Datenbank “waelder” in pgAdmin und öffnen Sie die Inhalte/Eigenschaften mit Klick auf den kleinen Pfeil.\nNavigieren Sie zum Eintrag Schemas. Dort sind 4 Einträge zu sehen. Ein Schema ist eine Art abgeschlossener Namensraum für die Datenhaltung. Es empfiehlt sich thematisch zusammenpassende Tabellen in einem gemeinsamen Schema zu speichern. Für die meisten Datenbank-Anwendungen genügt es aber alle Tabellen im default Schema “public” zu erstellen. Für den Zugriff über ArcGIS wurde aber durch das Werkzeug “Create Database User” ein spezielles Schema mit dem Namen des Database Users erstellt. Dies ist notwendig damit auch ArcGIS Pro auf die Daten zugreifen und diese verwalten kann. Das entsprechende Schema bekommt dabei immer den Namen des Admin Datenbankbenutzers. In diesem Fall “arcgispro_editor”. Sie können dort z.B. auch ein Schema mit Namen “sde” vom Geodatenbank-Administrator sehen (siehe Abbildung 9.6).\nÖffnen Sie das public Schema. Hier gibt es bereits Einträge. Hier werden die zugehörigen Informationen der Datenbank, wie Sichten, Funktionen usw. zugänglich gemacht. Interessant ist zunächst aber nur der Eintrag “Tables (3)”. In Klammern ist immer die Anzahl der vorhandenen Datenbanktabellen angegeben. Wie wir sehen, gibt es default-Tabellen, welche bereits erstellt wurden. Die Tabelle “spatial_ref_sys” enthält z.B. alle Koordinatensysteme. Die Tabelle “sde_spatial_references” ist eine Hilfstabelle für Koordinatensysteme von ArcGIS Pro. Löschen Sie diese beiden Tabellen NIEMALS. Ohne diese Tabellen sind bestimmte Funktionen nicht mehr ausführbar (siehe Abbildung 9.7)\n\n\n\n\n\n\n\nTipp\n\n\n\nDer Name des Schemas muss in zukünftigen Abfragen immer dem Tabellennamen vorangestellt werden, damit klar ist aus welchem Schema abgefragt werden soll.\n\n\n\n\n\n\n\n\nTipp\n\n\n\nFalls Sie einmal eigene Tabellen erstellen sollten: Es empfiehlt sich alle räumlichen Tabellen direkt in ArcGIS Pro zu erstellen. Dadurch entscheidet ArcGIS Pro selbstständig über die korrekten Datentypen und Geometrietypen. Alle anderen Tabellen sowie Fremdschlüssel usw. können auch in pgadmin erstellt werden. Alle Tabellen wurden im ArcGIS Pro Schema “arcgispro_editor” erstellt.\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.6: PG Admin Schemas\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.7: PG Admin Tables",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-5-datenbankschema-prüfen",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-5-datenbankschema-prüfen",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 5: Datenbankschema prüfen",
    "text": "Übung 5: Datenbankschema prüfen\nFür die kommenden Übungen nutzen wir die Datenbank “waelder” auf unserem Server. Den Zugriff haben wir in den vorigen Übungen eingerichtet. Um einen Überblick zu bekommen, lesen Sie das folgende Datenbankschema und machen sich mit den Tabellen, Attributen und Abhängigkeiten vertraut. Da Sie jetzt alle gemeinsam dieselben Tabellen bearbeiten, gibt es in jeder Tabelle jeweils ein Feld “id_erfasser”. Sobald Sie Tabellen mit Daten befüllen, schreiben Sie bitte immer jeweils Ihre studentNr in das Feld “id_erfasser”, damit die Einträge später unterscheidbar sind.",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-6-datenimport-in-die-datenbank-über-pgadmin",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-6-datenimport-in-die-datenbank-über-pgadmin",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 6: Datenimport in die Datenbank über pgAdmin",
    "text": "Übung 6: Datenimport in die Datenbank über pgAdmin\nDa jetzt alle Tabellen vorliegen sollen diese noch mit ein paar Beispiel-Daten gefüllt werden. Auch hier bietet es sich an räumliche Objekte (Geometrien) mit Hilfe von ArcGIS Pro zu erfassen. Nicht-räumliche Objekte können meist sogar schneller über SQL importiert werden.\n\nSuchen Sie in der Datenbank “waelder” das schema “arcgispro_editor”.\nÖffnen Sie anschliessend den SQL Editor von pgadmin. Sie finden das so genannte Query Tool im Kontextmenü des Schemas oder in der Menüleiste oben unter Tools→Query Tool\nImportieren Sie mit Hilfe eines SQL Statements eine Tierart in die Tabelle “tierarten”.\nDa Sie jetzt alle gemeinsam und gleichzeitig Daten in dieselbe Tabelle einfüllen und Sie die Einträge noch unterscheiden wollen, fügen Sie unter id_erfasser jeweils ihre zugewiesene studentNr (nur die Zahl) ein.\nBenutzen Sie dazu das INSERT Statement und tippen es in das Query Tool (siehe Abbildung 9.8)\n\n   INSERT INTO arcgispro_editor.tierarten (id_tierart, name_tierart, id_erfasser) \n   Values (DEFAULT, 'Bär', studentNr);\nSchliessen Sie die Eingabe mit Klick auf Execute ab.\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDEFAULT ist ein SQL Befehlswort, welches den Zähler für die id_tierart automatisch auf den nächsten freien Wert setzt. So kann die id_tierart automatisch fortlaufend hochnummeriert werden. Sie dürfen gern ein eigenes Tier in die Datenbank einfüllen.\nAchten Sie darauf, dass Text immer in einfache Anführungszeichen (Das Zeichen auf der ?- Taste) gesetzt werden muss. Bei Copy & Paste aus Dateien wird oft das Anführungszeichen verändert.Beachten Sie ausserdem die Punktschreibweise, dabei muss der Name des Schemas “arcgispro_editor” immer mit Punkt verbunden vor dem Namen der Tabelle angegeben werden. Jedes Statement wird mit Semikolon abgeschlossen.\n\n\n\nLassen Sie sich den Inhalt der Tabelle ausgeben. Dies können Sie über ein SELECT SQL Statement ausführen (siehe Abbildung 9.9).\n\n   SELECT * FROM arcgispro_editor.tierarten;\n\nSie können erkennen, dass ihr Tier mit Ihrer studentNr als id_erfasser in die Tabelle eingetragen wurde. Vermutlich sehen Sie auch bereits Einträge Ihrer Mit-Studierenden.\nNavigieren Sie im Object Explorer von pgAdmin zur Tabelle “tierarten”.\nÜber das Kontextmenü können ebenfalls die Inhalte der Tabelle angezeigt werden (siehe Abbildung 9.10).\n\nTabelle “tierarten”→Kontextmenü→View/Edit Data→All Rows\n\nEs öffnet sich automatisch das Query Tool und die Inhalte der Tabelle werden angezeigt.\n\n\n\n\n\n\n\nTipp\n\n\n\nAuf diese Weise kann immer nur die komplette Tabelle angezeigt werden. Filter oder sonstige Einschränkungen müssen als SQL Statement abgesetzt werden.\n\n\n\n\n\n\n\n\nAbbildung 9.8: Insert Statement\n\n\n\n\n\n\n\n\n\nAbbildung 9.9: Select Statement\n\n\n\n\n\n\n\n\n\nAbbildung 9.10: Überprüfen der Tabelleninhalte",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-7-datenimport-in-die-datenbank-mit-einer-sql-datei",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-7-datenimport-in-die-datenbank-mit-einer-sql-datei",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 7: Datenimport in die Datenbank mit einer SQL-Datei",
    "text": "Übung 7: Datenimport in die Datenbank mit einer SQL-Datei\nJedes SQL Statement kann in einer Datei abgespeichert werden. Dadurch lassen sich bequem z.B. gleich mehrere Daten in die Datenbank einlesen.\n\nBleiben Sie in der Datenbank “waelder” im schema “arcgispro_editor”.\nÖffnen Sie das Query Tool.\nLaden Sie die Datei “tierarten.sql” aus dem Moodle und speichern Sie in Ihrem Ordner.\nÖffnen Sie die Datei in einem beliebigen Texteditor und ändern das Wort “studentNr” in Ihre studentNr ab. Denken Sie sich ausserdem ein paar eigene/andere Tierarten aus und schreiben diese ebenfalls in die Datei (siehe Abbildung 9.11).\nÜber das kleine Ordner Symbol (Im Menü des Query Tools links oben) kann eine SQL-Datei geladen werden. Laden Sie die geänderte “tierarten.sql” Datei in pgAdmin.\nDie Auswahl lädt den Inhalt der Datei ins Query Tool (siehe Abbildung 9.12).\nSchliessen Sie die Eingabe mit Klick auf Execute ab.\nSchauen Sie sich erneut den Inhalt der Tabelle “tierarten” an. Die Tabelle sollte jetzt die eigenen Tierarten plus ein paar Einträge Ihrer Mit-Studierenden enthalten.\n\n\n\n\n\n\n\nTipp\n\n\n\nDa der Primärschlüssel der Tabelle nur auf id_tierart gesetzt ist und wir alle zusammen auf derselben Tabelle arbeiten, gibt es einige Tierarten bestimmt doppelt. Das ist normal.\n\n\n\n\n\n\n\n\nAbbildung 9.11: Insert statments\n\n\n\n\n\n\n\n\n\nAbbildung 9.12: Query tool",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-8-geometrieimport-in-die-datenbank",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-8-geometrieimport-in-die-datenbank",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 8: Geometrieimport in die Datenbank",
    "text": "Übung 8: Geometrieimport in die Datenbank\nHerkömmliche GIS Methoden zum Erstellen und Importieren von Geometrien ins GIS sollten Ihnen aus dem GIS Basic Modul bereits bekannt sein. Auch in ArcGIS Pro können Geometrien z.B. über ein Shapefile in eine Geodatenbank importiert werden. Ausserdem können Geometrien z.B. aus einem Luftbild digitalisiert und direkt in der Geodatenbank gespeichert werden.\n\nLaden Sie die Datei “waelder.zip” aus dem Moodle und entpacken Sie die Dateien. Es handelt sich um ein Shapefile mit einigen Wäldern.\nStarten Sie ArcGIS Pro und laden das Projekt “Datenbankzugriff”.\nFügen Sie das Shapefile ein und erfassen Sie mit dem Digitalisierungsmöglichkeiten von ArcGIS Pro zusätzlich ein paar eigene fehlende Wälder.\nÖffnen Sie die Attributtabelle.\nErfassen Sie im Feld “id_erfasser” wiederum Ihre zugewiesene studentNr (Nur die Zahl). Alle weiteren Attribute können Sie beliebig erfassen. Denken Sie sich einfach etwas aus.\nImportieren Sie die Daten anschliessend folgendermassen in die Feature Class “waelder” in der Datenbank auf dem Server.\nKontextmenü der Feature Class “waelder”→Load Data. Es öffnet sich das Werkzeug “Append” (siehe Abbildung 9.13)\n\nInput Dataset: Shapefile “waelder”\nTarget Dataset: waelder.arcgispro_editor.waelder\nField Matching Type: Use the Field Map to reconcile schema differences. Shapefiles können nur Spaltenbezeichnungen mit 10 Zeichen speichern. Alles andere wird abgeschnitten. Das Attribut “beschreibung” ist deshalb in der Datenbank als “beschreibung” gespeichert, im Shapefile aber nur als “beschreibu”. Dies hat zur Folge, dass das Schema beider Feature Classes nicht gleich ist. Aus diesem Grund muss hier explizit die Übereinstimmung der Spalten bestimmt werden. Mit dem kleinen Stiftsymbol können Sie die Felder anpassen bzw. zuweisen. (siehe Abbildung 9.14) Das gleiche gilt für das Feld “id_erfasser” bzw. “id_erfasse” (siehe Abbildung 9.15).\n\nErstellen Sie eine neue Karte in ArcGIS Pro und laden Sie die Feature Class “waelder” aus der Server Datenbank.\nSie haben jetzt die Wälder in die Datenbank importiert.\nSchauen Sie sich die Wälder auch in pgAdmin an. Machen Sie hierzu eine Select Abfrage im Query Tool. In der Ergebnis Tabelle sehen Sie in der Geometry-Spalte ein kleines Karten-Symbol (View all Geometries in this column). Dies öffnet den “Geometry Viewer”. Sie sollten auch dort die Geometrien der importierten Wälder sehen (siehe Abbildung 9.16).\n\n\n\n\n\n\n\nTipp\n\n\n\nDa wir jetzt alle unsere Wälder in dieselbe Datenbank laden, sind natürlich einige Wälder doppelt vorhanden. Dies ist für unser Vorhaben aber nicht weiter schlimm.\n\n\n\n\n\n\n\n\nAbbildung 9.13: Load data\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.14: Geoprocessing Append\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.15: Geoprocessing Append\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.16: GIS GUI mit Wälder",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-9-geometrieimport-in-die-datenbank-mit-sql-datei",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-9-geometrieimport-in-die-datenbank-mit-sql-datei",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 9: Geometrieimport in die Datenbank mit SQL-Datei",
    "text": "Übung 9: Geometrieimport in die Datenbank mit SQL-Datei\nAuch Geometrien können ebenso wie Sachdaten über eine SQL-Datei in die Datenbank kopiert werden.\n\nLaden Sie die Datei “sichtungsmeldungen.sql” aus dem Moodle. Es handelt sich um eine SQL-Datei mit Sichtungsmeldungen von Tieren.\nÖffnen Sie die Datei in einem beliebigen Texteditor. Was sehen Sie? Was fällt auf?\nSie werden bemerken, dass die Geometrie über die Funktion ST_GeomFromText lesbar dargestellt werden kann. Der Geometrietyp von ArcGIS Pro wird dann über diese Funktion automatisch umgewandelt. I.d.R. ist es aber sehr viel einfacher Geometrien über ArcGIS Pro zu importieren oder zu erstellen. Sie sollen hier aber einmal sehen, dass es auch direkt über SQL geht.\nDie Attribute (Spalten in der DB) in der Datei sind Kommagetrennt in Klammern nach dem Wert VALUES. Die Reihenfolge ist diesselbe wie in der Klammer vor dem VALUES.\nPassen Sie die Datei an, indem Sie als objectid (erstes Attribut) ihre studentNr gefolgt von einer 0 eintragen und als id_erfasser (letztes Attribut) jeweils Ihre studentNr (Nur die Zahl ohne 0) eintragen. Denken Sie sich auch eine sinnvolle Schweizer-Koordinate in der Nähe der anderen Objekte aus, damit Sie nicht alle denselben Punkt importieren. Die Punkte dürfen, müssen aber nicht im Wald liegen. Variieren Sie etwas. Sie können eine Koordinate einfach im Map-Fenster von ArcGIS Pro ablesen und ebenfalls in der Datei anpassen. Es kommt jetzt hier nicht auf Genauigkeit der Lage des Punktes an. Über die id_tierart können Sie sich ein beliebiges Tier aussuchen. Tragen Sie eine vorhandene id_tierart aus Ihrer Tierarten Tabelle aus Übung 6 ein. Passen Sie zum Schluss auch noch das Datum an (siehe Abbildung 9.17).\nStarten Sie pgAdmin und laden die Datenbank “waelder” im Schema “arcgispro_editor”\nImportieren Sie die Sichtungsmeldung mit Hilfe der SQL-Datei in die Datenbank.\nSchauen Sie sich die Daten in pgadmin und in ArcGIS Pro an. Sie sollten einige Punkte in der Karte sehen (siehe Abbildung 9.18 und Abbildung 9.19).\n\n\n\n\n\n\n\nAbbildung 9.17: Anpassungen INSERT Statement\n\n\n\n\n\n\n\n\n\nAbbildung 9.18: pgAdmin Select Statement\n\n\n\n\n\n\n\n\n\nAbbildung 9.19: GIS GUI mit Wälder und Sichtungen",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/4_Uebung_Versionierung_Mehrbenutzer.html",
    "href": "B_Datenbanken_2/4_Uebung_Versionierung_Mehrbenutzer.html",
    "title": "Versionierung und Mehrbenutzerbetrieb in ArcGIS Pro",
    "section": "",
    "text": "Übung 10: Version erstellen in ArcGIS Pro\nDie Nutzung von Enterprise Server Geodatenbanken wie z.B. PostgreSQL erlaubt einen Mehrbenutzerbetrieb derselben Datenbank. In den vorigen Übungen haben wir jeweils alle Einträge in die Datenbank mehr oder weniger gleichzeitig durchgeführt, ohne auf eine Version zu achten. In solchen Fällen gilt für die Datenbank, dass der letzte Eintrag einen vorangehenden Eintrag überschreiben würde. Macht ein Benutzer Änderungen an einem Objekt, z.B. einem Polygon und gleichzeitig ein anderer Benutzer ebenfalls Änderungen am selben Polygon, so gilt jeweils die letzte Eintragung als aktuell. Alle vorigen Anpassungen werden überschrieben. Um dies zu verhindern, braucht es einen Mechanismus, welcher diese Mehrfachänderungen im Mehrbenutzerbetrieb managen kann. Hierzu wird Versionierung verwendet.",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Versionierung und Mehrbenutzerbetrieb in ArcGIS Pro</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/4_Uebung_Versionierung_Mehrbenutzer.html#übung-10-version-erstellen-in-arcgis-pro",
    "href": "B_Datenbanken_2/4_Uebung_Versionierung_Mehrbenutzer.html#übung-10-version-erstellen-in-arcgis-pro",
    "title": "Versionierung und Mehrbenutzerbetrieb in ArcGIS Pro",
    "section": "",
    "text": "Kehren Sie in das Projekt “Datenbankzugriff” in ArcGIS Pro zurück und verbinden zur Datenbank “waelder” mit Ihrem zugewiesenen Benutzer (studentNr).\nZeigen Sie die Sichtungsmeldungen aus der Datenbank in der Karte an.\nStarten Sie jetzt den Editor und erfassen ein paar beliebige Sichtungsmeldungen. Erfassen Sie auch die Attribute über die Attributtabelle. Speichern Sie anschliessend Ihre neuen Punkte.\nWechseln Sie anschliessend die Ansicht im Contents-Fenster von “List By Drawing Order” auf “List By Data Source” (siehe Abbildung 10.1).\nSchauen Sie sich die Verbindung zum Layer im Contents-Fenster an. Sie sehen dort zu Anfang “sde.DEFAULT”. Dies ist wie der Name vermuten lässt die Standard-Version in welche automatisch alle Änderungen usw. eingespielt werden, sofern keine weiteren Versionen vorhanden sind. “student1@…” zeigt hier auch noch den verbundenen Benutzer. (siehe Abbildung 10.2).\nSelektieren Sie die Verbindung und achten auf die Registerkarten im ArcGIS Pro Hauptmenü (ganz oben). Es wird ein neues Register “Versioning” angezeigt.\nHier sehen Sie alle Werkzeuge zur Verwaltung der Versionen. Erstellen Sie eine neue eigene Version durch Klick auf “New Version”. Achten Sie darauf das Häkchen bei “Change to this new version” zu setzen, damit die neue Version aktiviert wird (siehe Abbildung 10.3).\n\nName: studentNr_name\nDescription: beliebiger Text\nAccess Permission: Protected\n\nPrivate: Alle Änderungen in dieser Version sind privat, d.h. kein anderer Benutzer kann diese Version sehen und/oder benutzen.\nProtected: Alle Änderungen sind privat und niemand kann in dieser Version Daten bearbeiten. Andere Benutzer können aber die Version anzeigen und Änderungen sehen.\nPublic: Öffentliche Nutzung, d.h. auch andere Benutzer können zu dieser Version wechseln und Daten bearbeiten\n\n\nErstellen Sie die neue Version mit “OK”.\nSchauen Sie wiederum die Datenbankverbindung im Contents-Fenster an. Die neue Version student1 ist jetzt aktiv. Ab sofort werden alle Änderungen innerhalb dieser Version gemacht und nicht mehr in der sde.DEFAULT Version (siehe Abbildung 10.4).\nStarten Sie den Editor und löschen einige der bereits von Ihnen erfassten Sichtungsmeldungen und erfassen auch ein paar neue Punkte. Speichern Sie die Änderungen im Editor.\nMerken Sie sich ungefähr die Lage der von Ihnen jetzt digitalisierten Punkte (siehe Abbildung 10.5).\nWechseln Sie jetzt zurück auf die DEFAULT Version. Dies können Sie über das Kontextmenü des Eintrags im Contents-Fenster→Change Version. Alternativ kann die Version auch in der Registerkarte “Versioning” gewechselt werden.\nWechseln Sie die Version zurück auf die sde.DEFAULT Version.\nSchauen Sie sich das Kartenbild an. Was fällt auf?\nAlle Ihre Anpassungen/Änderungen, welche Sie in der Version studentNr gemacht haben, sind in der sde.DEFAULT nicht mehr vorhanden. Dies ist normal, da die Änderungen eben in einer anderen Version gemacht wurden (siehe Abbildung 10.6 und Abbildung 10.7).\nACHTUNG: Es kann natürlich sein, dass Ihre Mit-Studierenden etwas schneller waren und bereits Änderungen auch in die sde.DEFAULT eingespielt haben und Ihr Kartenbild jetzt deshalb trotzdem anders aussieht als vorher.\nSpeichern Sie Ihr ArcGIS Pro Projekt.\n\n\n\n\n\n\n\nAbbildung 10.1: Data Source in Contents-Fenster\n\n\n\n\n\n\n\n\n\nAbbildung 10.2: ArcGIS Pro Versionierung\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.3: ArcGIS neue Version erstellen\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.4: Neue Version in Data Source in Contents-Fenster\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.5: Neue Punkte in ArcGIS GUI\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.6: Ändere Version in Contents-Fenster\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.7: Ändere Version in Contents-Fenster",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Versionierung und Mehrbenutzerbetrieb in ArcGIS Pro</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/4_Uebung_Versionierung_Mehrbenutzer.html#übung-11-versionen-zusammenführen-in-arcgis-pro",
    "href": "B_Datenbanken_2/4_Uebung_Versionierung_Mehrbenutzer.html#übung-11-versionen-zusammenführen-in-arcgis-pro",
    "title": "Versionierung und Mehrbenutzerbetrieb in ArcGIS Pro",
    "section": "Übung 11: Versionen zusammenführen in ArcGIS Pro",
    "text": "Übung 11: Versionen zusammenführen in ArcGIS Pro\nIn vielen Anwendungsfällen bearbeiten viele Mitarbeiter die Daten in derselben Datenbank. Z.B. können unterschiedliche Mitarbeiter jeweils einen Teil eines Untersuchungsgebiets kartieren. Durch die Versionierung können alle Arbeiten unabhängig voneinander auf derselben Datenbank durchgeführt werden. Zu einem gewissen Zeitpunkt, spätestens nach Abschluss der Arbeiten sollten alle Arbeiten aber wieder in einer gemeinsamen Version zusammengeführt werden.\n\nBleiben Sie im Projekt “Datenbankzugriff” in ArcGIS Pro und in der Datenbank “waelder” mit Ihrem zugewiesenen Benutzer (studentNr).\nWechseln Sie wiederum auf die “List By Data Source” Ansicht im Contents-Fenster.\nSchauen Sie sich den Versionsmanager an. Sie öffnen diesen über die Registerkarte “Data Source Versioning” über die Schaltfläche “Manage Versions” (siehe Abbildung 10.8).\nHier können Sie alle vorhandenen (sofern berechtigten) Versionen einsehen und verwalten.\nDa Sie Ihre jeweilige Version als “protected” erstellt haben, sollten auch die Versionen Ihrer MitStudierenden sichtbar sein (siehe Abbildung 10.9).\nSchliessen Sie den Versionsmanager wieder.\nWechseln Sie anschliessend für den Sichtungsmeldungen Layer die Version. Wählen Sie diesmal die Version eines anderen Teilnehmers z.B. Ihres Tischnachbarn (siehe Abbildung 10.10).\nSie sollten im Kartenbild wieder eine andere Version mit anderen Punkten sehen.\nStarten Sie den Editor und versuchen ein paar neue Punkte zu erfassen.\nSie bekommen eine Fehlermeldung (siehe Abbildung 10.11).\nWie bereits erwähnt können “fremde” Versionen nicht bearbeitet werden, wenn diese nicht öffentlich sind.\nWechseln Sie wieder zurück zu Ihrer eigenen Version “studentNr”.\nZeigen Sie die Registerkarte “Versioning” an.\nBevor wir unsere eigenen Änderungen zurück in die sde.DEFAULT Version einspielen können, müssen wir auf Fehler bzw. Versionierungsprobleme prüfen, um sicher zu stellen, dass keine Inkonsistenzen entstehen.\nKlicken Sie dazu im Menü auf “Manage Versions”. Selektieren Sie Ihre Version und klicken “Reconcile/Post”. Wählen Sie die Zielversion so wie Einstellungen für das Fehlerhandling. Wählen Sie als Zielversion die sde.DEFAULT Datenbank und als Edit versions Ihre zuvor erstellte Version. Setzen Sie noch den Haken bei “Post versions after reconcile”. Lassen Sie ansonsten die Voreinstellungen (siehe Abbildung 10.12).\nSollte der Prozess ohne Fehler durchgeführt werden, so können im Anschluss die Änderungen in die sde.DEFAULT Datenbank geschrieben werden.\nKlicken Sie auf “Ok”. Alle Ihre Änderungen sollten jetzt auch in die sde.DEFAULT Version importiert worden sein.\nPrüfen Sie dies, indem Sie zurück auf die sde.DEFAULT Version wechseln. Diese sollte jetzt identisch mit Ihrer eigenen Version sein\n\n\n\n\n\n\n\nAbbildung 10.8: “Manage Versions” in Data Source [ArcGIS Pro]\n\n\n\n\n\n\n\n\n\nAbbildung 10.9: Verschiedene Versionen sind verfügbar\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.10: Änderung der Version\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.11: Fehlermeldung in ArcGIS Pro\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.12: Fehlerbehebung mit Reconcile/Post",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Versionierung und Mehrbenutzerbetrieb in ArcGIS Pro</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/5_Uebung_SQL_Abfragen.html",
    "href": "B_Datenbanken_2/5_Uebung_SQL_Abfragen.html",
    "title": "Abfragen in SQL mit pgAdmin und ArcGIS Pro",
    "section": "",
    "text": "(Optional) Übung 12: Abfragen in SQL\nWir haben in der Vorlesung ein paar SQL-Abfragen über die “waelder” Datenbank definiert. Da wir jetzt über die vorigen Übungen ein paar Beispiel Daten in die Datenbank importiert haben, können wir diese Datenbank nutzen, um noch ein paar Abfragen zu üben. Es ist nicht Ziel alle Abfragen gemacht zu haben. Machen Sie einfach so viele Abfragen wie Sie können. Beachten Sie auch, dass es oft mehr als einen Lösungsweg gibt.",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Abfragen in SQL mit pgAdmin und ArcGIS Pro</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/5_Uebung_SQL_Abfragen.html#optional-übung-12-abfragen-in-sql",
    "href": "B_Datenbanken_2/5_Uebung_SQL_Abfragen.html#optional-übung-12-abfragen-in-sql",
    "title": "Abfragen in SQL mit pgAdmin und ArcGIS Pro",
    "section": "",
    "text": "Starten Sie pgAdmin und verbinden mit der Datenbank “waelder” mit Ihrem zugewiesenen Login (studentNr).\nFormulieren Sie die folgenden SQL-Abfragen und führen diese über das Query Tool von pgAdmin aus. Schauen Sie sich anschliessend das Ergebnis in der Attributtabelle und im Geometry Viewer an.\n\n\nNicht räumliche Abfragen:\n\nWelche Sichtungsmeldungen wurden von “id_erfasser = x” erfasst?\nWurden Löwen gesichtet? Wenn ja, wie viele?\nWie viele Tiere von jeder Art wurden jeweils gesichtet. Geben Sie eine Liste mit den Namen der Tierarten und der Anzahl der Sichtungen aus.\nWie viele Hasen wurden gesichtet? Geben Sie eine Zahl aus.\nWelcher Erfasser hat am meisten Meldungen erfasst? Geben Sie die id_erfasser und die Anzahl der erfassten Tiere aus.\nWelcher Erfasser hat am meisten unterschiedliche Tiere erfasst? Geben Sie die id_erfasser und die Anzahl der unterschiedlichen Tiere aus.\nIn welchen Wäldern kommen Rehe vor? Geben Sie die Namen und die Beschreibung der betroffenen Wälder und die Tierart aus.\nWie viele unterschiedliche Tierarten wurden gesichtet und welche sind das? Zeigen Sie jede Tierart mit dem Datum der letzten Sichtung. SQL→MAX(datum).\nWelche Tierarten wurden NICHT gesichtet?\nIn welchen Monaten wurden die meisten Tiere gesichtet? Geben Sie die drei “besten” Monate für Tiersichtungen aus.\n\nRäumliche Abfragen:\n\nWie gross sind die erfassten Wälder? Geben Sie eine Liste mit den Waldflächen in qm aus.\n\nFunktion: ST_AREA\n\nWie viel Fläche in qm haben alle Wälder zusammen?\n\nFunktion: ST_AREA und SUM\n\nWelche Sichtungsmeldungen liegen innerhalb eines Waldes?\n\nFunktion: ST_CONTAINS oder ST_WITHIN\n\nWelche Sichtungsmeldungen liegen ausserhalb des Waldes?\n\nFunktion: ST_UNION und ST_CONTAINS\n\nIn welchem Wald gibt es die meisten Sichtungen?\n\nFunktion: ST_CONTAINS und SUM\n\nWie weit sind die ausserhalb liegenden Sichtungsmeldungen vom Wald entfernt?\n\nFunktion: ST_DISTANCE, ST_UNION und ST_CONTAINS\n\nWelche Tiere wurden ausserhalb vom Wald gesichtet?\n\nFunktion: ST_UNION, ST_CONTAINS + JOIN\n\n\nWeitere Abfragen:\n\nGibt es Tierarten, welche nur im Wald gesichtet wurden? Welche sind das?\nGibt es Tierarten, welche nie im Wald gesichtet wurden? Welche sind das?\nIn welchen Wäldern wurden Füchse gesichtet?\nIn welchen Wäldern kommen Rehe und Füchse gemeinsam vor?\nWo gibt es Hermeline aber keine Mauswiesel?",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Abfragen in SQL mit pgAdmin und ArcGIS Pro</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/1_Einleitung.html",
    "href": "B_Datenbanken_3/1_Einleitung.html",
    "title": "Datenbanken III",
    "section": "",
    "text": "HinweisÜbungsziele\n\n\n\n\nSie lernen die Abfragesprache SQL kennen.\nSie können Abfragen in SQL formulieren und dabei auch räumliche PostGIS Funktionen nutzen.\nSie lernen SQL‐Abfragen mit ArcGIS Pro Werkzeugen zu visualisieren.",
    "crumbs": [
      "Datenbanken III"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/2_Leistungsnachweis.html",
    "href": "B_Datenbanken_3/2_Leistungsnachweis.html",
    "title": "Leistungsnachweis",
    "section": "",
    "text": "Die Ergebnisse dieser folgenden Übungen sollen als Leistungsnachweis aufbereitet und eingereicht werden. In diesem Fall muss zu jeder Übung im Abschnitt 4 “Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL” (Übung 7‐12), ausgenommen optionale und Wiederholungsübungen, eine kurze schriftliche Dokumentation der Lösung abgegeben werden. Die Aufgabe gilt als Einzelarbeit. Eine gemeinsame Abgabe in Gruppen ist nicht erlaubt. Abgeschriebenes gilt sofort als nicht bestanden.\nDie Dokumentation muss Folgendes beinhalten:\n\nName und Vorname der Autoren oder Autorinnen.\nKurze Beschreibung des Lösungsweges inkl. der formulierten SQL‐Statements.\nBeschreiben Sie sowohl das Vorgehen in ArcGIS Pro als auch das Vorgehen in pgAdmin. Betrachten Sie dabei insbesondere die Geometrien und die Sachdaten und gehen Sie auf Unterschiede in den Vorgehensweisen und Ergebnissen ein.\nStellen Sie zum Schluss ArcGIS Pro und SQL/PostGIS gegenüber. Überlegen Sie sich Argumente für und gegen den Einsatz von ArcGIS Pro bzw. von SQL/PostGIS. Wann würden Sie ArcGIS Pro nutzen? Wann eher SQL/PostGIS? Befragen Sie dazu auch einschlägige Literatur und starten Sie eine Web‐Recherche. Dokumentieren Sie Ihre Erkenntnisse in ein paar kurzen Sätzen.\n\n\nAbgabeform und ‐termin:\nReichen Sie Ihre vollständige Dokumentation spätestens bis Mittwoch 23. Oktober 2024 (2 Wochen nach letztem Input) als PDF über Moodle ein. Ihr findet dies unter der Aufgabenstellung im Abschnitt Geodatenbanken 3.\nAbgabe Leistungsnachweis",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/3_Uebung_Datenbankverbindung.html",
    "href": "B_Datenbanken_3/3_Uebung_Datenbankverbindung.html",
    "title": "Datenbankverbindung zum Server aufbauen",
    "section": "",
    "text": "Übung 1: (Wiederholung) Datenbankverbindung zum Server in pgAdmin herstellen\nIn den nächsten Übungen wollen wir mit Daten unserer Pflanzendatenbank aus der ersten Datenbank‐Lektion vor 2 Wochen umgehen. Dazu versuchen Sie die Daten aus den einzelnen Tabellen zu verknüpfen und sinnvoll aufzubereiten, um Sie anschliessend im ArcGIS Pro einzubinden und zu visualisieren. Unsere Pflanzendatenbank hat hierbei immer den Namen “modulagi_pdb”. Verwenden Sie, wenn nicht anders angegeben diese Datenbank.\nOPTIONAL: Es ist Ihnen selbst überlassen, ob Sie in den kommenden Übungen die bestehende Server Datenbank nutzen möchten oder Ihre eigene lokale Pflanzendatenbank. Die Übungen beziehen sich auf die Server Variante. Bei eigener Datenbank passen Sie die Datanbank Verbindungsparameter entsprechend an. Wie Sie Ihre eigene lokale Pflanzendatenbank aufsetzen ist in den Vorbereitungsübungen auf Moodle beschrieben.\nUnterlagen auf Moodle\nIn den folgenden Übungen wollen wir mit einer Datenbank auf einem ZHAW‐Server arbeiten. Hierzu erstellen wir zunächst eine Verbindung zu dieser Datenbank über pgAdmin. ACHTUNG: funktioniert nur im ZHAW Netz (VPN).",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Datenbankverbindung zum Server aufbauen</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/3_Uebung_Datenbankverbindung.html#übung-1-wiederholung-datenbankverbindung-zum-server-in-pgadmin-herstellen",
    "href": "B_Datenbanken_3/3_Uebung_Datenbankverbindung.html#übung-1-wiederholung-datenbankverbindung-zum-server-in-pgadmin-herstellen",
    "title": "Datenbankverbindung zum Server aufbauen",
    "section": "",
    "text": "Starten Sie pgAdmin.\nIm Dashboard klicken Sie auf NEW Server und geben die folgenden Verbindungsparameter ein:\nRegister General: Name: svma‐s‐01323_modulagi_pdb_studentNr. Verwenden Sie dabei die Nr. Ihres zugewiesenen Benutzers.\nRegister Connection (siehe Abbildung 13.1):\n\nHost name/address: svma‐s‐01323.zhaw.ch\nPort: 5432\nMaintenance database: modulagi_pdb\nstudentNr (Verwenden Sie hier Ihren zugewiesenen Anmeldenamen)\nPasswort: (Verwenden Sie hier Ihr zugewiesenes Passwort)\n\nAlle anderen Einstellungen können belassen werden. Speichern Sie mit Klick auf Save.\nLassen Sie sich nicht davon verunsichern, dass es bereits einige Einträge hat. Da auf dem Server bereits andere Datenbanken installiert sind, sehen Sie auch diese. Navigieren Sie zur Datenbank “modulagi_pdb” und verschaffen sich einen Überblick über die vorhandenen Tabellen usw..\nVerwenden Sie für alle folgenden Übungen diese Datenbankverbindung, wenn nichts anderes angegeben.\n\n\n\n\n\n\n\nAbbildung 13.1: Register Connection pgAdmin",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Datenbankverbindung zum Server aufbauen</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/3_Uebung_Datenbankverbindung.html#übung-2-wiederholung-datenbankverbindung-zum-server-in-arcgis-pro-herstellen",
    "href": "B_Datenbanken_3/3_Uebung_Datenbankverbindung.html#übung-2-wiederholung-datenbankverbindung-zum-server-in-arcgis-pro-herstellen",
    "title": "Datenbankverbindung zum Server aufbauen",
    "section": "Übung 2: (Wiederholung) Datenbankverbindung zum Server in ArcGIS Pro herstellen",
    "text": "Übung 2: (Wiederholung) Datenbankverbindung zum Server in ArcGIS Pro herstellen\nIn den folgenden Übungen wollen wir mit einer Datenbank auf einem ZHAW-Server arbeiten. Hierzu erstellen wir zunächst eine Verbindung zu dieser Datenbank über ArcGIS Pro.\n\nStarten Sie ArcGIS Pro und erstellen Sie ein neues Projekt “Pflanzendatenbank_III”.\nSie können alle folgenden Übungen in diesem Projekt durchführen.\nNavigieren Sie im Catalog Fenster zum Eintrag Databases. Über das Kontextmenü (Rechtsklick) können Sie eine neue Datenbankverbindung herstellen.\nVerwenden Sie folgende Parameter (siehe Abbildung 13.2):\n\nDatabase Platform: PostgreSQL\nInstance: svma-s-01323.zhaw.ch\nAuthentication Type: Database authentication\nUser Name: studentNr (Verwenden Sie Ihren zugewiesenen Benutzer)\nPassword: (Verwenden Sie ihr zugewiesenes Passwort)\nDatabase: modulagi_pdb (Achtung, auch hier sehen sie eine Reihe von anderen Datenbanken, Achten Sie darauf die korrekte Datenbank zu wählen)\n\nSpeichern Sie die Einstellungen mit Klick auf OK und geben der neuen Datenbankverbindung einen sinnvollen Namen.\nVerwenden Sie für alle folgenden Übungen diese Datenbankverbindung, wenn nichts anderes angegeben.\n\n\n\n\n\n\n\nAbbildung 13.2: Register Connection ArcGIS Pro",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Datenbankverbindung zum Server aufbauen</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html",
    "href": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html",
    "title": "Abfragen aus der Datenbank in ArcGIS Pro einbinden",
    "section": "",
    "text": "Übung 3: Werkzeug “Make Query Table” anwenden\nIn den nächsten Übungen wollen wir mit den Daten in unserer Beispiel-Datenbank umgehen (siehe Abbildung 14.1). Dazu versuchen wir die Daten aus den einzelnen Tabellen zu verknüpfen und sinnvoll aufzubereiten, um Sie anschliessend im ArcGIS Pro einzubinden und zu visualisieren. Unsere Pflanzendatenbank hat hierbei immer den Namen “modulagi_pdb”. Verwenden Sie, wenn nicht anders angegeben diese Datenbank. Erstellen Sie zunächst noch einen beliebigen Ordner auf Ihrem Rechner in welchem wir die jeweiligen Ergebnisse speichern können. Sie finden ein Datenbankschema der Pflanzendatenbank auf dem Moodle. Dies hilft Ihnen beim Verständnis der Datenbank und seinen Beziehungen. Nutzen Sie auch die PostGIS Referenz, um die PostGIS Funktionen zu verstehen.\nWenn Sie sich bei den SQL-Befehlen nicht ganz sicher sind, so versuchen Sie schrittweise zum Ziel zu kommen. Formulieren Sie zunächst einen einfacheren Teil der Abfrage, z.B. nur Attribute aus einer Tabelle und fügen Sie dann die weiteren Attribute und/oder Tabellen schrittweise hinzu. Probieren Sie bei Bedarf nach jedem Zwischenschritt die Abfrage aus und schauen sich die Ergebnisse an.\nDas Werkzeug erstellt aus einer beliebigen Datenbankabfrage eine von ArcGIS Pro lesbare temporäre Tabelle. Dies ist immer dann sinnvoll, wenn z.B. nur eine Teilmenge aller Objekte gebraucht wird. Diese Teilmenge wird dabei in eine neue Tabelle geschrieben.",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Abfragen aus der Datenbank in ArcGIS Pro einbinden</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-3-werkzeug-make-query-table-anwenden",
    "href": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-3-werkzeug-make-query-table-anwenden",
    "title": "Abfragen aus der Datenbank in ArcGIS Pro einbinden",
    "section": "",
    "text": "Tipp\n\n\n\nDie Tabelle wird nur temporär in dem Projekt abgelegt, d.h. es wird keine konkrete Datei geschrieben und auch keine neue Tabelle in der Datenbank erstellt, sondern nur die Abfrage im Projekt gespeichert.\n\n\n\nStarten Sie pgAdmin und verbinden Sie mit der Pflanzendatenbank “modulagi_pdb” mit Ihrem Benutzer studentNr.\nProbieren Sie folgende SQL-Abfrage zu formulieren.\nSuchen Sie alle Gattungen der Familie “Asteraceae”. Zeigen Sie den Namen der Familie und den Namen der Gattung an (siehe Abbildung 14.2).\nStarten Sie ArcGIS Pro und öffnen das Projekt “Pflanzendatenbank_III”.\nErstellen Sie eine neue Karte.\nÖffnen Sie das Werkzeug “Make Query Table”\nWählen Sie die beteiligten Tabellen familien und gattungen (über die Datenbankverbindung)\nWählen Sie die anzuzeigenden Felder name_familie und name_gattung\nFiltern Sie die Abfrage über die SQL-Expression nach ‘Asteraceae’.\n\n\n\n\n\n\n\nTipp\n\n\n\nSie brauchen im Werkzeug nur den WHERE Teil der Abfrage ohne das Schlüsselwort WHERE eingeben. Achten Sie auch auf die verknüpften Schlüssel (id_familie) in beiden Tabellen. Sie können den WHERE Teil natürlich aus pgAdmin kopieren. Achten Sie in dem Fall darauf im Werkzeug auf die SQL-Ansicht umzustellen.\n\n\n\nGeben Sie der neuen Tabelle einen Namen.\nPrüfen Sie die Inhalte der neuen Tabelle. Vergleichen Sie mit dem Ergebnis aus pgAdmin.\n\n\n\n\n\n\n\nTipp\n\n\n\n“Make Query Table” erlaubt nur NICHT-räumliche Abfragen. Es können zwar Felder aus räumlichen Tabellen abgefragt werden, das Ergebnis ist aber immer eine einfache Tabelle und keine Feature Class.\n\n\n\n\n\n\n\n\nAbbildung 14.2: Ausschnitt Datenbankschema modulagi_pdb",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Abfragen aus der Datenbank in ArcGIS Pro einbinden</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-4-werkzeug-make-query-layer-anwenden",
    "href": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-4-werkzeug-make-query-layer-anwenden",
    "title": "Abfragen aus der Datenbank in ArcGIS Pro einbinden",
    "section": "Übung 4: Werkzeug “Make Query Layer” anwenden",
    "text": "Übung 4: Werkzeug “Make Query Layer” anwenden\nDas Werkzeug erstellt aus einer beliebigen Datenbankabfrage eine von ArcGIS Pro lesbare temporäre Feature Class.\n\n\n\n\n\n\nTipp\n\n\n\nDie Feature Class wird nur temporär in dem Projekt abgelegt, d.h. es wird keine konkrete Datei geschrieben und auch keine neue Tabelle in der Datenbank erstellt, sondern nur die Abfrage im Projekt gespeichert.\n\n\n\nProbieren Sie folgende SQL-Abfrage in pgAdmin zu formulieren.\nSuchen Sie den Standort aller Eichen (Gattung = Quercus). Zeigen Sie Gattung, Art und den Standort mit der objectid (Attribut shape + objectid) (siehe Abbildung 14.3).\nWechseln Sie zu ArcGIS Pro.\nÖffnen Sie das Werkzeug “Make Query Layer”.\nSchreiben Sie das SQL-Query.\n\n\n\n\n\n\n\nTipp\n\n\n\nSie können die Abfrage aus pgAdmin (Schritt 3) kopieren und hier wieder einfügen. Klicken Sie danach auf eine leere graue Fläche irgendwo im Werkzeug-Fenster damit das Kopierte angenommen wird.\n\n\n\nDie folgenden Einstellungen sollten dadurch dann automatisch gefunden werden.\nAchten Sie auf den korrekten Geometrietyp (Shape Type) und das Koordinatensystem, die SRID Nummer für das Schweizer Koordinatensystem CH1903+_LV95 lautet 2056.\n\n\n\n\n\n\n\nTipp\n\n\n\nEine Abfrage mit dem Werkzeug “Make Query Layer” benötigt immer ein eindeutiges Identifizierungsfeld (Unique identifier Field(s)). In diesem Fall nutzen wir das Attribut “objectid”. Achten Sie auch in den kommenden Abfragen auf ein solches ID-Feld.\n\n\n\nSchauen Sie sich den neuen Layer in der Karte an und werfen Sie auch einen Blick auf die Attributtabelle.\nVergleichen Sie wieder mit dem Ergebnis aus pgAdmin.\n\n\n\n\n\n\n\nTipp\n\n\n\nÜber das Kontextmenü des neuen Layers im Contents Fenster (Data→Export Features) können Sie den Layer auch dauerhaft z.B. als neue Feature Class in eine eigene Datenbank oder als neues Shapefile speichern.\n\n\n\n\n\n\n\n\nAbbildung 14.3: Ausschnitt Datenbankschema modulagi_pdb",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Abfragen aus der Datenbank in ArcGIS Pro einbinden</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-5-werkzeug-create-database-view-anwenden",
    "href": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-5-werkzeug-create-database-view-anwenden",
    "title": "Abfragen aus der Datenbank in ArcGIS Pro einbinden",
    "section": "Übung 5: Werkzeug “Create Database View” anwenden",
    "text": "Übung 5: Werkzeug “Create Database View” anwenden\n“Create Database View” kann dazu benutzt werden, eine Sicht auf eine Tabelle zu erzeugen bzw. eine Abfrage in der Datenbank zu speichern. Hierbei wird dann nur eine Auswahl von Attributspalten und/oder Objekten zurückgegeben. Eine Sicht ist oft auch nützlich, um komplizierte Abfragen aus mehreren Tabellen in eine Tabelle “zusammen zu fassen”, um dann einfacher darauf zugreifen zu können.\n\n\n\n\n\n\nTipp\n\n\n\nDie Sicht wird bei diesem Werkzeug, anders als in den beiden vorigen Werkzeugen, in der Datenbank gespeichert. D.h. es wird eine neue Tabelle bzw. View in der Datenbank erstellt.\n\n\n\nProbieren Sie folgende SQL-Abfrage in pgAdmin zu formulieren.\nMachen Sie eine Liste mit allen Pflanzen des Kurses “UÖ Stauden Gärtnerisch”. Die Liste soll dabei die ID der Spezies, die Gattung, Art und Sorte der Pflanze sowie den Namen des Kurses und den Standort (Attribut shape) enthalten. Speichern Sie diese Abfrage als View mit dem Namen “pdb.view_kursliste_stauden_gaertnerisch_studentNr” in der Datenbank. (CREATE VIEW … AS SELECT…) (siehe Abbildung 14.4).\n\n\n\n\n\n\n\nTipp\n\n\n\nMit zwei Minus Zeichen vor einer Zeile können Sie die Zeile auskommentieren.\n\n\n\nWechseln Sie zu ArcGIS Pro.\nErneuern Sie die Datenbankverbindung (Refresh / F5), damit die neue View sichtbar ist.\nEine View verhält sich wie eine neue Tabelle in ArcGIS Pro. Aus diesem Grund müsste die Tabelle eigentlich mit der Datenbank registriert werden. Sie erkennen dies auch in der Catalog Ansicht an dem nicht ausgefüllten Rechteck (siehe Abbildung 14.5).\nEine Registrierung bewirkt das Freischalten der Geodatenbank-Funktionen für diese Tabelle, damit auch neue Daten erfasst und bearbeitet werden können. Da Ihr Benutzer studentNr keine Berechtigungen zum Schreiben im Datenbankschema auf der Datenbank hat, kann die Tabelle jetzt nicht registriert werden. Da wir aber die Tabelle nur abfragen wollen ist dies nicht weiter schlimm.\nÖffnen Sie das Werkzeug “Create Database View”.\nSpeichern Sie mit dem Werkzeug eine identische Liste für den Kurs “UÖ Gehölze”. Geben Sie der View den Namen “pdb.view_kursliste_gehoelze_studentNr”. Achten Sie auf das “pdb.” vor dem eigentlichen Namen. Dies gibt das Schema an indem die View gespeichert werden soll. Sie können hierzu wieder das SQL-Select-Statement von oben kopieren (ohne den CREATE VIEW Teil) und den Kursnamen entsprechend anpassen.\nSchauen Sie sich das Ergebnis in der Attributtabelle und in der Karte an.\nSie sehen an dieser Übung, dass nur der Datenbankbesitzer neue Tabellen erstellen und hinzufügen kann. Andere Benutzer wie der student1 können nur vorhandene Tabellen und Daten bearbeiten und ändern. Neue Tabellen können nur ohne Schreibberechtigung erstellt werden.\n\n\n\n\n\n\n\nAbbildung 14.4: Ausschnitt Datenbankschema modulagi_pdb\n\n\n\n\n\n\n\n\n\nAbbildung 14.5: Catalog Ansicht in ArcGIS Pro",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Abfragen aus der Datenbank in ArcGIS Pro einbinden</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-6-optional-werkzeug-make-table-view",
    "href": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-6-optional-werkzeug-make-table-view",
    "title": "Abfragen aus der Datenbank in ArcGIS Pro einbinden",
    "section": "Übung 6: (optional) Werkzeug “Make Table View”",
    "text": "Übung 6: (optional) Werkzeug “Make Table View”\n“Make Table View” kann dazu benutzt werden, um eine reduzierte Sicht auf eine Tabelle zu erzeugen. Hierbei wird dann nur eine Auswahl von Attributspalten (ohne Geometrie-Attribut) angezeigt.\n\n\n\n\n\n\nTipp\n\n\n\nDie Sicht wird nur temporär in dem Projekt abgelegt, d.h. es wird keine konkrete Datei geschrieben und auch keine neue Tabelle in der Datenbank erstellt, sondern nur die Abfrage im Projekt gespeichert.\n\n\n\nStarten Sie ArcGIS Pro und laden das Projekt mit dem Namen “Pflanzendatenbank_III”\nÖffnen Sie das Werkzeug “Make Table View”.\nErstellen Sie eine Abfrage wie in Übung 5 und filtern nach der Art “japonicum”.\nWählen Sie als Input Table die zuvor erstellte View, lassen Sie aber das Geometriefeld (shape) in der Abfrage weg und filtern über eine “new Expression” nach name_art = “japonicum”.\nLassen Sie sich die Attributtabelle der neuen Tabelle anzeigen.",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Abfragen aus der Datenbank in ArcGIS Pro einbinden</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "",
    "text": "Übung 7: Geometrien zusammenführen mit “Dissolve”\nIn diesem Kapitel sollen konkrete Geoverarbeitungsoperationen in ArcGIS Pro und PostGIS/SQL gegenübergestellt werden. Dafür bearbeiten wir die entsprechende Fragestellung zunächst in ArcGIS Pro und stellen anschliessend die gleiche Funktion in PostGIS nach. Zur Visualisierung des Ergebnisses der SQL-Abfrage nutzen wir das Werkzeug “Make Query Layer” in ArcGIS Pro aus Übung 4.\nDie importierten Flächen sind alle einem bestimmten Bereich zugeordnet. Um einen Überblick über die Grösse und Ausdehnung der Bereiche zu bekommen, möchten wir alle Flächen (Tabelle pdb.flaechen_shp) mit identischem Bereich (Attribut “name_bereich”) zusammenführen (Abbildung 15.1).",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-7-geometrien-zusammenführen-mit-dissolve",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-7-geometrien-zusammenführen-mit-dissolve",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "",
    "text": "Führen Sie die Geometrien mit identischem Bereichsnamen (Attribut “name_bereich”) zusammen. Verwenden Sie wieder die Verbindung mit dem Benutzer studentNr.\n\nVerwenden Sie das Werkzeug “Dissolve” in ArcGIS Pro. Nutzen Sie dabei Multipart Features. Speichern Sie das Ergebnis als neuen Layer.\nFormulieren Sie jetzt die SQL Anfrage in pgAdmin (Verbindung wieder mit Benutzer studentNr). Verwenden Sie dabei die Funktion ST_UNION. Um nur gewünschte Flächen zu erhalten, sollten Sie das Ergebnis im SQL-Befehl nach dem Namen des Bereichs gruppieren (GROUP BY).\nOptional: Was passiert wenn das GROUP BY weggelassen würde? Probieren Sie es aus.\nLassen Sie das Attribute name_bereich für die Flächen anzeigen.\nZeigen Sie das Ergebnis mit “Make Query Layer” an und vergleichen mit dem ArcGIS Pro Resultat.\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDa Ihr Datenbankbenutzer studentNr keine Berechtigungen zum Speichern in der Server Datenbank hat, können Sie das Ergebnis lokal auf Ihrem Rechner in Ihrem Ordner oder einer eigenen Geodatenbank ablegen.\n\n\n\n\n\n\n\n\nAbbildung 15.1: Auszug aus Datenbankschema",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-8-puffer-um-geometrie-erstellen",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-8-puffer-um-geometrie-erstellen",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "Übung 8: Puffer um Geometrie erstellen",
    "text": "Übung 8: Puffer um Geometrie erstellen\nAuf dem Campus sollen die Wege im Päoniengarten auf jeder Seite um 25cm verbreitert werden. Um die neuen Wege darzustellen, erstellen wir einen Puffer. Die Wegflächen finden Sie in der Datenbank in der Feature Class “wege_paeoniengarten” (siehe Abbildung 15.2).\n\nLegen Sie jeweils einen Puffer von beidseitig 25cm um das Wegenetz.\n\nNutzen Sie dazu einmal das Werkzeug “Buffer” in ArcGIS Pro. Speichern Sie hierbei das Ergebnis.\nNutzen Sie jetzt die POSTGIS Funktion ST_BUFFER in pgAdmin. Geben Sie auch die id der Flächen mit aus.\n\n\n\n\n\n\n\n\nTipp\n\n\n\nAchten Sie auf die Einheiten. Welche Einheit nimmt ST_BUFFER? Fragen Sie die Online-Hilfe.\n\n\n\nSkizzieren Sie ihr Vorgehen in ArcGIS Pro und notieren ihren SQL-Befehl.\nUm das Ergebnis der PostGIS Funktion zu visualisieren, nutzen Sie das Werkzeug “Make Query Layer” mit Ihrer SQL Abfrage.\nVergleichen Sie die Ergebnisse. Schauen Sie sich auch die Attribute an. Was fällt auf?\n\n\n\n\n\n\n\nAbbildung 15.2: Auszug aus Datenbankschema",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-9-geometrien-überschneiden-mit-intersect",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-9-geometrien-überschneiden-mit-intersect",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "Übung 9: Geometrien überschneiden mit “Intersect”",
    "text": "Übung 9: Geometrien überschneiden mit “Intersect”\nAn einigen Stellen muss für die Verbreiterung des Weges die Fläche einiger Beete weichen. Ermitteln Sie die betroffenen Beete, welche Fläche für die neuen Wege abgeben müssen (siehe Abbildung 15.3).\n\nBilden Sie die Schnittmenge (Intersection) der gepufferten Wegfläche und der restlichen Flächen aus der Tabelle “pdb.flaechen”.\n\nIn ArcGIS Pro verwenden Sie dazu das Werkzeug “Pairwise Intersect”. Sie können als Input entweder Ihr Ergebnis aus der vorigen Übung benutzen oder Sie verwenden den Datensatz “wege_paeoniengarten_buffer” aus der Datenbank. Speichern Sie das Ergebnis.\nStellen Sie den SQL-Befehl mit Hilfe der Funktion “ST_INTERSECTION” für diese Abfrage in pgAdmin auf und visualisieren das Ergebnis wieder mit “Make Query Layer”. Sie können als Input entweder den gespeicherten Puffer aus der vorigen Übung verwenden oder Sie verwenden den Datensatz “wege_paeoniengarten_buffer” aus der Datenbank. Probieren Sie ebenfalls einmal aus durch eine verschachtelte Abfrage den Puffer mit ST_BUFFER direkt einzubeziehen. Geben Sie in Ihrem SQL-Befehl auch die ID der Fläche mit aus.\n\nSkizzieren Sie ihr Vorgehen in ArcGIS Pro und notieren ihren SQL-Befehl.\nVergleichen Sie die Ergebnisse aus ArcGIS Pro und SQL.\n\n\n\n\n\n\n\nTipp\n\n\n\nDie SQL Funktion ST_INTERSECTION erzeugt immer eine so genannte Geometry Collection, auch wenn zwei Geometrien keine Schnittmenge aufweisen, gibt es einen dann leeren Eintrag. Aus diesem Grund zeigt das Ergebnis immer alle Geometrien an. Haben die Geometrien keine Schnittmenge, so ist die Geometrie leer. Um leere Geometrien auszuschliessen, sollte im WHERE-Abschnitt z.B. mit der Funktion ST_OVERLAPS oder der Funktion ST_INTERSECTS geprüft werden, ob die zwei Eingabe-Geometrien (Gepufferte Wege und sonstige Flächen) überhaupt irgendwo überlappen. Im ArcGIS Pro werden leere Geometrien automatisch vom Ergebnis abgeschnitten.\n\n\n\n\n\n\n\n\nAbbildung 15.3: Auszug aus Datenbankschema",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-10-flächen-berechnen-in-arcgis-pro-und-sql",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-10-flächen-berechnen-in-arcgis-pro-und-sql",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "Übung 10: Flächen berechnen in ArcGIS Pro und SQL",
    "text": "Übung 10: Flächen berechnen in ArcGIS Pro und SQL\nIn der Übung 10 wurden Flächen ausgeschieden, welche von den betroffenen Beeten abgegeben werden müssen. Die genauen Flächengrössen sollen jetzt berechnet werden (Abbildung 15.4).\n\nWelche Beete müssen wie viel Fläche abgeben? Berechnen Sie die Fläche pro Beet in qm.\n\nLegen Sie dazu in ArcGIS Pro ein neues Feld in der Attributtabelle ihres gespeicherten Layers an und berechnen dort die jeweiligen Einzelflächen in qm (Calculate Geometry). Haben Sie das Ergebnis in einer Geodatenbank gespeichert gibt es bereits das Attribut shape_area mit der Fläche in qm.\nErstellen Sie in pgAdmin eine Abfrage in SQL, welche ebenfalls die jeweiligen Einzelflächen in qm ausgibt. Ergänzen Sie dazu die SQL-Abfrage aus Übung 9 mit einem neuen Feld, welches die Fläche ausgibt. Wenden Sie dazu die Funktion ST_AREA auf das Geometriefeld an.\nVisualisieren Sie das Ergebnis erneut mit “Make Query Layer”.\n\n\n\n\n\n\n\n\nAbbildung 15.4: Auszug aus Datenbankschema",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-11-geometrien-ausschneiden-mit-erase",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-11-geometrien-ausschneiden-mit-erase",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "Übung 11: Geometrien ausschneiden mit “Erase”",
    "text": "Übung 11: Geometrien ausschneiden mit “Erase”\nAls nächstes wollen wir die grosse Hauptwege-Achse zu unseren Flächen hinzufügen. Hierzu haben wir eine weitere Feature Class in der Datenbank mit der Hauptwegeachse zur Verfügung. Leider enthält die Feature Class nur die Aussengrenzen des Weges. Da es auf dem Weg auch Beete gibt, wollen wir diese Beetflächen aus der Wegfläche ausschneiden (siehe Abbildung 15.5).\n\nSchneiden Sie die Beetflächen aus der Wegeachse aus. Nutzen Sie dafür:\n\nIn ArcGIS Pro das Werkzeug “Erase” und speichern das Ergebnis als neue Feature Class oder als Shapefile in Ihrem Ordner.\nFormulieren Sie in pgAdmin den SQL-Befehl mit der Funktion ST_DIFFERENCE und zeigen Sie das Resultat mit “Make Query Layer” auf der Karte. Geben Sie dabei zusätzlich die id der Fläche sowie die Attribute name_standort und name_bereich mit aus.\n\nVergleichen Sie die Ergebnisse.\n\n\n\n\n\n\n\nTipp\n\n\n\nDiese Anfrage funktioniert in zwei Schritten mit einer verschachtelten Abfrage (aber trotzdem in einem SQL-Befehl). Um Polygone auszuschneiden, müssen wir zunächst alle Wegeflächen und alle sonstigen Flächen aus der Tabelle “flaechen_shp” zu jeweils einem Polygon zusammenfügen (ST_Union), damit wir nur noch zwei Flächen miteinander vergleichen müssen. Anschliessend werden die beiden Flächen dann mit dem Werkzeug ST_Difference untersucht.\nDie Funktion ST_Difference berechnet für jedes eingeschlossene Polygon einmal die Differenzmenge aus der Wegefläche und allen eingeschlossenen Polygonen. Dadurch hat das Ergebnis eigentlich zu viele Einträge, für jedes eingeschlossene Polygon ein Eintrag, welche aber alle dieselbe Geometrie aufweisen. Der Parameter LIMIT 1 limitiert die Ausgabe auf ein Feature.\n\n\n\n\n\n\n\n\nAbbildung 15.5: Auszug aus Datenbankschema",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-12-geometrien-ausschneiden-mit-clip",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-12-geometrien-ausschneiden-mit-clip",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "Übung 12: Geometrien ausschneiden mit “Clip”",
    "text": "Übung 12: Geometrien ausschneiden mit “Clip”\nAls nächstes möchten wir alle Pflanzen suchen, welche auf bereits kartierten Flächen stehen. Hierzu nehmen wir den Punktdatensatz der Pflanzen und verschneiden diesen mit den bereits vorhandenen Beet-Flächen (siehe Abbildung 15.6).\n\nSuchen Sie alle Standorte (Punkte) der Pflanzen, welche auf kartierten Flächen stehen.\n\nIn ArcGIS Pro verwenden Sie das Werkzeug “Clip” und schneiden damit überflüssige Punkte weg. Speichern Sie das Resultat in Ihrem Ordner. Alternativ würde auch ein “Select by Location” gehen.\nFormulieren Sie auch hierzu die SQL-Anfrage in pgAdmin, welche alle Punkte auf den Flächen zurückgibt. Sie können dazu wieder die Funktion ST_INTERSECTION nutzen. Achten Sie darauf, dass wir dabei wieder nur diejenigen Punkte haben wollen, welche auch wirklich in Beziehung zu den Flächen stehen. Diesen Filter müssen Sie im WHERE-Abschnitt bereitstellen. Verwenden Sie dafür diesmal die Funktion ST_INTERSECTS. Binden Sie ausserdem noch die Attribute id_pflanze (objectid) und id_spezies in die Ausgabe ein und sortieren die Liste danach anhand der id_pflanze.\n\n\n\n\n\n\n\n\nAbbildung 15.6: Auszug aus Datenbankschema",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/1_Einleitung.html",
    "href": "C_Programmieren_1/1_Einleitung.html",
    "title": "Programmieren I",
    "section": "",
    "text": "Vorbereitung\nIn diesem Block bekommt ihr euren ersten Kontakt mit Python. Er soll einen Einstieg in die Programmierwelt von Python bieten und spezifisch zeigen, wie man räumliche Fragestellungen mit frei verfügbarer Software lösen kann. Die Voraussetzung für diesen Kurs ist eine Offenheit, neue Tools und Ansätze kennen zu lernen, die Bereitschaft für lösungsorientiertes Arbeiten sowie etwas Hartnäckigkeit.\nUm Python sinnvoll lernen und anwenden zu können, müsst ihr ein paar Programme installieren. Die folgenden Kapitel leiten euch dabei an.",
    "crumbs": [
      "Programmieren I"
    ]
  },
  {
    "objectID": "C_Programmieren_1/1_Einleitung.html#vorbereitung",
    "href": "C_Programmieren_1/1_Einleitung.html#vorbereitung",
    "title": "Programmieren I",
    "section": "",
    "text": "Positron IDE\nUm mit R zu programmieren, habt ihr bisher in RStudio gearbeitet. RStudio ist eine sogenannte “Integrierte Entwicklungsumgebung” (Integrated development environment, IDE), wo ihr eure R-Scripts entwicklen konntet. Posit, die Hersteller von RStudio, haben eine zweite IDE erstellt, die von der Bedienung sehr ähnlich ist wie RStudio, aber Python besser unterstützt. Diese IDE heisst Positron und ist ebenfalls kostenlos und mit freiem Quellcode verfügbar.\nLadet die neuste Version von Positron für euer Betriebssystem herunter (siehe hier) und installiert diese.\n\n\nPython\nIm Modul Angewandte Geoinformatik benutzen wir Python. Mit der Installation von ArcGIS sollte Python bereits installiert sein. Es muss also lediglich getestet werden, ob dies auch wie erwartet funktioniert. Bitte führt die Instruktionen unter dem Punkt Windows (s.u.) durch.\nWer lieber auf einem anderen Betriebssystem als Windows arbeiten möchte, sollte es für den Teil Programmieren I - III auch können. In diesem Fall braucht es aber ein bisschen Vorbereitung. Befolgt in diesem Fall die Schritte Mac / Linux (s.u.).\n\nWindowsMac / Linux\n\n\nMit ArcGIS Installation\nUm zu testen, ob die Installation bei Dir auch funktioniert, musst Du die paar Schritte ausführen:\n\nPython Command Prompt suchen und starten (siehe Terminal)\nFolgender Befehl eingeben:\npython3 --version   \n# oder:\npython --version\nWenn der obige Befehl eine Fehlermeldung verursacht, bitte die Anleitung Mac / Linux befolgen.\n\n\n\nOhne ArcGIS Installation\nWer keine ArcGIS Installation hat, sollte folgendermassen vorgehen:\n\nÜberprüfe, ob Python ≥ 3.11 installiert ist. Tippe dafür folgenden Befehl in den Terminal:\npython3 --version   \n# oder:\npython --version\nWenn Python nicht vorhanden oder die Version &lt; 3.11 ist, solltet ihr eine aktuelle Version von Python installieren: https://www.python.org/downloads/\nInstalliert Miniconda von dieser Website: https://docs.conda.io/projects/miniconda/en/latest/. Wählt den installer für eure Plattform aus, und verwendet nicht den grossen grünnen Button “Download Anaconda”.",
    "crumbs": [
      "Programmieren I"
    ]
  },
  {
    "objectID": "C_Programmieren_1/1_Einleitung.html#daten",
    "href": "C_Programmieren_1/1_Einleitung.html#daten",
    "title": "Programmieren I",
    "section": "Daten",
    "text": "Daten\nIm Kurs werdet ihr nachstehende Datensätze benötigen, die ihr im Moodlekurs unter Programmieren I → Datensätze herunterladen könnt.\n\n\n\nTabelle 1: Datensätze für den Teil “Programmieren I - III”\n\n\n\n\n\n\n\n\n\nDatensatz\nBeschreibung\n\n\n\n\nzeckenstiche.csv\nEine CSV mit 10 Zeckenstich-Meldungen im Kanton Zürich\n\n\nzeckenstiche_full.csv\nEine CSV mit 1’076 Zeckenstich-Meldungen im Kanton Zürich\n\n\nwald.gpkg\nEin Geodatensatz mit einem flächendeckenden (lückenlosen) Polygon, welche den Kanton Zürich in “Wald” und “nicht Wald” unterscheidet",
    "crumbs": [
      "Programmieren I"
    ]
  },
  {
    "objectID": "C_Programmieren_1/2_Python-Command-Prompt.html",
    "href": "C_Programmieren_1/2_Python-Command-Prompt.html",
    "title": "Software Anleitungen",
    "section": "",
    "text": "Conda Environment erstellen\nMit der Software conda verwalten wir unsere Python Packages in sogenannte Conda Environments. Wenn ihr auf Windows mit einer ArcGIS installation arbeitet, verwendet ihr für Conda den Python Command Prompt, wenn ihr auf Mac / Linux arbeitet, verwendet ihr für Conda den Terminal innerhalb von Positron (siehe Terminal).\nFolgende commands erstellen die Environment für den ersten Kurstag (sollte einzeln ausgeführt werden!):",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Software Anleitungen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/2_Python-Command-Prompt.html#sec-conda-env",
    "href": "C_Programmieren_1/2_Python-Command-Prompt.html#sec-conda-env",
    "title": "Software Anleitungen",
    "section": "",
    "text": "conda create --name geopython1\nconda activate geopython1\nconda install -c conda-forge jupyterlab pandas matplotlib",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Software Anleitungen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/2_Python-Command-Prompt.html#sec-wd",
    "href": "C_Programmieren_1/2_Python-Command-Prompt.html#sec-wd",
    "title": "Software Anleitungen",
    "section": "Arbeitsordner / Working Directory erstellen",
    "text": "Arbeitsordner / Working Directory erstellen\nUm in Positron arbeiten zu können, braucht ihr eine designierte Working Directory. Erstellt auf eurem Computer einen solchen Ordner, wo ihr die Pythonskripts und die zugehörigen Daten abspeichern könnt. Diese lautet zum Beispiel:\nC:\\Pfad\\zu\\deinem\\Modul-AGI-Kurs\\Programmieren1\\Python_Code",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Software Anleitungen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/2_Python-Command-Prompt.html#positron-starten-und-verwenden",
    "href": "C_Programmieren_1/2_Python-Command-Prompt.html#positron-starten-und-verwenden",
    "title": "Software Anleitungen",
    "section": "Positron starten und verwenden",
    "text": "Positron starten und verwenden\nStartet Positron und klickt auf File → Open Folder und öffnet den Pfad, den ihr im letzten Schritt erstellt habt (Arbeitsordner / Working Directory erstellen). Jetzt solltet ihr die Environment, die ihr in Conda Environment erstellen erstellt habt, als Python interpreter nutzen können (siehe Abbildung 16.1).\n\n\n\n\n\n\nAbbildung 16.1: Wenn Positron erstellte Environment findet, kann diese im Dropdown (drei Pünktchen neben Python) ausgewählt werden\n\n\n\nDie Erfahrung hat aber gezeigt, dass Positron diese erstellten Environments nicht immer findet. Sollte dies der Fall sein, gibt es den folgenden Workaround:\nStartet Positron aus der Conda Environment mit dem entsprechenden Befehl im Terminal (siehe Terminal). Verwendet dazu den Pfad, den ihr im Schritt Arbeitsordner / Working Directory erstellen erstellt habt.\nconda activate geopython1                                      \n          # ↓ euer Pfad verwenden!\npositron C:/Pfad/zu/deinem/Modul-AGI-Kurs/Programmieren1/Python_Code\nNun wird in Positron automatisch eure erstellte Environment (geopython1) verwendet.",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Software Anleitungen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/2_Python-Command-Prompt.html#sec-terminal",
    "href": "C_Programmieren_1/2_Python-Command-Prompt.html#sec-terminal",
    "title": "Software Anleitungen",
    "section": "Terminal",
    "text": "Terminal\n\nMit ArcGIS installation (Windows)Ohne ArcGIS installation (Linux / Mac)\n\n\nStartet dazu den Python Command Prompt, indem ihr Windowstaste drückt und nach dieser Applikation sucht (einfach den Namen eingeben). Nach dem Öffnen der Applikation sollte sich ein schwarzes Fenster öffnen und auf eure Eingabe warten (siehe Abbildung 16.2).\n\n\n\n\n\n\nAbbildung 16.2: Python Command Prompt (i.e. “Eingabeaufforderung”)\n\n\n\n\n\nVerwendet als Terminal den TERMINAL innerhalb von Positron (rechts von CONSOLE)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Software Anleitungen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/3_Primitive_Datentypen.html",
    "href": "C_Programmieren_1/3_Primitive_Datentypen.html",
    "title": "Primitive Datentypen",
    "section": "",
    "text": "Boolean\nBei primitiven Datentypen handelt es sich um die kleinste Einheit der Programmiersprache, sie werden deshalb auch “atomare Datentypen” genannt. Alle komplexeren Datentypen (Tabellarische Daten, Bilder, Geodaten) basieren auf diesen einfachen Strukturen. Die für uns wichtigsten Datentypen lauten: Boolean, String, Integer und Float. Das sind ähnliche Datentypen wie ihr bereits aus R kennt:\nHierbei handelt es sich um den einfachsten Datentyp. Er beinhaltet nur zwei Zustände: Wahr oder Falsch. In Python werden diese mit True oder False definiert (diese Schreibweise muss genau beachtet werden). Beispielsweise sind das Antworten auf geschlossene Fragen.\nregen = True # \"es regnet\"\n\nsonne = False # \"die Sonne scheint nicht\"\n\ntype(sonne)\n\nbool\nUm zu prüfen, ob ein bestimmter Wert True oder False ist, verwendet man is True. Will man also fragen, ob es regnet, wird dies folgendermassen formuliert:\n# regnet es?\nregen is True\n\nTrue\nOb die Sonne scheint, lautet folgendermassen (natürlich müssen dazu die Variabel sonne bereits existieren):\n# scheint die Sonne?\nsonne is True\n\nFalse",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Primitive Datentypen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/3_Primitive_Datentypen.html#string",
    "href": "C_Programmieren_1/3_Primitive_Datentypen.html#string",
    "title": "Primitive Datentypen",
    "section": "String",
    "text": "String\nIn sogenannten Strings werden Textinformationen gespeichert. Beispielsweise können das die Namen von Ortschaften sein.\n\nstadt = \"Bern\"\nland = \"Schweiz\"\n\ntype(stadt)\n\nstr\n\n\nStrings können mit + miteinander verbunden werden\n\nstadt + \" ist die Hauptstadt der \" + land\n\n'Bern ist die Hauptstadt der Schweiz'",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Primitive Datentypen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/3_Primitive_Datentypen.html#integer",
    "href": "C_Programmieren_1/3_Primitive_Datentypen.html#integer",
    "title": "Primitive Datentypen",
    "section": "Integer",
    "text": "Integer\nIn Integer werden ganzzahlige Werte gespeichert, beispielsweise die Anzahl Einwohner einer Stadt.\n\nbern_einwohner = 133115\n\ntype(bern_einwohner)\n\nint",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Primitive Datentypen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/3_Primitive_Datentypen.html#float",
    "href": "C_Programmieren_1/3_Primitive_Datentypen.html#float",
    "title": "Primitive Datentypen",
    "section": "Float",
    "text": "Float\nAls Float werden Zahlen mit Nachkommastellen gespeichert, wie zum Beispiel die Temperatur in Grad Celsius.\n\nbern_flaeche = 51.62\n\ntype(bern_flaeche)\n\nfloat",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Primitive Datentypen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html",
    "href": "C_Programmieren_1/4_Uebung_1.html",
    "title": "Übung 1",
    "section": "",
    "text": "Übung 1.1\nErstelle eine Variabel vorname mit deinem Vornamen und eine zweite Variabel nachname mit deinem Nachnamen. Was sind vorname und nachname für Datentypen?\nMusterlösung\nvorname = \"Guido\"\nnachname = \"van Rossum\"\n\ntype(vorname) # es handelt sich um den Datentyp \"str\", also String (Text)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html#übung-1.2",
    "href": "C_Programmieren_1/4_Uebung_1.html#übung-1.2",
    "title": "Übung 1",
    "section": "Übung 1.2",
    "text": "Übung 1.2\n“Klebe” Vor- und Nachname mit einem Leerschlag dazwischen zusammen.\n\n\nMusterlösung\nvorname + \" \" + nachname",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html#übung-1.3",
    "href": "C_Programmieren_1/4_Uebung_1.html#übung-1.3",
    "title": "Übung 1",
    "section": "Übung 1.3",
    "text": "Übung 1.3\nErstelle eine Variabel groesse_cm mit deiner Körpergrösse in Zentimeter. Was ist das für ein Datentyp?\n\n\nMusterlösung\ngroesse_cm = 184\ntype(groesse_cm) # es handelt sich hierbei um den Datentyp \"integer\"",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html#übung-1.4",
    "href": "C_Programmieren_1/4_Uebung_1.html#übung-1.4",
    "title": "Übung 1",
    "section": "Übung 1.4",
    "text": "Übung 1.4\nErmittle deine Grösse in Fuss auf der Basis von groesse_cm (1 Fuss entspricht 30.48 cm). Was ist das für ein Datentyp?\n\n\nMusterlösung\ngroesse_fuss = groesse_cm / 30.48\ntype(groesse_fuss) # es handelt sich um den Datentyp \"float\"",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html#übung-1.5",
    "href": "C_Programmieren_1/4_Uebung_1.html#übung-1.5",
    "title": "Übung 1",
    "section": "Übung 1.5",
    "text": "Übung 1.5\nErstelle eine boolsche Variable blond und setzte sie auf True, wenn diese Eigenschaft auf dich zutrifft, und False, falls nicht.\n\n\nMusterlösung\nblond = False",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html#übung-1.6",
    "href": "C_Programmieren_1/4_Uebung_1.html#übung-1.6",
    "title": "Übung 1",
    "section": "Übung 1.6",
    "text": "Übung 1.6\nErstelle eine Variabel einwohner mit der Einwohnerzahl der Schweiz (8’603’900, per 31. Dezember 2019). Erstelle eine zweite Variabel flaeche (ohne Umlaute!) mit der Flächengrösse der Schweiz (41’285 km\\(^2\\)). Berechne nun die Einwohnerdichte.\n\n\nMusterlösung\neinwohner = 8603900\nflaeche = 41285\n\ndichte = einwohner / flaeche\n\ndichte",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html#übung-1.7",
    "href": "C_Programmieren_1/4_Uebung_1.html#übung-1.7",
    "title": "Übung 1",
    "section": "Übung 1.7",
    "text": "Übung 1.7\nErstelle eine Variabel gewicht_kg (kg) und groesse_m (m) und berechne aufgrund von gewicht_kg und groesse_m ein BodyMassIndex (\\(BMI=\\frac{m}{l^2}\\), \\(m\\): Körpermasse in Kilogramm, \\(l\\): Körpergrösse in Meter).\n\n\nMusterlösung\ngewicht_kg = 85\ngroesse_m = groesse_cm / 100\n\ngewicht_kg / (groesse_m * groesse_m)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/5_Komplexe_Datentypen.html",
    "href": "C_Programmieren_1/5_Komplexe_Datentypen.html",
    "title": "Komplexe Datentypen",
    "section": "",
    "text": "Im letzten Kapitel haben wir primitive Datentypen angeschaut. Diese stellen eine gute Basis dar, in der Praxis haben wir aber meistens nicht einen Temperaturwert, sondern eine Liste von Temperaturwerten. Wir haben nicht einen Vornamen, sondern eine Tabelle mit Vor- und Nachnamen. Dafür gibt es in Python komplexere Datenstrukturen die als Gefässe für primitive Datentypen betrachtet werden können. Auch hier finden wir viele Ähnlichkeiten mit R:\n\n\n\n\n\n\n\n\n\n\nPython\nR\nBeschreibung\nBeispiel\n\n\n\n\n\nList\n(Vector)\nwerden über die Position abgerufen\nBeachtet die eckigen Klammern: hexerei = [3,2,1]\n\n\n\nDict\nList\nwerden über ein Schlüsselwort abgerufen\nBeachtet die geschweiften Klammern: langenscheidt = {\"trump\":\"erdichten\"}\n\n\n\nDataFrame\nDataframe\nTabellarische Daten\nSpezialfall einer dict pd.DataFrame({\"x\":[1,2,3], \"y\": [3,4,5]}\n\n\n\n\nIn Python gibt es noch weitere komplexe Datentypen wie Tuples und Sets. Diese spielen in unserem Kurs aber eine untergeordnete Rolle. Ich erwähne an dieser Stelle zwei häufig genannte Typen, damit ihr sie schon mal gehört habt:\n\nTuples:\n\nsind ähnlich wie Lists, nur können sie nachträglich nicht verändert werden. Das heisst, es ist nach der Erstellung keine Ergänzung von neuen Werten oder Löschung von bestehenden Werten möglich.\nsie werden mit runden Klammern erstellt: mytuple = (2,2,1)\n\nSets\n\nsind ähnlich wie Dicts, verfügen aber nicht über keys und values\njeder Wert wird nur 1x gespeichert (Duplikate werden automatisch entfernt)\nsie werden mit geschweiften Klammern erstellt: myset = {3,2,2}\n\n\nWohl das einfachste Gefäss, um mehrere Werte zu speichern, sind Python-Listen, sogenannte Lists. Diese Lists werden mit eckigen Klammern erstellt. Die Reihenfolge, in denen die Werte angegeben werden, wird gespeichert. Das erlaubt es uns, bestimmte Werte aufgrund ihrer Position abzurufen.\nEine List wird folgendermassen erstellt:\n\nhexerei = [3,1,2]\n\nDer erste Wert wird in Python mit 0 (!!!) aufgerufen:\n\nhexerei[0]\n\n3\n\n\n\ntype(hexerei)\n\nlist\n\n\nIm Prinzip sind Lists ähnlich wie Vectors in R, mit dem Unterschied, dass in Python-Lists unterschiedliche Datentypen abgespeichert werden können. Zum Beispiel auch weitere, verschachtelte Lists:\n\nchaos = [23, \"ja\", [1,2,3]]\n\n\n# Der Inhalt vom ersten Wert ist vom Typ \"Int\"\ntype(chaos[0])\n\nint\n\n\n\n# Der Inhalt vom dritten Wert ist vom Typ \"List\"\n\ntype(chaos[2])\n\nlist",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Komplexe Datentypen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html",
    "href": "C_Programmieren_1/6_Uebung_2.html",
    "title": "Übung 2",
    "section": "",
    "text": "Übung 2.1\nMusterlösung\nvornamen = [\"Christopher\", \"Henning\", \"Severin\"]\nnachnamen = [\"Annen\", \"May\", \"Kantereit\"]\n\ngroessen = [174, 182, 162]",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#übung-2.1",
    "href": "C_Programmieren_1/6_Uebung_2.html#übung-2.1",
    "title": "Übung 2",
    "section": "",
    "text": "Erstelle eine Variable vornamen bestehend aus einer List mit 3 Vornamen\nErstelle eine zweite Variable nachnamen bestehend aus einer List mit 3 Nachnamen\nErstelle eine Variable groessen bestehend aus einer List mit 3 Grössenangaben in Zentimeter.",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#übung-2.2",
    "href": "C_Programmieren_1/6_Uebung_2.html#übung-2.2",
    "title": "Übung 2",
    "section": "Übung 2.2",
    "text": "Übung 2.2\nWie erhältst du den ersten Eintrag in der Variable vornamen?\n\n\nMusterlösung\nvornamen[0]",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#übung-2.3",
    "href": "C_Programmieren_1/6_Uebung_2.html#übung-2.3",
    "title": "Übung 2",
    "section": "Übung 2.3",
    "text": "Übung 2.3\nListen können durch die Methode append ergänzt werden (s.u.). Ergänze die Listen vornamen, nachnamen und groessen durch je einen Eintrag.\n\nvornamen.append(\"Malte\")\n\n\n\nMusterlösung\nnachnamen.append(\"Huck\")\n\ngroessen.append(177)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#übung-2.4",
    "href": "C_Programmieren_1/6_Uebung_2.html#übung-2.4",
    "title": "Übung 2",
    "section": "Übung 2.4",
    "text": "Übung 2.4\nErmittle die Summe aller Werte in groessen. Tipp: Nutze dazu sum()\n\n\nMusterlösung\nsum(groessen)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#übung-2.5",
    "href": "C_Programmieren_1/6_Uebung_2.html#übung-2.5",
    "title": "Übung 2",
    "section": "Übung 2.5",
    "text": "Übung 2.5\nErmittle die Anzahl Werte in groessen . Tipp: Nutze dazu len()\n\n\nMusterlösung\nlen(groessen)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#sec-mittelwert",
    "href": "C_Programmieren_1/6_Uebung_2.html#sec-mittelwert",
    "title": "Übung 2",
    "section": "Uebung 2.6",
    "text": "Uebung 2.6\nBerechne die durchschnittliche Grösse aller Personen in groessen. Tipp: Nutze dazu len() und sum().\n\n\nMusterlösung\nsum(groessen) / len(groessen)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#übung-2.7",
    "href": "C_Programmieren_1/6_Uebung_2.html#übung-2.7",
    "title": "Übung 2",
    "section": "Übung 2.7",
    "text": "Übung 2.7\nErmittle nun noch die Minimum- und Maximumwerte aus groessen (finde die dazugehörige Funktion selber heraus).\n\n\nMusterlösung\nmin(groessen)\nmax(groessen)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/8_Dictionary.html",
    "href": "C_Programmieren_1/8_Dictionary.html",
    "title": "Dictionaries",
    "section": "",
    "text": "In den letzten Übungen haben wir einen Fokus auf Listen gelegt. Nun wollen wir ein besonderen Fokus auf den Datentyp Dictionary legen.\nÄhnlich wie eine List ist eine Dictionary ein Behälter, wo mehrere Elemente abgespeichert werden können. Wie bei einem Wörterbuch bekommt jedes Element ein “Schlüsselwort”, mit dem man den Eintrag finden kann. Unter dem Eintrag “trump” findet man im Langenscheidt Wörterbuch (1977) die Erklärung “erdichten, schwindeln, sich aus den Fingern saugen”.\n\nIn Python würde man diese Dictionary folgendermassen erstellen:\n\nlangenscheidt = {\"trump\":\"erdichten- schwindeln- sich aus den Fingern saugen\"}\n\nSchlüssel (von nun an mit Key bezeichnet) des Eintrages lautet “trump” und der dazugehörige Wert (Value) “erdichten- schwindeln- aus den Fingern saugen”. Beachte die geschweiften Klammern ({ und }) bei der Erstellung einer Dictionary.\nEine Dictionary besteht aber meistens nicht aus einem, sondern aus mehreren Einträgen: Diese werden Kommagetrennt aufgeführt.\n\nlangenscheidt = {\"trump\":\"erdichten- schwindeln- sich aus den Fingern saugen\", \"trumpery\":\"Plunder- Ramsch- Schund\"}\n\nDer Clou der Dictionary ist, dass man nun einen Eintrag mittels dem Key aufrufen kann. Wenn wir also nun wissen wollen, was “trump” heisst, ermitteln wir dies mit der nachstehenden Codezeile:\n\nlangenscheidt[\"trump\"]\n\n'erdichten- schwindeln- sich aus den Fingern saugen'\n\n\nUm eine Dictionary mit einem weiteren Eintrag zu ergänzen, geht man sehr ähnlich vor wie beim Abrufen von Einträgen.\n\nlangenscheidt[\"trumpet\"] = \"trompete\" \n\nEin Key kann auch mehrere Einträge enthalten. An unserem Langenscheidt Beispiel: Das Wort “trump” ist zwar eindeutig, doch “trumpery” hat vier verschiedene Bedeutungen. In so einem Fall können wir einem Eintrag auch eine List von Werten zuweisen. Beachte die eckigen Klammern und die Kommas, welche die Listeneinträge voneinander trennt.\n\nlangenscheidt[\"trumpery\"] = [\"Plunder- Ramsch- Schund\", \n                             \"Gewäsch- Quatsch\", \n                             \"Schund- Kitsch\", \n                             \"billig- nichtssagend\"]    \nlangenscheidt[\"trumpery\"]\n\n['Plunder- Ramsch- Schund',\n 'Gewäsch- Quatsch',\n 'Schund- Kitsch',\n 'billig- nichtssagend']\n\n\n\nlen(langenscheidt[\"trumpery\"])\n\n4",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html",
    "href": "C_Programmieren_1/9_Uebung_3.html",
    "title": "Übung 3",
    "section": "",
    "text": "Übung 3.1\nErstelle eine Dictionary mit folgenden Einträgen: Vorname und Nachname von (d)einer Person. Weise diese Dictionary der Variable me zu.\nMusterlösung\nme = {\"vorname\": \"Guido\", \"nachname\": \"van Rossum\"}",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.2",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.2",
    "title": "Übung 3",
    "section": "Übung 3.2",
    "text": "Übung 3.2\nRufe verschiedene Elemente aus der Dictionary via Key ab.\n\n\nMusterlösung\nme[\"nachname\"]",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.3",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.3",
    "title": "Übung 3",
    "section": "Übung 3.3",
    "text": "Übung 3.3\nNutze me, um nachstehenden Satz (mit deinen Values) zu erstellen:\n\n\nMusterlösung\n\"Mein Name ist \"+me[\"nachname\"] +\", \"+ me[\"vorname\"]+\" \"+me[\"nachname\"]\n\n\n'Mein Name ist van Rossum, Guido van Rossum'",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.4",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.4",
    "title": "Übung 3",
    "section": "Übung 3.4",
    "text": "Übung 3.4\nErgänze die Dictionary me durch einen Eintrag “groesse” mit (d)einer Grösse.\n\n\nMusterlösung\nme[\"groesse\"] = 181",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.5",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.5",
    "title": "Übung 3",
    "section": "Übung 3.5",
    "text": "Übung 3.5\nErstelle eine neue Dictionary people mit den Keys “vornamen”, “nachnamen” und “groesse” und jeweils 3 Einträge pro Key.\n\n\nMusterlösung\npeople = {\"vornamen\": [\"Christopher\", \"Henning\", \"Severin\"], \"nachnamen\": [\"Annen\",\"May\", \"Kantereit\"], \"groessen\": [174, 182, 162]}",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.6",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.6",
    "title": "Übung 3",
    "section": "Übung 3.6",
    "text": "Übung 3.6\nRufe den ersten Vornamen deiner Dict auf. Dazu musst du dein Wissen über Listen und Dictionaries kombinieren.\n\n\nMusterlösung\npeople[\"vornamen\"][0]",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.7",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.7",
    "title": "Übung 3",
    "section": "Übung 3.7",
    "text": "Übung 3.7\nRufe den dritten Nachname deiner Dict auf.\n\n\nMusterlösung\npeople[\"nachnamen\"][2]",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.8",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.8",
    "title": "Übung 3",
    "section": "Übung 3.8",
    "text": "Übung 3.8\nBerechne den Mittelwert aller grössen in deiner Dict\n\n\nMusterlösung\nsum(people[\"groessen\"])/len(people[\"groessen\"])",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/10_Tabellarische_Daten.html",
    "href": "C_Programmieren_1/10_Tabellarische_Daten.html",
    "title": "DataFrames",
    "section": "",
    "text": "Schauen wir uns nochmals die Dictionary people aus der letzten Übung an. Diese ist ein Spezialfall einer Dictionary: Jeder Eintrag besteht aus einer Liste von gleich vielen Werten. Wie bereits erwähnt, kann es in einem solchen Fall sinnvoll sein, die Dictionary als Tabelle darzustellen.\n\npeople = {\"vornamen\": [\"Christopher\", \"Henning\", \"Severin\"], \"nachnamen\": [\"Annen\",\"May\", \"Kantereit\"], \"groessen\": [174, 182, 162]}\n\n\nimport pandas as pd # Was diese Zeile beudeutet lernen wir später\n\npeople_df = pd.DataFrame(people)\n\npeople_df\n\n\n\n\n\n\n\n\nvornamen\nnachnamen\ngroessen\n\n\n\n\n0\nChristopher\nAnnen\n174\n\n\n1\nHenning\nMay\n182\n\n\n2\nSeverin\nKantereit\n162",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>DataFrames</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/11_Uebung_4.html",
    "href": "C_Programmieren_1/11_Uebung_4.html",
    "title": "Übung 4",
    "section": "",
    "text": "Übung 4.1\nImportiere pandas und nutze die Funktion DataFrame, um people in eine DataFrame umzuwandeln (siehe dazu das Beispiel unten). Weise den Output der Variablen people_df zu und schau dir people_df an.\nimport pandas as pd\n\npeople = {\"vornamen\": [\"Christopher\", \"Henning\", \"Severin\"], \"nachnamen\": [\"Annen\",\"May\", \"Kantereit\"], \"groessen\": [174, 182, 162]}\n\n\npeople_df = pd.DataFrame(people)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Übung 4</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/11_Uebung_4.html#sec-ex-to-csv",
    "href": "C_Programmieren_1/11_Uebung_4.html#sec-ex-to-csv",
    "title": "Übung 4",
    "section": "Übung 4.2",
    "text": "Übung 4.2\nIn der Praxis kommen tabellarische Daten meist als “csv” Dateien daher. Wir können aus unserer eben erstellten DataFrame sehr einfach eine csv-Datei erstellen. Führe das mit folgendem Code aus und suche anschliessend die erstellte csv-Datei.\n\npeople_df.to_csv(\"people.csv\")",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Übung 4</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/11_Uebung_4.html#sec-ex-import-zeckenstiche",
    "href": "C_Programmieren_1/11_Uebung_4.html#sec-ex-import-zeckenstiche",
    "title": "Übung 4",
    "section": "Übung 4.3",
    "text": "Übung 4.3\nGenau so einfach ist es, ein csv zu importieren. Lade die Datei “zeckenstiche.csv” (siehe Tabelle 1) herunter und speichere es im aktuellen Arbeitsverzeichnis ab. Importiere mit folgendem Code die Datei “zeckenstiche.csv”.\n\n# ich habe die Daten in einem Unterordner \"data\" abgespeichert\nzeckenstiche = pd.read_csv(\"data/zeckenstiche.csv\")",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Übung 4</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/11_Uebung_4.html#sec-ex-scatterplot",
    "href": "C_Programmieren_1/11_Uebung_4.html#sec-ex-scatterplot",
    "title": "Übung 4",
    "section": "Übung 4.4",
    "text": "Übung 4.4\nDie DataFrame zeckenstiche beinhaltet x und y Koordinaten für jeden Unfall in den gleichnamigen Spalten. Wir können die Stiche mit einem Scatterplot räumlich visualisieren. Führe dazu folgenden Code aus.\n\nfig = zeckenstiche.plot.scatter(\"x\",\"y\")\n\nfig.axis(\"equal\")\n# \"equal\" stellt sicher, das die x und y Achsen gleich skaliert sind\n# dies ist sinnvoll, da es sich ja um Schweizer Koordinaten (Meter) handelt",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Übung 4</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/11_Uebung_4.html#sec-ex-sel-col",
    "href": "C_Programmieren_1/11_Uebung_4.html#sec-ex-sel-col",
    "title": "Übung 4",
    "section": "Übung 4.5",
    "text": "Übung 4.5\nUm eine einzelne Spalte zu selektieren (z.B. die Spalte “ID”), kann man gleich vorgehen wie bei der Selektion eines Eintrags in einer Dictionary. Probiere es aus.\n\n\nMusterlösung\nzeckenstiche[\"ID\"]",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Übung 4</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/11_Uebung_4.html#sec-ex-new-col",
    "href": "C_Programmieren_1/11_Uebung_4.html#sec-ex-new-col",
    "title": "Übung 4",
    "section": "Übung 4.6",
    "text": "Übung 4.6\nAuch das Erstellen einer neuen Spalte ist identisch mit der Erstellung eines neuen Dictionary Eintrags. Erstelle eine neue Spalte “Stichtyp” mit dem Wert “Zecke” auf jeder Zeile (s.u.).\n\nzeckenstiche[\"Stichtyp\"] = \"Zecke\"\n\n\n\nMusterlösung\nzeckenstiche",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Übung 4</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/12_Uebung_5.html",
    "href": "C_Programmieren_1/12_Uebung_5.html",
    "title": "Übung 5",
    "section": "",
    "text": "Übung 5.1 Neue Conda Umgebung erstellen\nDiese letzte Übung dient lediglich der Vorbereitung auf Programmieren II. Ihr müsst die Übung nicht verstehen, sondern nur ausführen. Melde dich, falls es Probleme gibt.",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Übung 5</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/12_Uebung_5.html#übung-5.1-neue-conda-umgebung-erstellen",
    "href": "C_Programmieren_1/12_Uebung_5.html#übung-5.1-neue-conda-umgebung-erstellen",
    "title": "Übung 5",
    "section": "",
    "text": "Starte Python Command Prompt oder den Terminal in Positron (siehe Terminal)\nFühre den Befehl: conda create --name geopython2 aus\nBestätige die Installation mit y\nPrüfe, ob u.a. folgende Meldung im Terminal erscheint (melde dich falls nicht):\n#\n# To activate this environment, use\n#\n#     $ activate geopython2\n#\n# To deactivate an active environment, use\n#\n#     $ deactivate\nFühre den Befehl aus, der in der Meldung steht:\nactivate geopython2               # (Windows) \nconda activate geopython2         # (MacOS, Linux)\nPrüfe, ob die Eingabeforderung im Terminal nun mit (geopython2) beginnt (melde dich falls nicht)\n# ↓ vorher\n(arcgispro-py3) C:\\Program Files\\ArcGIS\\Pro\\bin\\Python\\envs\\arcgispro-py3&gt;\n\n# ↓ nachher\n(geopython2)  C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\geopython&gt;\nFühre den folgenden Befehl aus:\nconda install -c conda-forge jupyterlab geopandas matplotlib descartes\nBestätige die Installation mit y\nPrüfe, ob die Installation erfolgreich war (erscheint folgende Meldung im Terminal?):\nPreparing transaction: done\nVerifying transaction: done\nExecuting transaction: done\nRetrieving notices: ...working... done",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Übung 5</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/1_Einleitung.html",
    "href": "C_Programmieren_2/1_Einleitung.html",
    "title": "Programmieren II",
    "section": "",
    "text": "Letzte Woche habt ihr die wichtigsten Datentypen in Python kennen gelernt und sowohl den Command Prompt wie auch Positron verwendet. Diese Woche werden wir Python Module genauer beleuchten und dabei conda genauer kennenlernen. Zudem widmen wir uns dem Erstellen von Funktionen (Functions), Fallunterscheidungen (if und else) sowie dem Erstellen von Zufallszahlen.\n\n\n\n\n\n\nHinweisÜbungsziele\n\n\n\n\nConda verstehen und beherrschen\nPython Module verstehen\nFunctions kennenlernen und beherrschen\nFunction auf eine ganze Spalte einer DataFrame anwenden können.",
    "crumbs": [
      "Programmieren II"
    ]
  },
  {
    "objectID": "C_Programmieren_2/3_Python_Module.html",
    "href": "C_Programmieren_2/3_Python_Module.html",
    "title": "Python Modules",
    "section": "",
    "text": "Vergleich R vs. Python\nDer Umgang mit Modulen ist in Python in vielerlei Hinsicht ähnlich wie in R. An dieser Stelle möchten wir die Unterschiede in einem Direktvergleich beleuchten. Dafür verwenden wir ein fiktives Modul namens maler, in Anlehnung an die Analogie des Hausbauens mit Spezialisten (siehe Vorlesungsfolien). Nehmen wir an, dieses Modul existiert als Python Modul wie auch als R Library.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Python Modules</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/3_Python_Module.html#vergleich-r-vs.-python",
    "href": "C_Programmieren_2/3_Python_Module.html#vergleich-r-vs.-python",
    "title": "Python Modules",
    "section": "Was ist Conda?",
    "text": "Erweiterung installieren\nIn R ist die Installation einer Library selbst ein R-Befehl und wird innerhalb von R ausgeführt. Wenn wir keine Quelle angeben, woher die Library heruntergeladen werden soll, wird eine Default-Quelle verwendet, die im System hinterlegt ist (z.B. “https://cloud.r-project.org”).\nIn Python ist dies leider etwas komplizierter, es braucht für die Installation einer Python Library eine Zusatzsoftware wie zum Beispiel conda. Es gibt auch noch andere Wege, wie zum Beispiel pip, aber diese lassen wir zur Vereinfachung an dieser Stelle weg.\n\n\n\n\n\n\nHinweisExkurs Conda\n\n\n\n\n\nWas ist Conda?\nConda ist ein Verwaltungssystem für Python-Bibliotheken1, welches unter Windows, macOS und Linux läuft. Neben Conda gibt es noch den “Package Manager” pip, welchen wir im Unterricht aber nicht nutzen werden. Mit Conda lassen sich diese Libraries schnell installieren, ausführen und aktualisieren. Ein zusätzliches, wichtiges Feature von Conda ist die Verwaltung von sogenannten “virtuellen Umgebungen” (wie z.B. geopython1 bzw. geopython2, welche wir in Programmieren I erstellt haben). Diese Umgebungen ermöglichen es, dass Package-Installationen in abgeschottenen “Container” erfolgen. Das heisst, dass man unterschiedliche Versionen des gleichen Packages installieren kann, ohne das dies Probleme bereitet.\n\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nmaler ist ein fiktives Modul. Der unten stehende Code bitte nur lesen, nicht ausführen!\n\n\n\n\nin R:\ninstall.packages(\"maler\")\n\n\n\nIn Python:\nconda install -c conda-forge maler \n\n\n\n\nErweiterung laden\nUm eine Erweiterung nutzen zu können, müssen wir diese sowohl in R wie auch in Python in die aktuelle Session importieren. In R und Python sehen die Befehle folgendermassen aus:\n\n\nin R:\nlibrary(maler)\n\n\n\nin Python:\nimport maler\n\n\n\n\nErweiterung verwenden\nUm eine Funktion aus einer Library in R zu verwenden, kann ich diese Function direkt aufrufen. In Python hingegen muss ich entsprechende Erweiterung der Function mit einem Punkt voranstellen.\nDas ist zwar umständlicher, dafür aber weniger fehleranfällig. Angenommen zwei leicht unterschiedliche Funktionen heissen beide wand_bemalen(). Die eine stammt aus der Erweiterung maler, die andere aus der Erweiterung maurer. Wenn die Funktion in R aufgerufen wird ist nicht klar, aus welcher Library die Funktion verwendet werden soll. In Python ist im nachstehenden Beispiel unmissverständlich, dass wand_bemalen() aus dem Modul maler gemeint ist.\n\n\nin R:\nwand_bemalen()\n\n\n\nin Python:\nmaler.wand_bemalen()",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Python Modules</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/3_Python_Module.html#was-ist-conda",
    "href": "C_Programmieren_2/3_Python_Module.html#was-ist-conda",
    "title": "Python Modules",
    "section": "",
    "text": "Conda ist ein Verwaltungssystem für Python-Bibliotheken1, welches unter Windows, macOS und Linux läuft. Neben Conda gibt es noch den “Package Manager” pip, welchen wir im Unterricht aber nicht nutzen werden. Mit Conda lassen sich diese Libraries schnell installieren, ausführen und aktualisieren. Ein zusätzliches, wichtiges Feature von Conda ist die Verwaltung von sogenannten “virtuellen Umgebungen” (wie z.B. geopython1 bzw. geopython2, welche wir in Programmieren I erstellt haben). Diese Umgebungen ermöglichen es, dass Package-Installationen in abgeschottenen “Container” erfolgen. Das heisst, dass man unterschiedliche Versionen des gleichen Packages installieren kann, ohne das dies Probleme bereitet.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Python Modules</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/3_Python_Module.html#python-eigenheiten",
    "href": "C_Programmieren_2/3_Python_Module.html#python-eigenheiten",
    "title": "Python Modules",
    "section": "Python Eigenheiten",
    "text": "Python Eigenheiten\nIn Python gibt es in Bezug auf die Verwendung von Modulen ein paar Eigenheiten, die wir aus der R Welt nicht kennen. Es ist wichtig diese Eigenheiten zu kennen, denn man trifft sie immer wieder an.\n\nModul mit Alias importieren\nDa es umständlich sein kann, jedesmal maler.wand_bemalen() voll auszuschreiben, können wir dem Modul beim Import auch einen “Alias” vergeben. Für gewisse populäre Module haben sich solche Aliasse eingebürgert. Beispielsweise wird pandas meist mit dem Alias pd importiert. Es ist sinnvoll, sich an diese Konventionen zu halten. Übertragen auf unser maler beispiel sieht der Import mit einem Alias folgendermassen aus:\nimport maler as m               # importiert \"maler\" mit dem Alias \"m\"\nm.wand_bemalen()                # nun wird \"m.\" vorangestellt statt \"maler.\"\n\n\nEinzelne Function importieren\nEs gibt noch die Variante, explizit eine spezifische Function aus einem Modul zu laden. Wenn man dies macht, kann man die Funktion ohne vorangestelltes Modul nutzen (genau wie in R). Dies sieht folgendermassen aus:\nfrom maler import wand_bemalen  # importiert nur die Funktion \"wand_bemalen\"\nwand_bemalen()                  # das Voranstellen von \"maler.\" ist nun nicht nötig\n\n\nAlle Functions importieren\nZusätzlich ist es möglich, alle Functions aus einem Modul so zu importieren, dass der Modulname nicht mehr erwähnt werden muss. Diese Notation wird nicht empfohlen, aber es ist wichtig sie zu kennen.\nfrom maler import *             # importier alle Funktionen (*) von \"maler\"\nwand_bemalen()                  # das Voranstellen von \"maler.\" ist nun nicht nötig",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Python Modules</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/3_Python_Module.html#footnotes",
    "href": "C_Programmieren_2/3_Python_Module.html#footnotes",
    "title": "Python Modules",
    "section": "",
    "text": "Genau genommen ist Conda universell einsetzbar und kann auch Libraries von R und weiteren Programmiersprachen installieren.↩︎",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Python Modules</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/4_Functions_I.html",
    "href": "C_Programmieren_2/4_Functions_I.html",
    "title": "Function Basics",
    "section": "",
    "text": "Ein Grundprinzip von Programmieren ist “DRY” (Don’t repeat yourself). Wenn unser Script viele ähnliche Codezeilen enthält ist das ein Zeichen dafür, dass man besser eine Function schreiben sollte. Das hat viele Vorteile: Unter anderem wird der Code lesbarer, einfacher zu warten und kürzer.\nUm mit Python gut zurechtzukommen ist das Schreiben von eigenen Functions unerlässlich. Dies ist auch nicht weiter schwierig: Eine Function wird mit def eingeleitet, braucht einen Namen, einen Input und einen Output.\nWenn wir zum Beispiel eine Function erstellen wollen die uns grüsst, so geht dies folgendermassen:\n\ndef sag_hallo():\n    return \"Hallo!\"\n\n\nMit def sagen wir: “Jetzt definiere ich eine Function”.\nDanach kommt der Name der Function, in unserem Fall sag_hallo (mit diesem Namen können wir die Function später wieder aufrufen).\nAls Drittes kommen die runden Klammern, wo wir bei Bedarf Inputvariablen (sogenannte Parameter) festlegen können. In diesem ersten Beispiel habe ich keine Parameter festgelegt.\nNach der Klammer kommt ein Doppelpunkt was bedeutet: “jetzt wird gleich definiert, was die Funktion tun soll”.\nAuf einer neuen Zeile wird eingerückt festgelegt, was die Function eben tun soll. Meist sind hier ein paar Zeilen Code vorhanden.\nDie letzte eingerückte Zeile (in unserem Fall ist das die einzige Zeile) gibt mit return an, was die Function zurück geben soll (der Output). In unserem Fall soll sie “Hallo!” zurück geben.\n\nDas war’s schon! Jetzt können wir diese Function schon nutzen:\n\nsag_hallo()\n\n'Hallo!'\n\n\nDiese Function ohne Input ist wenig nützlich. Meist wollen wir der Function etwas - einen Input - übergeben können. Beispielsweise könnten wir der Function unseren Vornamen übergeben, damit wir persönlich gegrüsst werden:\n\ndef sag_hallo(vorname):\n    return \"Hallo \" + vorname + \"!\" \n\nNun können wir der Function ein Argument übergeben. In folgendem Beispiel ist vorname ein Parameter, “Guido” ist sein Argument.\n\nsag_hallo(vorname = \"Guido\")\n\n'Hallo Guido!'\n\n\nWir können auch eine Function gestalten, die mehrere Parameter annimmt. Beispielweise könnte sag_hallo() zusätzlich noch einen Parameter nachname erwarten:\n\ndef sag_hallo(vorname, nachname):\n    return \"Hallo \" + vorname + \" \" + nachname + \"!\" \n\n\nsag_hallo(vorname = \"Guido\", nachname = \"van Rossum\")\n\n'Hallo Guido van Rossum!'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>*Function* Basics</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/5_Uebung_6.html",
    "href": "C_Programmieren_2/5_Uebung_6.html",
    "title": "Übung 6",
    "section": "",
    "text": "Übung 6.1\nBevor du mit den Übungen anfägst, solltest du bereits eine eigene Conda Environment nach der Anleitung in Übung 5 “Übung 5” erstellt haben.\nErstelle eine Function, die gruezi heisst, einen Nachnamen als Input annimmt und per Sie grüsst.\n# Das Resultat soll in etwa folgendermassen aussehen:\ngruezi(nachname = \"van Rossum\")\n\n'Guten Tag, van Rossum'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Übung 6</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/5_Uebung_6.html#sec-gruezi2",
    "href": "C_Programmieren_2/5_Uebung_6.html#sec-gruezi2",
    "title": "Übung 6",
    "section": "Übung 6.2",
    "text": "Übung 6.2\nErstelle eine neue Funktion gruezi2 welche im Vergleich zu gruezi einen weiteren Parameter namens anrede annimmt.\n\n# Das Resultat soll in etwa folgendermassen aussehen:\ngruezi2(nachname = \"van Rossum\", anrede = \"Herr\")\n\n'Guten Tag, Herr van Rossum'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Übung 6</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/5_Uebung_6.html#übung-6.3",
    "href": "C_Programmieren_2/5_Uebung_6.html#übung-6.3",
    "title": "Übung 6",
    "section": "Übung 6.3",
    "text": "Übung 6.3\nErstelle eine Funktion add die zwei Zahlen summiert.\n\n# Das Resultat sollte folgendermassen aussehen:\nadd(zahl1 = 2, zahl2 = 10)\n\n12",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Übung 6</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/5_Uebung_6.html#übung-6.4",
    "href": "C_Programmieren_2/5_Uebung_6.html#übung-6.4",
    "title": "Übung 6",
    "section": "Übung 6.4",
    "text": "Übung 6.4\nErstelle eine Funktion square, welche den Input quadriert.\n\n# Das Resultat sollte folgendermassen aussehen:\nsquare(zahl = 5)\n\n25",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Übung 6</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/5_Uebung_6.html#übung-6.5",
    "href": "C_Programmieren_2/5_Uebung_6.html#übung-6.5",
    "title": "Übung 6",
    "section": "Übung 6.5",
    "text": "Übung 6.5\nErstelle eine Funktion meter_zu_fuss, die eine beliebige Zahl von Meter in Fuss konvertiert. Zur Erinnerung: 30.48 cm ergeben 1 Fuss.\n\n# Das Resultat sollte folgendermassen aussehen:\n\nmeter_zu_fuss(meter = 1.80)\n\n5.905511811023622",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Übung 6</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/6_Functions_II.html",
    "href": "C_Programmieren_2/6_Functions_II.html",
    "title": "Function Advanced",
    "section": "",
    "text": "Standart-Werte\nMan kann für einzelne (oder alle) Parameter auch Standardwerte festlegen. Das sind Werte die dann zum Zug kommen, wenn der Nutzer der Funktion das entsprechende Parameter leer lässt. Schauen wir dazu nochmals sag_hallo() an.\ndef sag_hallo(vorname):\n    return \"Hallo \" + vorname + \"!\"\nUm diese Funktion zu nutzen muss dem Parameter vorname ein Argument übergeben werden, sonst erhalten wir eine Fehlermeldung.\nsag_hallo()\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 sag_hallo()\n\nTypeError: sag_hallo() missing 1 required positional argument: 'vorname'\nWenn wir möchten, dass gewisse Parameter auch ohne Argument auskommen, dann könnnen wir einen Standartwert festlegen. So wird der Parameter optional. Bespielsweise könnte sag_hallo() einfach Hallo Du! zurückgeben, wenn kein Vorname angegeben wird. Um dies zu erreichen, definieren wir den Standartwert bereits innerhalb der Klammer, und zwar folgendermassen:\ndef sag_hallo(vorname = \"Du\"):\n    return \"Hallo \" + vorname + \"!\" \n\n# Wenn \"vorname\" nicht angegeben wird:\nsag_hallo()\n\n'Hallo Du!'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>*Function* Advanced</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/6_Functions_II.html#standart-werte",
    "href": "C_Programmieren_2/6_Functions_II.html#standart-werte",
    "title": "Function Advanced",
    "section": "",
    "text": "HinweisWichtig\n\n\n\nWenn mehrere Parameter in einer Funktion definiert werden, dann kommen die optionalen Parameter immer zum Schluss.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>*Function* Advanced</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/6_Functions_II.html#reihenfolge-der-argumente",
    "href": "C_Programmieren_2/6_Functions_II.html#reihenfolge-der-argumente",
    "title": "Function Advanced",
    "section": "Reihenfolge der Argumente",
    "text": "Reihenfolge der Argumente\nWenn die Argumente in der gleichen Reihenfolge eingegeben werden, wie sie in der Function definiert sind, müssen die Parameter nicht spezifiziert werden (z.B: anrede=, nachname=).\n\ndef gruezi2(nachname, anrede):\n    return \"Guten Tag, \" + anrede + \" \"+nachname\n\ngruezi2(\"van Rossum\", \"Herr\")\n\n'Guten Tag, Herr van Rossum'\n\n\nWenn wir die Reihenfolge missachten, ist der Output unserer Funktion fehlerhaft:\n\ngruezi2(\"Herr\", \"van Rossum\")\n\n'Guten Tag, van Rossum Herr'\n\n\nAber wenn die Parameter der Argumente spezifiziert werden, können wir sie in jeder beliebigen Reihenfolge auflisten:\n\ngruezi2(anrede = \"Herr\", nachname = \"van Rossum\")\n\n'Guten Tag, Herr van Rossum'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>*Function* Advanced</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/6_Functions_II.html#funktionen-auf-mehreren-zeilen",
    "href": "C_Programmieren_2/6_Functions_II.html#funktionen-auf-mehreren-zeilen",
    "title": "Function Advanced",
    "section": "Funktionen auf mehreren Zeilen",
    "text": "Funktionen auf mehreren Zeilen\nBisher waren unsere Funktionen sehr kurz und einfach und wir benötigten dafür immer nur zwei Zeilen: Die erste Zeile begann die Function-Definition (def..) und die zweite Zeile retournierte bereits die Lösung return(...).\nZwischen diesen beiden Komponenten haben wir aber viel Platz, den wir uns zu Nutze machen können. Wir können hier Kommentare hinzufügen wie auch unsere Funktion in Einzelschritte aufteilen um den Code lesbarer zu machen.\n\ndef gruezi2(nachname, anrede):\n    \"\"\" \n    Meine coole Grüezi funktion\n    Diese Funktion soll Menschen freundlich grüssen. \n    Sie nimmt zwei Inputs: nachname und andrede, beides \"strings\"\n    \"\"\"\n    gruss = \"Guten Tag, \" + anrede + \" \"+nachname\n    return gruss\n\nAllgemeine Kommentare werden in Python mit # hinzugefügt, Funktionen werden aber mit drei Anführungs- und Schlusszeichen kommentiert. Diese Kommentare erscheinen eleganterweise wenn man die Hilfe zu dieser Funktion mit help() aufruft:\n\nhelp(gruezi2)\n\nHelp on function gruezi2 in module __main__:\n\ngruezi2(nachname, anrede)\n    Meine coole Grüezi funktion\n    Diese Funktion soll Menschen freundlich grüssen.\n    Sie nimmt zwei Inputs: nachname und andrede, beides \"strings\"",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>*Function* Advanced</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/6_Functions_II.html#globale-und-lokale-variabeln",
    "href": "C_Programmieren_2/6_Functions_II.html#globale-und-lokale-variabeln",
    "title": "Function Advanced",
    "section": "Globale und Lokale Variabeln",
    "text": "Globale und Lokale Variabeln\nInnerhalb einer Function können nur die Variabeln verwendet werden, die der Function als Argumente übergeben (oder innerhalb der Funktion erstellt) werden. Diese nennt man “lokale” Variabeln und sind nur lokal in der Function vorhanden. Im Gegensatz dazu stehen “globale” Variabeln, welche Teil der aktuellen Session sind.\nVersuchen wir das mit einem Beispiel zu verdeutlichen. Angenommen wir definieren gobal die Variabel vorname:\n\n# Wir definieren globale Variabel\nvorname = \"Guido\"\n\n# Nun erstellen wir eine Function, welche diese Variabel (\"vorname\") nutzen soll:\ndef sag_hallo(vorname):\n    return \"Hallo \" + vorname\n\n# Wenn wir jetzt aber die Function ausführen wollen, entsteht die Fehlermeldung,\n# dass \"vorname\" fehlt (obwohl wir vorname ja schon definiert haben)\nsag_hallo()\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[9], line 10\n      6     return \"Hallo \" + vorname\n      8 # Wenn wir jetzt aber die Function ausführen wollen, entsteht die Fehlermeldung,\n      9 # dass \"vorname\" fehlt (obwohl wir vorname ja schon definiert haben)\n---&gt; 10 sag_hallo()\n\nTypeError: sag_hallo() missing 1 required positional argument: 'vorname'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>*Function* Advanced</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/6_Functions_II.html#sec-functions-lambda",
    "href": "C_Programmieren_2/6_Functions_II.html#sec-functions-lambda",
    "title": "Function Advanced",
    "section": "Lambda-Function",
    "text": "Lambda-Function\nMit dem Begriff lambda kann eine Function verkürzt geschrieben werden. Wir werden dies im Unterricht kaum verwenden, es ist aber doch gut davon gehört zu haben. Nachstehend wird die Funktion sag_hallo() in der bekannten, wie auch in der verkürzten Form definiert.\n\n\nHerkömmliche Weise:\ndef sag_hallo(vorname):\n    return \"Hi \"+vorname\n\n\n\nVerkürzt mit lambda:\nsag_hallo = lambda vorname: \"Hi \"+vorname",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>*Function* Advanced</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/7_Uebung_7.html",
    "href": "C_Programmieren_2/7_Uebung_7.html",
    "title": "Übung 7",
    "section": "",
    "text": "Übung 7.1\nErstelle eine Funktion namens times, die zwei Zahlen miteinander multipliziert.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Übung 7</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/7_Uebung_7.html#übung-7.2",
    "href": "C_Programmieren_2/7_Uebung_7.html#übung-7.2",
    "title": "Übung 7",
    "section": "Übung 7.2",
    "text": "Übung 7.2\nDie eben erstellte Funktion times benötigt 2 Argumente (die miteinander multipliziert werden). Wandle den zweiten Parameter in einen optionalen Parameter um (mit dem Defaultwert 1).\nZusatzaufgabe: Was passiert, wenn du den ersten Parameter in einen optionalen Parameter umwandelst?",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Übung 7</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/7_Uebung_7.html#sec-ex-functions-bmi",
    "href": "C_Programmieren_2/7_Uebung_7.html#sec-ex-functions-bmi",
    "title": "Übung 7",
    "section": "Übung 7.3",
    "text": "Übung 7.3\nErstelle eine Funktion namens bmi, die aus Grösse und Gewicht einen BodyMassIndex berechnet (\\(BMI=\\frac{m}{l^2}\\), \\(m\\): Körpermasse in Kilogramm, \\(l\\): Körpergrösse in Meter). Das Resultat soll etwa folgendermassen aussehen:\n\nbmi(groesse_m = 1.8, gewicht_kg = 88)\n\n27.160493827160494",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Übung 7</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/7_Uebung_7.html#übung-7.4",
    "href": "C_Programmieren_2/7_Uebung_7.html#übung-7.4",
    "title": "Übung 7",
    "section": "Übung 7.4",
    "text": "Übung 7.4\nErstelle eine Funktion mittelwert(), welche den Mittelwert aus einer Liste (List) von Zahlen berechnet. Nutze dazu sum() und len() analog Uebung 2.6. Das Resultat sollte folgendermassen aussehen:\n\nmeine_zahlen = [50, 100, 550, 1000]\nmittelwert(meine_zahlen)\n\n425.0",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Übung 7</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/7_Uebung_7.html#übung-7.5",
    "href": "C_Programmieren_2/7_Uebung_7.html#übung-7.5",
    "title": "Übung 7",
    "section": "Übung 7.5",
    "text": "Übung 7.5\nErstelle eine Funktion celsius_zu_farenheit, welche eine beliebige Zahl von Grad Celsius in Grad Farenheit konvertiert. Zur Erinnerung: Temperatur in °F = Temperatur in °C x 1,8 + 32.\nDas Resultat sollte folgendermassen aussehen:\n\ncelsius_zu_farenheit(celsius = 25)\n\n77.0",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Übung 7</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/7_Uebung_7.html#übung-7.6",
    "href": "C_Programmieren_2/7_Uebung_7.html#übung-7.6",
    "title": "Übung 7",
    "section": "Übung 7.6",
    "text": "Übung 7.6\nSchreibe die letzte Funktion celsius_zu_farenheit in der lambda Notation.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Übung 7</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/8_If_else.html",
    "href": "C_Programmieren_2/8_If_else.html",
    "title": "If / Else",
    "section": "",
    "text": "Ein wichtiger Bestandteil von Programmieren sind Fallunterscheidungen. Mit Fallunterscheidungen können wir mit unterschiedlichen Situationen verschieden umgehen.\nDie einfache Fallunterscheidung ist die bedingte Verzweigung. Die Syntax der einfachen if-Anweisung lautet folgendermassen:\nif Bedingung:\n    # Anweisungen 1\nelse:\n    # Anweisungen 2\nZum Beispiel:\n\n# hier alter eingeben:\nalter = 35\n\nif alter &lt; 40:\n    print(\"Backstreet Boys: 'I want it that way'\")\nelse:\n    print(\"The Jackson 5: 'I want you back'\")\n\nBackstreet Boys: 'I want it that way'\n\n\nWenn wir mehr als zwei verschiedene Fälle haben, können diese mit elif dazwischen geschaltet werden.\nif Bedingung1:\n    # Anweisungen 1\nelif Bedingung2:\n    # Anweisungen 2\nelif Bedingung3:\n    # Anweisungen 3\nelse:\n    # Anweisungen 4\nZum Beispiel:\n\n# hier alter eingeben:\nalter = 35\n\nif alter &lt; 20:\n    print(\"Kesha: 'Tik Tok'\")\nelif alter &lt; 30:\n    print(\"Destiny's Child: 'Say My Name'\")\nelif alter &lt; 40:\n    print(\"Mariah Carey: 'Vision of love'\")\nelse:\n    print(\"Blondie: 'Call me'\")\n\nMariah Carey: 'Vision of love'\n\n\nSolche Fallunterscheidungen sind vor allem in Funktionen sehr praktisch. Aus dem obigen Beispiel können wir beispielsweise eine Funktion erstellen, die uns ein Lied in Abhängigkeit zu unserem Alter vorschlägt:\n\ndef suggest_song(alter):\n    if alter &lt; 20:\n        song = \"Kesha: 'Tik Tok'\"\n    elif alter &lt; 30:\n        song = \"Destiny's Child: 'Say My Name'\"\n    elif alter &lt; 40:\n        song = \"Mariah Carey: 'Vision of love'\"\n    else:\n        song = \"Blondie: 'Call me'\"\n    return \"I suggest the song \" + song + \". Enjoy!\"\n\nsuggest_song(24)\n\n\"I suggest the song Destiny's Child: 'Say My Name'. Enjoy!\"\n\n\nDabei ist wichtig, dass man sich jeweils die Ausführungslogik vor Augen führt.\n\ngraph LR\n    A[alter &lt; 20] \n    A--&gt;|yes| B[Kesha: 'Tik Tok']\n    A--&gt;|no| C[Alter &lt; 30]\n    C--&gt;|yes| D[Destiny's Child: 'Say My Name']\n    C--&gt;|no| E[alter &lt; 40]\n    E--&gt;|yes| F[Mariah Carey: 'Vision of love']\n    E--&gt;|no| G[Blondie: 'Call me']\n\n\n\n\ngraph LR\n    A[alter &lt; 20] \n    A--&gt;|yes| B[Kesha: 'Tik Tok']\n    A--&gt;|no| C[Alter &lt; 30]\n    C--&gt;|yes| D[Destiny's Child: 'Say My Name']\n    C--&gt;|no| E[alter &lt; 40]\n    E--&gt;|yes| F[Mariah Carey: 'Vision of love']\n    E--&gt;|no| G[Blondie: 'Call me']",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>If / Else</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/9_Uebung_8.html",
    "href": "C_Programmieren_2/9_Uebung_8.html",
    "title": "Übung 8",
    "section": "",
    "text": "Übung 8.1\nErstelle eine neue Funktion gruezi3 die gruezi (aus Übung 6.1) um einem weiteren Parameter uhrzeit erweitert. Die Funktion soll vor 18 Uhr (uhrzeit &lt; 18) mit “Guten Tag” und sonst mit “Guten Abend” grüssen. Um es einfach zu halten: Die Zeitangbe muss in Dezimalzahlen erfolgen (also nicht 20:15 Uhr sondern 20.25).\n# die Lösung sollte etwa folgendermasssen funktionieren:\n\ngruezi3(\"Guido\", uhrzeit = 21)\n\n'Guten Abend Guido'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Übung 8</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/9_Uebung_8.html#übung-8.2",
    "href": "C_Programmieren_2/9_Uebung_8.html#übung-8.2",
    "title": "Übung 8",
    "section": "Übung 8.2",
    "text": "Übung 8.2\nErweitere die Funktion gruezi2 so, dass zwischen folgende Uhrzeiten berücksichtigt werden:\n\n\n\nTabelle 32.1: Uhrzeiten und ihre Begrüssungsformen\n\n\n\n\n\nUhrzeit\nBegrüssungsform\n\n\n\n\n\n5 bis 11 Uhr\nGuten Morgen\n\n\n\n11 bis 18 Uhr\nGuten Tag\n\n\n\n18 bis 22 Uhr\nGuten Abend\n\n\n\n22 bis 5 Uhr\nGute Nacht\n\n\n\n\n\n\n\nDas Problem ist etwas schwierig zu Packen weil wir die “von - bis” Uhrzeiten in eine Ja/Nein Logik überführen müssen. Überlege dir zuerst eine Ausführungslogik und schreibe danach die if, elifund else Operationen. Hier unser Vorschlag:\n\n\n\n\n\ngraph LR\n    A[uhrzeit &lt; 5] \n    A--&gt;|yes| B[Gute Nacht]\n    A--&gt;|no| C[Uhrzeit &lt; 11]\n    C--&gt;|yes| D[Guten Morgen]\n    C--&gt;|no| E[Uhrzeit &lt; 18]\n    E--&gt;|yes| F[Guten Tag]\n    E--&gt;|no| G[Uhrzeit &lt; 22]\n    G--&gt;|yes| H[Guten Abend]\n    G--&gt;|no| I[Gute Nacht]\n\n\n\n\n\n\nTeste die Funktion mit verschiedenen Optionen um sicherzustellen, dass sie richtig funktioniert.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Übung 8</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/9_Uebung_8.html#übung-8.3",
    "href": "C_Programmieren_2/9_Uebung_8.html#übung-8.3",
    "title": "Übung 8",
    "section": "Übung 8.3",
    "text": "Übung 8.3\nErweitere die Funktion bmi aus Übung 7.3 so, dass statt dem berechneten BMI der “Nutritional status” aufgrund der WHO Klassifizierung ausgegeben wird:\n\n\n\nTabelle 32.2: WHO Nutritional status\n\n\n\n\n\nBMI\nNutritional status\n\n\n\n\nBelow 18.5\nUnderweight\n\n\n18.5–24.9\nNormal weight\n\n\n25.0–29.9\nPre-obesity\n\n\n30.0–34.9\nObesity class I\n\n\n35.0–39.9\nObesity class II\n\n\nAbove 40\nObesity class III\n\n\n\n\n\n\n\n# Der Output sollte etwa folgedermassen aussehen\nbmi2(1.7, 70)\n\n'Who classification: Normal weight'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Übung 8</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/10_Zufallzahlen.html",
    "href": "C_Programmieren_2/10_Zufallzahlen.html",
    "title": "Zufallszahlen generieren",
    "section": "",
    "text": "Im Block “Datenqualität und Unsicherheit” habt ihr euch bereits mit Zufallszahlen und Simulationen auseinandergesetzt. Programmiersprachen sind für eine solche Anwendung sehr gut geeignet, und deshalb werden wir in diesem Abschnitt eine Erweiterung zur Erstellung von Zufallszahlen kennenlernen. Diese Erweiterung lautet random und ist Teil der “Python Standard Library”, was bedeutet das dieses Erweiterung bereits installiert ist, und wir sie nicht installieren müssen.\n\nimport random\n\n\nrandom.seed(2)\n\nInnerhalb vom random gibt es zahlreiche Funktionen um Zufallszahlen zu generieren, je nachdem was unsere Anforderungen an die Zufallszahl ist. Eine Anforderung könnte zum Beispiel sein, dass die Zahl innerhalb eines bestimmten Bereichs luegen soll (z.B. “generiere eine Zufallszahl zwischen 1 und 9”). Oder aber, dass sie eine ganze Zahl sein muss. Weiter könnte die Anforderung sein, dass sie aus einer bestimmten Verteilung kommen sollte, zum Beispiel einer Normalverteilung. In diesem letzten Fall müssen wir den Mittlwert sowie die Standartabweichung unserer Verteilung angeben.\nUm eine ganzzahlige Zufallszahl zwischen 1 und 9 zu generieren, können wir die Funktion randrange() nutzen:\n\nrandom.randrange(start = 1, stop = 10)\n\n1\n\n\nWenn wir auf diese Weise mit randrange() immer wieder neue Zufallszahlen generieren fällt auf, dass die Verteilung der Zahlen ziemlich gleichmässig ist. Es ist also gleich wahrscheinlich eine 9 zu bekommen, wie eine 1 oder eine 5. Die Zahlen kommen also aus einer “uniformen” Verteilung. Um dies zu verdeutlichen generiere ich in den folgenden Codezeilen 500 Zufallszahlen zwischen 1 und 9 mit der Funktion randrange und visualisiere die Häufigkeit der einzelnen Zahlen in einem Histogramm.\n\n# erstellt eine Liste von Zufallszahlen 1 - 9\n# (lernen wir zu einem späteren Zeitpunkt)\na = [random.randrange(1, 10) for x in range(500)]\n\nimport pandas as pd\n\n# visualisiert die zufällig generierten Zahl in Form \n# eines Histogramms (lernen wir ebenfalls später)\npd.Series(a).plot(kind = \"hist\", bins = range(1, 11), edgecolor = \"black\", align = \"left\", xticks = range(1, 10))\n\n\n\n\n\n\n\n\nDie Funktion randrange() generiert nur ganzzahlige Zufallszahlen. Wenn wir aber eine Zufallszahl mit Nachkommastellen brauchen, verwenden wir die Funktion uniform().\nUm Zufallszahlen aus einer “Normalverteilung” zu erhalten, verwenden wir die Funktion normalvariate. Hier müssen wir den Mittelwert und die Standartabweichung dieser Verteilung angeben. Tatsächlich können wir bei dieser Variante keine Minimum- und Maximumwerte festlegen: Theoretisch könnte der Generator jeden erdenklichen Zahlenwert rausspucken, am wahrscheinlichsten ist jedoch eine Zahl nahe am angegebenen Mittelwert.\n\n# mu = Mittelwert, sigma = Standartabweichung\nrandom.normalvariate(mu = 5, sigma = 2)\n\n2.5056884809480864\n\n\nWenn wir die obige Funktion 10’000x laufen lassen und uns das Histogramm der generierten Zahlen anschauen, dann zeichnet sich folgendes Bild ab.\n\nb = [random.normalvariate(mu = 5, sigma = 2) for b in range(10000)]\npd.Series(b).plot(kind = \"hist\", bins = 30, edgecolor = \"black\")",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Zufallszahlen generieren</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/11_Uebung_9.html",
    "href": "C_Programmieren_2/11_Uebung_9.html",
    "title": "Übung 9",
    "section": "",
    "text": "Übung 9.1\nNun wollen wir diesen Zufallszahlengenerator random nutzen um eine Funktion zu entwickeln, welche einen beliebigen Punkt (mit einer x-/y-Koordinate) zufällig in einem definierten Umkreis verschiebt. Unser Fernziel ist es, den simulierten Datensatz aus “Datenqualität und Unsicherheit” zu rekonstruieren (siehe unten). Der erste Schritt dorthin ist es, einen gemeldeten Punkt (rot in Abbildung 34.1) in einem definierten Umkreis zu verschieben.\nDas Ziel dieser Übung ist es also, dass wir eine Funktion entwickeln, die uns einen zufälligen Punkt in der Nähe eines Ursprungspunktes vorschlägt. Unser Vorgehen: Wir addieren jedem Koordinatenwert (x/y) des Ursprungspunktes einen Zufallswert, zum Beispiel zwischen -100 bis +100.\nBevor wir mit Koordinaten arbeiten wollt ihr euch zuerst mit dem Modul random vertraut machen. Importiere das Modul random und generiere eine Zufallszahl zwischen -100 und +100 aus einer uniformen Verteilung sowie aus einer Normalverteilung mit Mittelwert 100 und Standartabweichung 20.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Übung 9</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/11_Uebung_9.html#übung-9.2",
    "href": "C_Programmieren_2/11_Uebung_9.html#übung-9.2",
    "title": "Übung 9",
    "section": "Übung 9.2",
    "text": "Übung 9.2\nNun wollen wir uns den Koordinaten zuwenden. Erstelle als erstes zwei Dummykoordinaten x_start und y_start mit jeweils dem Wert 0. Diese sollen als “Ursprungskoordinaten” dienen.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Übung 9</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/11_Uebung_9.html#übung-9.3",
    "href": "C_Programmieren_2/11_Uebung_9.html#übung-9.3",
    "title": "Übung 9",
    "section": "Übung 9.3",
    "text": "Übung 9.3\nGeneriere nun eine Zufallszahl, die aus einer Normalverteilung stammt und die in etwa zwischen -100 und +100 liegt. Weise diese Zahl der Variabel x_offset zu. Generiere danach eine zweite Zufallszahl (auf die gleiche Art) und weise diese y_offset zu.\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nÜberlege dir, welcher Mittelwert Sinn macht um Werte zwischen -100 und +100 zu bekommen. Welche Zahl liegt zwischen -100 und +100?\nÜberlege dir als nächstes, welche Standartabweichung sinnvoll wäre. Zur Erinnerung: Etwa 68% der Werte liegen inerhalb von +/- 1 Standartabweichung (SD), 95% innerhalb von +/- 2 SD, 99% innerhalb von 3 SD (siehe unten):\n\n\n\n\n\n\nAbbildung 34.2: Normalverteilung und die Anteile innerhalb von 1 Standartabweichung (Mittelwert \\(\\mu\\) minus Standartabweichung \\(\\sigma\\)), 2 Standartabweichungen (\\(\\mu - 2\\times\\sigma)\\) und 2 Standartabweichungen (\\(\\mu - 3\\times\\sigma)\\). Quelle: cobocards",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Übung 9</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/11_Uebung_9.html#übung-9.4",
    "href": "C_Programmieren_2/11_Uebung_9.html#übung-9.4",
    "title": "Übung 9",
    "section": "Übung 9.4",
    "text": "Übung 9.4\nAddiere nun die Zufallszahlen x_offset und y_offset jeweils zu den Dummykoordinaten x_start und y_start und weise diese neuen Koordinaten x_neu und y_neu zu. Die neuen Werte stellen die leicht verschobenen Ursprungskoordinaten dar. In meinem Fall sind diese um 10.2 Meter nach Osten (positiver Wert) bzw. 4.4 Meter nach Süden (negativer Wert) verschoben worden.\n\nx_neu\n\n10.246170309600945\n\n\n\ny_neu\n\n-4.443904000288846\n\n\n\n\nCode für die Visualisierung (nur FYI)\nimport pandas as pd\n\nmypoints = pd.DataFrame({\n    \"x\": [x_start, x_neu],\n    \"y\": [y_start, y_neu],\n    \"typ\": [\"start\", \"neu\"]\n    }\n)\n\nfrom matplotlib import pyplot as plt\n\nmypoints.plot(\"x\", \"y\", kind = \"scatter\", xlim = [-100, 100], ylim = [-100, 100], c = [\"red\", \"blue\"], title = \"Ursprung (rot) und Simulation (blau)\")",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Übung 9</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/11_Uebung_9.html#sec-ex-offset-function",
    "href": "C_Programmieren_2/11_Uebung_9.html#sec-ex-offset-function",
    "title": "Übung 9",
    "section": "Übung 9.5",
    "text": "Übung 9.5\nNun haben wir das zufällige Verschieben eines Einzelpunktes am Beispiel einer Dummykoordinaten (0/0) durchgespielt. In der nächsten Aufgabe (Funktionen in DataFrames) werden wir alle unsere Zeckenstichkoordinaten auf diese Weise zufällig verschieben um einen simulierten Zeckenstichdatensatz ähnlich wie Abbildung 34.1 zu erhalten.\nDafür brauchen wir die eben erarbeiteten Einzelschritte als Funktion, um diese auf alle Zeckenstiche anwenden zu können.\nErstelle jetzt eine Funktion namens offset_coordinate welche als Input eine x oder y-Achsenwert annimmt und eine leicht verschobene Wert zurückgibt.** Integriere die Standartabweichung der Verteilung als optionalen Parameter mit dem Namen distance und einem Defaultwert von 100.\n\n# die Funktion sollte so funktionieren:\noffset_coordinate(x_start)\n\n-99.87034152252974",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Übung 9</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/11_Uebung_9.html#sec-offset-vis",
    "href": "C_Programmieren_2/11_Uebung_9.html#sec-offset-vis",
    "title": "Übung 9",
    "section": "Übung 9.6",
    "text": "Übung 9.6\nNun ist es wichtig, dass wir unser Resultat visuell überprüfen. Im Beispiel unten wende ich die in der letzten Übung erstellte Funktion offset_coordinate() 1’000 mal auf die Dummykoordinate an. Nutze deine Funktion offset_coordinate um eine Visualisierung gemäss untenstehendem beispiel zu machen.\n\nx_neu_list = [offset_coordinate(x_start) for i in range(1, 1000)]\ny_neu_list = [offset_coordinate(y_start) for i in range(1, 1000)]\n\n# Liste in eine Pandas DataFrame überführen\nmysim = pd.DataFrame({\"x\" : x_neu_list, \"y\" : y_neu_list})\n\nmysim.plot(\"x\", \"y\", kind = \"scatter\")\n\nfrom matplotlib import pyplot as plt\nplt.axis(\"equal\")\n\n(np.float64(-276.4138173551481),\n np.float64(328.23128802707674),\n np.float64(-345.23987160827943),\n np.float64(380.6391610005407))",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Übung 9</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/12_Funktionen_in_DataFrames.html",
    "href": "C_Programmieren_2/12_Funktionen_in_DataFrames.html",
    "title": "Funktionen in DataFrames",
    "section": "",
    "text": "In dieser Aufgabe haben wir das Ziel, die in der letzten Aufgabe (Zufallszahlen generieren) erstellte Funktion offset_coordinate() auf alle Zeckenstich-Koordinaten anzuwenden. Bildlich gesprochen: Wir nehmen unsere Zeckenstichdatensatz und schütteln ihn einmal durch. So erhalten wir einen Datensatz ähnlich wie in Abbildung 34.1 mit dem Unterschied, dass jede Zeckenstichmeldung nicht eine Wolke von simulierten Punkten enthält, sondern nur einen einzelnen Punkt.\nNutze hier die Datei zeckenstiche.csv von letzter Woche (siehe Tabelle 1). Erstelle ein neues Python-File und nutze nachstehenden Code, um die nötigen Module und Functions zu haben:\n\nimport pandas as pd\n\ndef offset_coordinate(old, distance = 100):\n    import random\n    new = old + random.normalvariate(0,distance)\n\n    return new\n\nzeckenstiche = pd.read_csv(\"data/zeckenstiche.csv\")\n#           ______________________↗____________________\n#         &lt; verwendet hier euren eigenen relativen pfad &gt;\n#           -------------------------------------------\n     \n\nzeckenstiche\n\n\n\n\n\n\n\n\nID\naccuracy\nx\ny\n\n\n\n\n0\n2550\n439.128951\n2681116\n1250648\n\n\n1\n10437\n301.748542\n2681092\n1250672\n\n\n2\n9174\n301.748542\n2681128\n1250683\n\n\n3\n8773\n301.748542\n2681111\n1250683\n\n\n4\n2764\n301.748529\n2681131\n1250692\n\n\n5\n2513\n301.748529\n2681171\n1250711\n\n\n6\n9185\n301.748542\n2681107\n1250712\n\n\n7\n28521\n301.748542\n2681124\n1250720\n\n\n8\n26745\n301.748542\n2681117\n1250725\n\n\n9\n27391\n301.748542\n2681138\n1250725",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Funktionen in *DataFrames*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/13_Uebung_10.html",
    "href": "C_Programmieren_2/13_Uebung_10.html",
    "title": "Übung 10",
    "section": "",
    "text": "Übung 10.1\nFür diese Übung brauchen wir\nMache dich nochmals damit vertraut, einzelne Spalten zu selektieren. Schau dir DataFrames nochmals an wenn du nicht mehr weisst wie das geht.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Übung 10</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/13_Uebung_10.html#übung-10.2",
    "href": "C_Programmieren_2/13_Uebung_10.html#übung-10.2",
    "title": "Übung 10",
    "section": "Übung 10.2",
    "text": "Übung 10.2\nMache dich nochmals damit vertraut, wie man neue Spalten erstellt. Schau dir DataFrames nochmals an wenn du nicht mehr weisst wie das geht. Erstelle ein paar neue Spalten nach dem Beispiel unten um die Hangriffe zu üben. Lösche die Spalten im Anschluss wieder mit del zeckenstiche['test1'] etc.\n\n\nMusterlösung\nzeckenstiche[\"test1\"] = \"test1\"\n\nzeckenstiche[\"test2\"] = 10\n\nzeckenstiche[\"test3\"] = range(10)\n\n\n\n# zeckenstiche könnte danach folgendermassen aussehen:\nzeckenstiche\n\n\n\n\n\n\n\n\nID\naccuracy\nx\ny\ntest1\ntest2\ntest3\n\n\n\n\n0\n2550\n439.128951\n2681116\n1250648\ntest1\n10\n0\n\n\n1\n10437\n301.748542\n2681092\n1250672\ntest1\n10\n1\n\n\n2\n9174\n301.748542\n2681128\n1250683\ntest1\n10\n2\n\n\n3\n8773\n301.748542\n2681111\n1250683\ntest1\n10\n3\n\n\n4\n2764\n301.748529\n2681131\n1250692\ntest1\n10\n4\n\n\n5\n2513\n301.748529\n2681171\n1250711\ntest1\n10\n5\n\n\n6\n9185\n301.748542\n2681107\n1250712\ntest1\n10\n6\n\n\n7\n28521\n301.748542\n2681124\n1250720\ntest1\n10\n7\n\n\n8\n26745\n301.748542\n2681117\n1250725\ntest1\n10\n8\n\n\n9\n27391\n301.748542\n2681138\n1250725\ntest1\n10\n9\n\n\n\n\n\n\n\n\n# unnötigen Spalten wieder entfernen:\ndel zeckenstiche['test1']\ndel zeckenstiche['test2']\ndel zeckenstiche['test3']",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Übung 10</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/13_Uebung_10.html#sec-ex-apply",
    "href": "C_Programmieren_2/13_Uebung_10.html#sec-ex-apply",
    "title": "Übung 10",
    "section": "Übung 10.3",
    "text": "Übung 10.3\npandas kennt eine ganze Familie von Methoden, um Spalten zu Manipulieren und Daten zu Aggregieren (apply, map, mapapply, assign). Es würde den Rahmen dieses Kurses sprengen, die alle im Detail durchzugehen, es lohnt sich aber sehr sich mit diesen auseinanderzusetzen wenn man sich näher mit Python befassen möchte.\nIm unserem Fall brauchen wir lediglich die Methode apply um die Funktion offset_coordinate() auf die Zeckenstichkoordinaten anzuwenden. Dabei gehen wir wie folgt for:\n\nzeckenstiche[\"x\"].apply(offset_coordinate)\n#\\______1_______/ \\_2_/\\_______3_________/\n\n# 1. Spalte selektieren ([\"x\"])\n# 2. Methode \"apply\" aufrufen\n# 3. Function übergeben\n\nVerwende dieses Schema um auch offset_coordinate auf die y Spalte anzuwenden und speichere den Output dieser beiden Operationen als neue Spalten x_sim sowie y_sim. Die DataFrame zeckenstiche sollte danach wie folgt aussehen:\n\n\nMusterlösung\nzeckenstiche[\"x_sim\"] = zeckenstiche[\"x\"].apply(offset_coordinate)\nzeckenstiche[\"y_sim\"] = zeckenstiche[\"y\"].apply(offset_coordinate)\n\n\n\nzeckenstiche\n\n\n\n\n\n\n\n\nID\naccuracy\nx\ny\nx_sim\ny_sim\n\n\n\n\n0\n2550\n439.128951\n2681116\n1250648\n2.681232e+06\n1.250747e+06\n\n\n1\n10437\n301.748542\n2681092\n1250672\n2.680961e+06\n1.250613e+06\n\n\n2\n9174\n301.748542\n2681128\n1250683\n2.681053e+06\n1.250678e+06\n\n\n3\n8773\n301.748542\n2681111\n1250683\n2.681087e+06\n1.250616e+06\n\n\n4\n2764\n301.748529\n2681131\n1250692\n2.681091e+06\n1.250899e+06\n\n\n5\n2513\n301.748529\n2681171\n1250711\n2.681210e+06\n1.250682e+06\n\n\n6\n9185\n301.748542\n2681107\n1250712\n2.681163e+06\n1.250478e+06\n\n\n7\n28521\n301.748542\n2681124\n1250720\n2.681236e+06\n1.250811e+06\n\n\n8\n26745\n301.748542\n2681117\n1250725\n2.681157e+06\n1.250571e+06\n\n\n9\n27391\n301.748542\n2681138\n1250725\n2.681169e+06\n1.250636e+06",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Übung 10</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/13_Uebung_10.html#sec-ex-param",
    "href": "C_Programmieren_2/13_Uebung_10.html#sec-ex-param",
    "title": "Übung 10",
    "section": "Übung 10.4",
    "text": "Übung 10.4\nIn Übung 10.3 haben wir unsere Funktion offset_coordinate aufgerufen, ohne den Parameter distance zu spezifizieren. Dies war möglich, weil wir für distance einen Defaultwert festgelegt hatten (100 Meter). Wir können aber auch zusätzliche Parameter kommagetrennt nach der Funktion angeben. Dies sieht folgendermassen aus:\n\nzeckenstiche[\"x\"].apply(offset_coordinate, distance = 200)\n\nNutze diese Möglichkeit, um den Offset (distance) auf maximal 10 Meter zu reduzieren.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Übung 10</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/13_Uebung_10.html#übung-10.5",
    "href": "C_Programmieren_2/13_Uebung_10.html#übung-10.5",
    "title": "Übung 10",
    "section": "Übung 10.5",
    "text": "Übung 10.5\nUm die Original x/y-Werte sowie die simulierten Daten im gleichen Plot darzustellen, wird folgendermassen vorgegangen: Der erste Datensatz wird mit .plot() visualisiert, wobei der Output einer Variabel (z.B. basemap) zugewiesen wird. Danach wird der zweite Datensatz ebenfalls mit .plot() visualisiert, wobei auf den ersten Plot via dem Argument ax verwiesen wird.\nBei den roten Punkten handelt es sich um die Original-Zeckenstichen, bei den blauen um die simulierten (leicht verschoben) Zeckenstiche. Visualisiere deine eigenen Zeckenstiche auf diese Weise.\n\nfrom matplotlib import pyplot as plt\n\nbasemap = zeckenstiche.plot(\"x\", \"y\", kind = \"scatter\", color = \"red\")\nzeckenstiche.plot(\"x_sim\", \"y_sim\", kind = \"scatter\", ax = basemap, color = \"blue\")\n\nplt.axis(\"equal\")\n\n(np.float64(2681088.05),\n np.float64(2681174.95),\n np.float64(1250638.1171760987),\n np.float64(1250740.1834372114))",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Übung 10</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/20_Anhang.html",
    "href": "C_Programmieren_2/20_Anhang.html",
    "title": "Anhang",
    "section": "",
    "text": "Anhang I: Conda cheat sheet\nIn der folgenden Tabelle werden die Einzelschritte in der Verwendung von Conda nochmal zusammengefasst. Wichtig ist vor allem, wann dieser Schritt nötig ist und wie er ausgeführt wird. Um die Tabelle kompakt zu halten werden gewisse Details als Fussnote verlinkt.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/20_Anhang.html#sec-conda",
    "href": "C_Programmieren_2/20_Anhang.html#sec-conda",
    "title": "Anhang",
    "section": "",
    "text": "Schritt\nWann ist dies nötig?\nDetails zum Vorgehen / Befehl für die Konsole1\n\n\n\n\n1. Conda installieren (installiert das Program conda)\neinmalig (ist nicht nötig, wenn ArcGIS Pro installiert ist)\nMiniconda (empfohlen) oder anaconda herunterladen und installieren\n\n\n2. Virtual environment erstellen (erstellt eine neue Arbeitsumgebung)\neinmal pro Projekt nötig (wobei eine environment auch wiederverwendet werden kann)\nin der Konsole: conda create --name geopython\n\n\n3. Virutal environment aktivieren (schaltet den “Bearbeitungsmodus” ein)\njedes mal nöig wenn ein *Erweiterung installiert** werden soll\nin der Konsole 2: activate geopython\n\n\n4. weitere Module 3 installieren (fügt der environment zB pandas hinzu)\njedes mal nötig, wenn ein Modul in einer Environment fehlt4\nin der Konsole 5,[^jupyterlabbeenden]: conda install -c conda-forge pandas",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/20_Anhang.html#anhang-2-probleme-mit-conda-umlaute-im-bentzernamen",
    "href": "C_Programmieren_2/20_Anhang.html#anhang-2-probleme-mit-conda-umlaute-im-bentzernamen",
    "title": "Anhang",
    "section": "Anhang 2: Probleme mit Conda: Umlaute im Bentzernamen",
    "text": "Anhang 2: Probleme mit Conda: Umlaute im Bentzernamen\nAlle conda environments werden an einem zentralen Ort gespeichert. Typischerweise im folgenden Verzeichnis: C:\\Users\\DEIN-WINDOWS-BENUTZERNAME\\AppData\\Local\\ESRI\\conda\\envs\\. Wenn ihr Umlaute in eurem Windows Benutzernamen habt, findet conda eure environment möglicherweise nicht. Eine Möglichkeit, dieses Problem zu beheben, ist einen alternativen Speicherort für eure conda environments zu definieren. Dazu geht ihr wie folgt vor6:\n\nÜberlege dir eine Location, wo du deine conda nvironments abspeichern möchtest (z.B. C:\\conda-envs). Erstelle diesen Ordnerpfad und prüfe ob du dort Schreibrechte hast indem du in diesem Orner C:\\conda-envs eine Dateie erstellst. Wenn das klappt, hast du Schreibrechte.\nFüge diesen Pfad deiner conda configuration hinzu:\nconda config --append envs_dirs C:\\conda-envs\nPrüfe ob der letzte Schritt funktioniert hat indem du folgendem Befehl laufen lässt und prüfst, ob C:\\conda-envs vorkommt:\nconda config --show envs_dirs\nErstelle eine neue conda environment in dieser neu erstellten directory:\nconda create --prefix=C:\\conda-envs\\geopython\nPrüfe, ob das geklappt hat, indem du die verfügbaren environments auflistest.\nconda info --envs\nWenn das geklappt hat, kannst du nun deine environment aktivieren\nconda activate geopython",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/20_Anhang.html#anhang-3-conda-und-arcpy",
    "href": "C_Programmieren_2/20_Anhang.html#anhang-3-conda-und-arcpy",
    "title": "Anhang",
    "section": "Anhang 3: Conda und arcpy",
    "text": "Anhang 3: Conda und arcpy\nUm die ganzen Befehle von ArcGIS direkt in Python ansteuern zu können, muss das package arcpy installiert werden. Bisher haben wir alle unsere Packages mit conda installiert, z.B:\nconda install -c conda-forge geopandas\nMit arcpy geht dies leider nicht, weil arcpy ein kostenpflichtiges Modul ist welches eine ArcGIS Lizenz benötigt. Glücklicherweise nutzt ArcGIS aber auch Conda Environments. Wir müssen also nur bewerkstelligen, das Juypter Lab die gleiche Conda environment verwendet wie ArcGIS. Dazu gehen wir wie folgt vor:\n\nSchritt 1: ArcGIS Python Umgebung Klonen\nSchritt 2: Die neue Environment aktivieren\nSchritt 3: weitere Module installieren\n\n\nSchritt 1: ArcGIS Python Umgebung Klonen\nZuerst prüfen wir die Python Umgebung in ArcGIS. Diese findet man in ArcGIS unter Project &gt; Python\n\nHier ist einerseits die Project Environement ersichtlich (1), andererseits steht aber auch, dass diese Environment “read only” ist (2). Das bedeutet, dass wir keine neuen module installieren können, wenn wir diese Environment benutzen. Wir folgen deshalb den Vorschlag “Clone and activate a new environment”. Dazu klicken wir auf “Manage Environment” (3). Übrigens: Das ArcGIS Conda benutzt sehen wir an (4).\nKlicke hier auf “Clone Default” um die Umgebung zu kopieren. Das dauert eine Weile, danach kann man die neue Environment auswählen (Klick auf den Button “Active”). Notiert dir den Namen der neuen Environment, speichere das ArcGIS Projekt ab und starte das ArcGIS neu\n\n\nSchritt 2: Die neue Environment aktivieren\nNun haben wir uns eine wunderschöne Python Umgebung parat gemacht und können diese jetzt in CMD aktivieren. Starte dazu Command Prompt / CMD und schaue dir die verfügbaren environments an:\nconda env list\nBei mir sieht der output folgendermassen aus:\n# conda environments:\n#\narcgisonline             C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\arcgisonline\narcgisonline2            C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\arcgisonline2\narcgispro-py3-clone      C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone\narcgispro-py3-clone1     C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone1\ncameratraps-detector     C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\cameratraps-detector\ngeopython                C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\geopython\ntest                     C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\test\narcgispro-py3         *  C:\\Program Files\\ArcGIS\\Pro\\bin\\Python\\envs\\arcgispro-py3\nroot                     C:\\Program Files\\ArcGIS\\Pro\\bin\\Python\nAktiviere nun die eben erstelle environment mit folgendem code (ersetzte name-der-environment mit dem tatsächlichen Namen deiner neuen environment aus dem letzten Schritt.\nactivate name-der-environment\n\n\nSchritt 3: weitere Module installieren\nGlücklicherweise ist jupyterlab bereits in der arcgis environment installiert, dies können wir mit folgendem code überprüfen:\nconda list\n# packages in environment at C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone1:\n#\naffine                    2.3.0                      py_0    anaconda\narcgis                    1.8.2                 py36_1275    esri\narcgispro                 2.6                           0    esri\n.\n.\n.\njupyterlab                2.2.9                      py_0    conda-forge\njupyterlab_pygments       0.1.2              pyh9f0ad1d_0    conda-forge\njupyterlab_server         1.2.0                      py_0    conda-forge\n.\n.\n.\nWenn jetzt aber noch module fehlen (wie z.B. geopandas), dann können wir diese wie gewohnt installieren.\n\n\nSchritt 4: arcpy verwenden\nWenn alles gewünschten Module installiert sind können wir nun JupyterLab starten.\nSobald JupyterLab gestartet ist, können wir innerhalb einer cell das Modul arcpy mit import arcpy importieren und nun auch verwenden. Zum Beispiel folgendermassen:\nimport arcpy\nfrom arcpy import env\n\n# Set environment settings\nenv.workspace = \"C:/data/Habitat_Analysis.gdb\"\n\n# Select suitable vegetation patches from all vegetation\nveg = \"vegtype\"\nsuitableVeg = \"C:/output/Output.gdb/suitable_vegetation\"\nwhereClause = \"HABITAT = 1\" \narcpy.Select_analysis(veg, suitableVeg, whereClause)\nDer Syntax ist auf jeder jeweiligen Tool Beschreibung gut dokumentiert (Abschnitt “Code Sample”, z.B. hier)",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/20_Anhang.html#footnotes",
    "href": "C_Programmieren_2/20_Anhang.html#footnotes",
    "title": "Anhang",
    "section": "",
    "text": "Mit Konsole ist unter Windows cmd gemeint (Windowstaste &gt; cmd). Unter Linux wird bash, auf Mac der Terminal verwendet.↩︎\nUnter Linux: conda activate geopython↩︎\nIn Programmieren I - III brauchen wir die Module pandas, matplotlib, geopandas und descartes↩︎\nDies macht sich bemerkbar duch die Fehlermeldung ModuleNotFoundError: No module named 'pandas'↩︎\nFalls die richtige environment noch nicht aktiviert ist, muss dies zuerst noch erfolgen (z.B activate geopython).↩︎\nAus: https://stackoverflow.com/a/67376348/4139249↩︎",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/1_Einleitung.html",
    "href": "C_Programmieren_3/1_Einleitung.html",
    "title": "Programmieren III",
    "section": "",
    "text": "Heute widmen wir uns zwei grossen Themen bevor wir uns an die Umsetzung der Monte Carlo Simulation wenden.\nIm ersten Thema geht es um for Loops, mit denen wir eine Aufgabe mehrfach (“Iterativ”) durchzuführen können. Ein for Loop ist ein sehr wichtiges und hilfreiches Werkzeug das man unbedingt kennen sollte. Wir werden for loops brauchen um Zeckenstiche zu simulieren, indem wir die bestehenden Meldungen x-fach zufällig verschieben. Das Thema for loops behandeln wir in Einführung in for loop, Basic for loop und Advanced for loops.\nBeim zweiten Thema geht es um GIS. Wir haben bisher mit Daten gearbeitet die eine Rauminformation beinhalten, die Zeckenstiche haben x/y-Koordinaten. Diese Rauminformation haben wir aber nicht als solche behandelt, wir haben die Koordinaten als Zahlen eingelesen und uns nicht gross darum geschert, dass es sich dabei um spezifische Punkte in der Schweiz handelt. Heute werden wir dies ändern müssen da uns eine räumliche Abfrage bevorsteht: Wir wollen nämlich wissen, welche Zeckenstiche sich im Wald befinden. Dadurch lernen wir eine neue Erweiterung kennen und sehen, was für räumliche Operationen in Python möglich sind. Das Thema behandeln wir in Input: GIS in Python, Räumliche Operationen und Spatial Joins.\nDie Übungen in Programmieren III kannst du mit deiner in Übung 5 erstellten Conda-Umgebung geopython2 durchführen.\n\n\n\n\n\n\nHinweisÜbungsziele\n\n\n\n\nIhr kennt for-Loops und könnt sie anwenden\nIhr seht, was mit räumlichen Operationen in Python möglich ist und kennt ein Tool, welches dazu notwendig ist\nIhr könnt räumliche Operationen (spatial join, overlay) in Python umsetzen\nIhr könnt summary Statistiken (mit groupby/count) aus DataFrames extrahieren",
    "crumbs": [
      "Programmieren III"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_For_Loops_Intro.html",
    "href": "C_Programmieren_3/2_For_Loops_Intro.html",
    "title": "Einführung in for loop",
    "section": "",
    "text": "Die Grundform\nNirgends ist der Aspekt der Automatisierung so sichtbar wie in for loops. Loops sind “Schleifen” wo eine Aufgabe beliebig lange wiederholt wird. Auch for loops sind im Grunde genommen simple. Auf den ersten Blick sieht eine for loop aus wie eine Function definition (siehe Function Basics und Function Advanced). Im folgenden Beispiel seht ihr ein minimales Beispiel einer for loop.\nfor platzhalter in [0,1,2]:\n    print(\"Iteration\",platzhalter)\n\nIteration 0\nIteration 1\nIteration 2",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Einführung in *for loop*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_For_Loops_Intro.html#die-grundform",
    "href": "C_Programmieren_3/2_For_Loops_Intro.html#die-grundform",
    "title": "Einführung in for loop",
    "section": "",
    "text": "for legt fest, dass eine For-Loop beginnt\nNach for kommt eine Platzhalter-Variabel, die ihr beliebig benennen könnt. Im obigen Beispiel lautet diese platzhalter\nNach dem Platzhalter kommt der Begriff in. Dieser Begriff kommt zwingend nach dem Platzhalter.\nNach in wird der “Iterator” festgelegt, also worüber der For-Loop iterieren soll (hier: über eine List mit den Werten [0,1,2]).\nDanach kommt ein Doppelpunkt : der zeigt: “Nun legen wir gleich fest was im For-Loop passieren soll” (ähnlich wie in einer Function)\nAuf einer neuen Zeile wird eingerückt festgelegt, was in der For-Loop passieren soll. Dieser Teil kann beliebig lange sein, ein for loop ist dann fertig, wenn man nicht mehr eingerückt wird. In unserem Fall wird mit print1 etwas in die Konsole ausgegeben.\nAchtung: return() gibt’s in For-Loops nicht!",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Einführung in *for loop*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_For_Loops_Intro.html#der-iterator",
    "href": "C_Programmieren_3/2_For_Loops_Intro.html#der-iterator",
    "title": "Einführung in for loop",
    "section": "Der Iterator",
    "text": "Der Iterator\nIm obigen Beispiel haben wir über eine List iteriert, wir haben also eine Liste als Iterator verwendet. Es gibt aber noch andere “Dinge”, über die wir iterieren können. Angenommen wir wollen den gleichen for loop mit den Zahlen von 0 bis 100 oder 100 bis 1’000 durchführen. Es wäre ganz schön mühsam, alle Zahlen von 0 bis 100 manuell in einer Liste zu erfassen. Zu diesem Zweck können wir die Funktion range verwenden. Mit range(3) erstellen wir einen Iterator mit den Werten 0, 1 und 2. Mit range(100,1001) erhalten wir die Werte von 100 bis 1’000.\nDer gleiche loop wie oben lautet mit range folgendermassen:\n\nfor platzhalter in range(3):\n    print(\"Iteration\",platzhalter)\n\nIteration 0\nIteration 1\nIteration 2",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Einführung in *for loop*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_For_Loops_Intro.html#der-platzhalter",
    "href": "C_Programmieren_3/2_For_Loops_Intro.html#der-platzhalter",
    "title": "Einführung in for loop",
    "section": "Der Platzhalter",
    "text": "Der Platzhalter\nDie Platzhaltervariabel liegt immer zwischen for und in, den Namen dieser Variabel könnt ihr frei wählen. Ich habe sie im obigen Beispiel platzhalter genannt. Speziell an dieser Variabel ist, dass sie während der Dauer des Loops ihren Wert verändert. Mehr dazu in Basic for loop.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Einführung in *for loop*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_For_Loops_Intro.html#footnotes",
    "href": "C_Programmieren_3/2_For_Loops_Intro.html#footnotes",
    "title": "Einführung in for loop",
    "section": "",
    "text": "Mit print können wir Variabeln in die Konsole “ausdrucken” lassen. Innerhalb von print können dazu verschiedene Variablen kommagetrennt aufgeführt werden, ohne sie mit + verbinden zu müssen wie damals in Function Basics.↩︎",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Einführung in *for loop*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_Uebung_11.html",
    "href": "C_Programmieren_3/2_Uebung_11.html",
    "title": "Übung 11",
    "section": "",
    "text": "Übung 11.1\nKopiere den folgenden for Loop und lasse ihn bei dir laufen. Spiele mit den Werten rum, um ein Gefühl für For Loops zu bekommen: Ergänze die Liste mit weiteren Zahlen, verändere den Namen der Platzhaltervariabel und verändere den Text, der in print ausgegeben wird.\nfor platzhalter in [0,1,2,5,10]:\n    print(\"Iteration\",platzhalter)\n\nIteration 0\nIteration 1\nIteration 2\nIteration 5\nIteration 10",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Übung 11</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_Uebung_11.html#sec-for-gruss",
    "href": "C_Programmieren_3/2_Uebung_11.html#sec-for-gruss",
    "title": "Übung 11",
    "section": "Übung 11.2",
    "text": "Übung 11.2\nKonstruiere eine Liste bestehend aus 3 Namen und nenne diese Liste namen. Erstelle danach einen for loop, mit welcher jede Person in der Liste gegrüsst wird. Nutze dafür print.\nDer Output könnte etwa so aussehen:\n\n\nCiao  Il Buono\nCiao  Il Brutto\nCiao  Il Cattivo",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Übung 11</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_Uebung_11.html#übung-11.3",
    "href": "C_Programmieren_3/2_Uebung_11.html#übung-11.3",
    "title": "Übung 11",
    "section": "Übung 11.3",
    "text": "Übung 11.3\nKopiere den folgenden For Loop und spiele hier mit den Werten herum. Verändere den For Loop so, dass er über die Werte von -5 bis +5 iteriert.\n\nfor nonsense in range(3, 5):\n    print(\"Iteration\",nonsense)\n\nIteration 3\nIteration 4",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Übung 11</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_Uebung_11.html#übung-11.4",
    "href": "C_Programmieren_3/2_Uebung_11.html#übung-11.4",
    "title": "Übung 11",
    "section": "Übung 11.4",
    "text": "Übung 11.4\nBis jetzt haben unsere Loops nicht viel Arbeiten müssen. Erstelle nun einen For Loop, welcher für die Werte -5 bis +5 folgendes ausgibt:\nDas Quadrat von -5 ist 25\nDas Quadrat von -4 ist 16\n...",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Übung 11</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_Uebung_11.html#sec-forloops-ex-party",
    "href": "C_Programmieren_3/2_Uebung_11.html#sec-forloops-ex-party",
    "title": "Übung 11",
    "section": "Übung 11.5",
    "text": "Übung 11.5\nBisher haben wir die Platzhaltervariabel immer in unserem Loop wiederverwendet. Das müssen wir aber gar nicht, wir können den for loop einfach nutzen um etwas x mal zu wiederholen. Erstellen einen for loop der folgende beiden Sätze 5x wiederholt:\nWho likes to party?\nWe like to party!\nWho likes to party?\n....\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nNutze dafür zwei verschiedene print Befehle auf zwei Zeilen.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Übung 11</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/3_For_Loops_Basics.html",
    "href": "C_Programmieren_3/3_For_Loops_Basics.html",
    "title": "Basic for loop",
    "section": "",
    "text": "Bis jetzt haben wir lediglich Sachen in die Konsole herausgeben lassen, doch wie schon bei Functions ist der Zweck einer for loop meist, dass nach Durchführung etwas davon zurückbleibt. Aber return() gibt es wie bereits erwähnt bei for loops nicht. Nehmen wir folgendes Beispiel:\n\nfor rolle in [\"bitch\",\"lover\",\"child\",\"mother\",\"sinner\",\"saint\"]:\n    liedzeile = \"I'm a \"+ rolle \n    print(liedzeile)\n\nI'm a bitch\nI'm a lover\nI'm a child\nI'm a mother\nI'm a sinner\nI'm a saint\n\n\nDer Output von dieser For-Loop sind zwar sechs Liederzeilen, wenn wir die Variabel liedzeile aber jetzt anschauen ist dort nur das Resultat aus der letzten Durchführung gespeichert. Das gleiche gilt auch für die Variabel rolle.\n\nliedzeile\n\n\"I'm a saint\"\n\n\n\nrolle\n\n'saint'\n\n\nDas verrät uns etwas über die Funktionsweise des for loops: Bei jedem Durchgang werden die Variablen immer wieder überschrieben. Wenn wir also den Output des ganzen For-Loops abspeichern wollen, müssen wir dies etwas vorbereiten.\nDafür erstellen wir unmittelbar for dem for loops einen leeren Behälter, zum Beispiel eine leere Liste:\n\nrefrain = []\n\nNun können wir innerhalb des Loops append() nutzen, um den Output von einem Durchgang dieser Liste hinzuzufügen.\n\nfor rolle in [\"bitch\",\"lover\",\"child\",\"mother\",\"sinner\",\"saint\"]:\n    liedzeile = \"I'm a \"+ rolle \n    refrain.append(liedzeile)\n\nIn unserer Liste refrain ist nun der Wert jeder Iteration gespeichert.\n\nrefrain\n\n[\"I'm a bitch\",\n \"I'm a lover\",\n \"I'm a child\",\n \"I'm a mother\",\n \"I'm a sinner\",\n \"I'm a saint\"]",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Basic *for loop*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/3_Uebung_12.html",
    "href": "C_Programmieren_3/3_Uebung_12.html",
    "title": "Übung 12",
    "section": "",
    "text": "Übung 12.1\nNehmen wir nochmals das Beispiel aus Übung 11.2. Erstelle nochmal ein Loop, wo drei Personen aus einer Liste gegrüsst werden. Diesmal sollen aber die drei Grüsse in einer Liste (z.B. mylist) gespeichert werden.\n# Das Resultat sieht dann so aus:\nmylist\n\n['Ciao Il Buono', 'Ciao Il Brutto', 'Ciao Il Cattivo']",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Übung 12</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/3_Uebung_12.html#sec-ex-loopoutput",
    "href": "C_Programmieren_3/3_Uebung_12.html#sec-ex-loopoutput",
    "title": "Übung 12",
    "section": "Übung 12.2",
    "text": "Übung 12.2\nDer im Beispiel verwendete Refrain aus dem Lied “Bitch” von Meredith Brooks besteht bis auf zwei Zeilen aus Wiederholungen. Versuche mit zwei verschiedenen, aneinander gereihten for loops den ganzen Refrain in einer Liste zu speichern. Die beiden Teile die vom Muster Abweichen (“I do not feel ashamed” und “You know you wouldn’t want it any other way”) kannst du auch ausserhalb der Loops in die Listen einfügen (append).\n\n# Das Resultat sieht dann so aus:\nrefrain\n\n[\"I'm a bitch\",\n \"I'm a lover\",\n \"I'm a child\",\n \"I'm a mother\",\n \"I'm a sinner\",\n \"I'm a saint\",\n 'I do not feel ashamed',\n \"I'm your hell\",\n \"I'm your dream\",\n \"I'm nothing in between\",\n \"You know you wouldn't want it any other way\"]",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Übung 12</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_For_Loops_Advanced.html",
    "href": "C_Programmieren_3/4_For_Loops_Advanced.html",
    "title": "Advanced for loops",
    "section": "",
    "text": "Verschachtelte for loops\nIn diesem Kapitel kommen noch zwei Aspekte von for loops, die als “Advanced” eingestuft werden können aber in der Praxis sehr nützlich sind. Dabei geht es einerseits um verschachtelte for loops und zum andere um eine verkürzte Schreibweise von for loops.\nWir können verschiedene for loops auch ineinander verschachteln (englisch: nested loops). Das ist vor allem dann nützlich, wenn alle Kombinationen aus zwei Datensätzen miteinander verrechnet werden müssen. Angenommen du willst die drei Mitglieder deiner Band (bestehend aus Il Buono, Il Brutto, Il Cattivo) deinen Eltern vorstellen und auch umgekehrt deine Eltern deiner Band vorstellen. Für so was eignen sich zwei verschachtelte for Loops hervorragend:\neltern = [\"Papa\", \"Mama\"]\nband = [\"Il Buono\", \"Il Brutto\", \"Il Cattivo\"]\n\nfor bandmitglied in band:\n    for elternteil in eltern:\n        print(elternteil, \"das ist\",bandmitglied)\n        print(bandmitglied, \"das ist\",elternteil)\n        print(\"---\")\n\nPapa das ist Il Buono\nIl Buono das ist Papa\n---\nMama das ist Il Buono\nIl Buono das ist Mama\n---\nPapa das ist Il Brutto\nIl Brutto das ist Papa\n---\nMama das ist Il Brutto\nIl Brutto das ist Mama\n---\nPapa das ist Il Cattivo\nIl Cattivo das ist Papa\n---\nMama das ist Il Cattivo\nIl Cattivo das ist Mama\n---",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Advanced *for loops*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_For_Loops_Advanced.html#verschachtelte-for-loops",
    "href": "C_Programmieren_3/4_For_Loops_Advanced.html#verschachtelte-for-loops",
    "title": "Advanced for loops",
    "section": "",
    "text": "Hinweis\n\n\n\n\n\nAls Platzhaltervariabel nutze ich wenn immer möglich das Singulär und für den Iterator das Plural von dem Objekt, über das ich iteriere. for bandmitglied in band, for vogel in voegel usw, dies hilft mir den Überblick im loop zu bewahren.\n\n\n\n\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nEin anderes Beispiel: In Übung 11.5 haben wir die beiden Zeilen \"Who likes to party?\", “We like to party?” 5x wiederholt. Dabei werden die Wörter `to party für jede Wiederholung zwei mal wiederholt:\nWho likes to party?\nWe like to party!\nWho likes to party?\nWe like to party!\n...\n\nDies kann man in zwei verschachtelte For Loops umschreiben:\nfor i in range(5):\n    inner = [\"Who likes\", \"We like\"]\n    for j in inner:\n        print(j+\" to party\")\n\nWho likes to party\nWe like to party\nWho likes to party\nWe like to party",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Advanced *for loops*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_For_Loops_Advanced.html#verkürzte-schreibweise",
    "href": "C_Programmieren_3/4_For_Loops_Advanced.html#verkürzte-schreibweise",
    "title": "Advanced for loops",
    "section": "Verkürzte Schreibweise",
    "text": "Verkürzte Schreibweise\nEs ist äusserst häufig der Fall, dass wir den Output aus einem Loop in einer Liste abspeichern wollen. Wie das geht haben wir ja bereits in Basic for loop gelernt:\n\nrollen = [\"bitch\",\"lover\",\"child\",\"mother\",\"sinner\",\"saint\"]\n\nrefrain = []\nfor rolle in rollen:\n    liedzeile = \"I'm a \"+ rolle \n    refrain.append(liedzeile)\n\nNur ist das ein bisschen umständlich, weil wir dafür viele Zeilen Code brauchen, um etwas eigentlich ganz simples zu bewerkstelligen. Es gibt deshalb dafür auch eine verkürzte Schreibweise, welche ich in der letzten Woche bereits einmal verwendet habe (siehe Übung 9.6). Der obige Loop hat in der verkürzten Schreibweise die folgende Form:\n\nrefrain = [\"I'm a \"+ rolle for rolle in rollen]\n\nDiese verkürzte Schreibweise heisst in Python list comprehension und sie ist äusserst praktisch, wenn man sie beherrscht. Das Beherrschen ist aber nicht zentral, es reicht schon wenn ihr eine solche Schreibweise wieder erkennt und richtig interpretieren könnt (im Sinne von “Aha, hier wird also in einem Loop eine Liste erstellt”). In der folgenden Darstellung seht ihr farblich, welche Elemente sich in der verkürzten Schreibweise wo wiederfinden und welche Elemente gar nicht wiederverwendet werden.\n\nrollen = [\"bitch\",\"lover\",\"child\",\"mother\",\"sinner\",\"saint\"]\n\n\n\nHerkömmlicher For-Loop:\n\n  ref = []\n  for r in rollen:\n      liedzeile = \"I'm a \"+ r\n      refrain.append(liedzeile)\n  \n\n\n\n\nVerkürzte Schreibweise:\n\nref = [\"I'm a \"+ r for r in rollen]",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Advanced *for loops*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_Uebung_13.html",
    "href": "C_Programmieren_3/4_Uebung_13.html",
    "title": "Übung 13",
    "section": "",
    "text": "Übung 13.1\nErstelle zwei Listen bestehend aus 3 Hundenamen (hunde) und 3 Katzennamen (katzen). Erstelle einen verschachtelten For Loop, wo jeder Hund jede Katze beisst und jede Katze jeden Hund kratzt.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Übung 13</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_Uebung_13.html#übung-13.1",
    "href": "C_Programmieren_3/4_Uebung_13.html#übung-13.1",
    "title": "Übung 13",
    "section": "",
    "text": "Bruno beisst Greta und Greta kratzt  Bruno\nBerta beisst Greta und Greta kratzt  Berta\nHelmi beisst Greta und Greta kratzt  Helmi\n....",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Übung 13</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_Uebung_13.html#übung-13.2",
    "href": "C_Programmieren_3/4_Uebung_13.html#übung-13.2",
    "title": "Übung 13",
    "section": "Übung 13.2",
    "text": "Übung 13.2\nErstelle einen verschachtelten Loop, wo alle Kombinationen von 0 bis 9 miteinander addiert werden.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Übung 13</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_Uebung_13.html#übung-13.3",
    "href": "C_Programmieren_3/4_Uebung_13.html#übung-13.3",
    "title": "Übung 13",
    "section": "Übung 13.3",
    "text": "Übung 13.3\nNutze die Funktion offset_coordinate (Lösung aus Übung 8.5) um einen Punkt in einem Koordinatensystem zu verschieben. Diesmal soll der Punkt aber nicht nur 1x, sondern 100x verschoben werden (100 Simulationen).",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Übung 13</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_Uebung_13.html#übung-13.4-fakultativ",
    "href": "C_Programmieren_3/4_Uebung_13.html#übung-13.4-fakultativ",
    "title": "Übung 13",
    "section": "Übung 13.4 (fakultativ)",
    "text": "Übung 13.4 (fakultativ)\nVersuche die Monte Carlo Simulation für die Annäherung an Pi (aus der ersten Übung “Datenqualität und Unsicherheit) mit einer Funktion und einem For Loop zu lösen.\nZur Erinnerung, die Vorgehensweise für die Annäherung an Pi geht folgendermassen:\n\nZufallskoordinaten (x, y) zwischen 0 und 1 erstellen\nDistanz zum Ursprung (0) mit der Formel \\(\\sqrt(x^2+y^2)\\) berechnen\nBestimmen ob sich der Punkt innerhalb des Kreisviertels befindet (\\(d &lt; 1\\))\nSchritte 1 & 2 mehrfach wiederholen\nAnteil der Punkte innerhalb des Kreisviertels mit 4 Multiplizieren\n\nTipps:\n\nFür die Erstellung der Zufallspunkte brauchst du die Funktion random() aus dem modul random\nSchritte 1 - 3 werden am sinnvollsten ein eine Funktion verpakt, welche keine Argumente benötigt\nSchritt 4 löst du am besten mit einer For loop mit range(100) (für 100 Wiederholungen)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Übung 13</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/5_GIS_in_Python.html",
    "href": "C_Programmieren_3/5_GIS_in_Python.html",
    "title": "Input: GIS in Python",
    "section": "",
    "text": "DataFrames &gt; GeoDataFrames\nManche mag das jetzt überraschen, andere haben es vielleicht schon gemerkt: Mit GIS hatte unseres bisheriges Wirken in Python eigentlich wenig zu tun. Unsere Zeckenstiche haben zwar x/y-Koordinaten, aber diese haben wir bisher gleich behandlet wie alle anderen Spalten.\nAnders gesagt: Wir wissen ja, dass mit den Spalten x und y Koordinaten in der Schweiz gemeint sind, Python hingegen wusste das bisher (noch) nicht. Der konkrete Raumbezug fehlt also noch und das wird irgendwann problematisch: Denn bald wollen wir für jeden simulierten Zeckenstich ermitteln, ob er sich im Wald befindet oder nicht. Das ist eine explizit räumliche Abfrage, welche nur mit explizit räumlichen Geodaten beantwortet werden kann.\nWas wir später mit den simulierten Zeckenstiche machen wollen, spielen wir an dieser Stelle mit den original Zeckenstichmeldungen (zeckenstiche.csv, siehe Tabelle 1) durch.\nGlücklicherweise können wir unsere Zeckenstich-Dataframe mit nur einem Zusatzmodul und wenigen Zeilen Code in eine räumliche DataFrame konvertieren. Mit dem Modul geopandas erstellen wir aus unserer pandas DataFrame eine geopandas GeoDataFrame. Mit dieser Erweiterung erhält die DataFrame:\nBeide Bestandteile müssen wir bei der Erstellung der GeoDataFrame festlegen. Nachstehend seht ihr, wie ihr dies bei den Zeckenstichen machen könnt. Was diese Bestandteile genau bedeuten, seht ihr in Aufbau von GeoDataFrames (geometry) und Koordinatenbezugssystem (crs).\nimport geopandas as gpd\n\ngeom = gpd.points_from_xy(\n  zeckenstiche['x'],    # ↘\n  zeckenstiche['y']     # → die Geometrie Spalte\n  )   \n\nzeckenstiche_gpd = gpd.GeoDataFrame(\n    zeckenstiche,    # die DataFrame (\"Attributtabelle\")\n    geometry = geom, #\n    crs = 2056       # das Koordinatenbezugssystem (EPSG Code)\n    )\nNun sehen wir, dass die neue geometry-Spalte die Punkt-Geometrie enthält.\nzeckenstiche_gpd\n\n\n\n\n\n\n\n\nID\naccuracy\nx\ny\ngeometry\n\n\n\n\n0\n2550\n439.128951\n2681116\n1250648\nPOINT (2681116 1250648)\n\n\n1\n10437\n301.748542\n2681092\n1250672\nPOINT (2681092 1250672)\n\n\n2\n9174\n301.748542\n2681128\n1250683\nPOINT (2681128 1250683)\n\n\n3\n8773\n301.748542\n2681111\n1250683\nPOINT (2681111 1250683)\n\n\n4\n2764\n301.748529\n2681131\n1250692\nPOINT (2681131 1250692)\n\n\n5\n2513\n301.748529\n2681171\n1250711\nPOINT (2681171 1250711)\n\n\n6\n9185\n301.748542\n2681107\n1250712\nPOINT (2681107 1250712)\n\n\n7\n28521\n301.748542\n2681124\n1250720\nPOINT (2681124 1250720)\n\n\n8\n26745\n301.748542\n2681117\n1250725\nPOINT (2681117 1250725)\n\n\n9\n27391\n301.748542\n2681138\n1250725\nPOINT (2681138 1250725)\nZudem hat die GeoDataFrame nun ein Attribut crs, wo das Koordinatenbezugssystem gespeichert ist.\nzeckenstiche_gpd.crs.name\n\n'CH1903+ / LV95'",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Input: GIS in Python</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-geodataframe",
    "href": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-geodataframe",
    "title": "Input: GIS in Python",
    "section": "",
    "text": "geometry: eine Zusatzspalte geometry mit der Geometrie als räumliches Objekt und\ncrs: ein Attribut crs, welches das Koordinatenbezugssystem der Geometriespalte enthält.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Input: GIS in Python</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-datenstruktur",
    "href": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-datenstruktur",
    "title": "Input: GIS in Python",
    "section": "Aufbau von GeoDataFrames",
    "text": "Aufbau von GeoDataFrames\nMit geometry = haben wir die Geometriespalte der GeoDataFrame festgelegt. Bei unseren Zeckenstichdaten ist die Geometrie sehr simpel: Sie besteht aus Punkt-Objekte die sich wiederum aus den x- und y-Koordinaten zusammensetzen. Um x/y-Koordinaten in Punktgeometrien zu konvertieren, gibt es in Geopandas die Funktion points_from_xy. Diese verwende ich im obigen Code, um die Punkt-Objekte zu erstellen.\nAn dieser Stelle ist es wichtig, die drei Hierarchiestufen von GeoDataFrames zu kären. Von “unten” nach “oben” erläutert gibt es folgende Stufen:\n\nGeometry: Einzelne Objekte der folgenden Typen\n\nPoints / Multipoint (siehe Note 44.1)\nLinestring / Multilinestring\nPolygon / Multipolygon\n\nGeoSeries: Eine vielzahl an Geometries, typischerweise eine Spalte einer GeoDataFrame namens (geometry)\nGeoDataFrame: Eine Tabelle, welche über eine Geometrie-Spalte (GeoSeries) verfügt\n\n\n\n\n\n\n\nAbbildung 44.1: Die drei Hierarchien in Geopandas: Eine GeoDataFrame verfügt immer über eine Geometrie-Spalte, welche sich eine GeoSeries nennt. Diese wiederum besteht aus Einzelgeometrien, sogenannten Geometries.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Input: GIS in Python</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-crs",
    "href": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-crs",
    "title": "Input: GIS in Python",
    "section": "Koordinatenbezugssystem",
    "text": "Koordinatenbezugssystem\nMit crs = wird das Koordinatenbezugssystem (engl. Coordinate Reference System) unseres Datensatzes festgelegt. Das Koordinatenbezugssystem gibt unseren x/y-Zahlenwerten einen konkreten Raumbezug auf dem Planeten und macht aus ihnen Koordiaten in der Schweiz. Wie lautet aber das “Koordinatenbezugssystem” unserer Daten?\nIm Prinzip weiss diese Information nur derjenige, der die Daten erstellt hat. Man man das Koordinatensytem aber auch anhand der Koordinaten erahnen: Es handelt sich in unserem Fall um Werte im Bereich von 2’600’000 auf der einen und 1’200’000 auf der anderen Achse. Da wir wissen, dass die Daten aus der Schweiz stammen, kann man mit etwas Erfahrung sagen, dass es sich um Daten im neuen Schweizer Koordinatenbezugssystem CH1903+ / LV95 handeln muss. Der EPSG Code dieses Koordinatenbezugssystems lautet 2056 und diesen Code können wir in der Funktion gpd.GeoDataFrame nutzen, um das korrekte Koordinatenbezugssystem zuzuweisen.\n\n# Das Attribut `crs` wurde aufgrund vom EPSG Code richtig erkannt:\nzeckenstiche_gpd.crs.name\n\n'CH1903+ / LV95'\n\n\nDiese CRS Information erlaubt uns auch, mit einer Zeile Code eine Webmap unserer Zeckenstiche zu machen. Versucht es aus!\n\nzeckenstiche_gpd.explore()\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Input: GIS in Python</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-formate",
    "href": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-formate",
    "title": "Input: GIS in Python",
    "section": "Geodatenformate",
    "text": "Geodatenformate\nDas Einlesen von CSV und die Konvertierung von DataFrame zu GeoDataFrame hat bei den Zeckenstichen zwar gut funktioniert, es ist aber auch etwas umständlich, jedes Mal die geometry Spalte und das crs zu setzen. CSVs eignen sich nicht besonders gut für das speichern von Geodaten, insbesonders wenn die Daten komplexer sind (Linien, Polygone..)). Deshalb gibt es auch spezifische Datenformate, in den Geodaten gespeichert werden können. Bei diesen Datenformaten werden geometry und crs automatisch abgespeichert.\nIhr seid im Studium mit solchen Datenformate bereits in Kontakt gekommen, sicher kennt ihr ESRI’s File Geodatabases/Feature Classes sowie Shapefiles. Dies sind häufig genutzte Formate, aber leider nicht offen, und gerade Shapefiles haben viele Tücken (siehe switchfromshapefile.org). Es gibt dafür ganz tolle Alternativen, beispielsweise Geopackages (nicht zu verwechseln mit ArcGIS Pro Packages!). Mit nachstehendem Befehl können wir zeckenstiche_gpd als Geopackage abspeichern.\n\nzeckenstiche_gpd.to_file(\"data/zeckenstiche.gpkg\", driver = \"GPKG\")   \n# Wer UNBEDINGT ein shapefile abspeichern will, \n# kann \".gpkg\" mit \".shp\" ersetzen\n# (-_-)\n\nDas File “zeckenstiche.gpkg” befindet sich nun in meiner Working Directory und ich kann sie mit gpd.read_file(\"data/zeckenstiche.gpkg\") wieder einlesen. Im Unterschied zu vorher musst ich nun geometry und crs nicht mehr zuweisen, diese sind beim Schreiben des Geopackage abgespeichert worden. Das Geopackage kann ich nun auch mit ArcGIS / QGIS öffnen, wenn ich die Punkte interaktiv explorieren möchte.\nIm Block “Datenqualität und Unsicherheit” habt ihr mit dem Wald-Datensatz gearbeitet. Ich habe diesen als Geopackage exportiert (siehe Tabelle 1) und kann ihn wie im nachstehenden Codeblock ersichtlich einlesen und visualisieren.\n\nwald = gpd.read_file(\"data/wald.gpkg\") # &lt;- importiert das File \"wald.gpkg\"\n\nwald\n\n\n\n\n\n\n\n\nShape_Area\nWald_text\ngeometry\n\n\n\n\n0\n2.380876e+08\nnein\nMULTIPOLYGON Z (((2692100 1256542.253 276.942,...\n\n\n1\n7.963237e+07\nja\nMULTIPOLYGON Z (((2689962.355 1245335.25 644.5...\n\n\n\n\n\n\n\nEs handelt sich also um einen Datensatz mit nur zwei Zeilen, aber mehreren Polygonen pro Zeile (das macht es zu einem Multipolygon). Mit plot können wir diesen Datensatz einfach visualisieren und mit den Zeckenstichdaten überlagern.\n\n\n\n\n\n\nHinweis 44.1\n\n\n\nDer Unterschied zwischen Point und Multipoint, Linesstring und Multilinestring und Polygon Multipolyon ist folgendermassen: Typischerweise hat jedes Attribut eine Geometrie. Zum Beispiel hat jede Zeckenstichmeldung eine ID, eine Ungenauigkeitsangabe und eben eine Punkgeometrie. Somit handelt es sich bei diesem Datensatz um einen einfach Point Datensatz. Wenn pro Attribut mehrere Geometrien zugewiesen sind handelt es sich um ein Multipoint Objekt.\n\n\n\nbase = wald.plot(color = [\"Lightgrey\",\"Green\"])\nzeckenstiche_gpd.plot(ax = base, color = \"red\")\n\n\n\n\n\n\n\n\nNoch einfacher und sogar mit einer Basemap und Zoom-Möglichkeit geht es mit der explore() Methode. Nun wird übrigens auch klar, dass es sich bei unseren 10 Zeckenstichen um sehr dicht beieinanderliegenden Punkte handelt.\n\nbase = wald.explore()\nzeckenstiche_gpd.explore(m = base, color = \"red\")\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Input: GIS in Python</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Raeumliche_Operationen.html",
    "href": "C_Programmieren_3/6_Raeumliche_Operationen.html",
    "title": "Räumliche Operationen",
    "section": "",
    "text": "Buffer\nWas bringt uns diese Geo Erweiterung? Mit GeoDataFrames sind nun alle räumliche Operationen möglich, die wir bereits aus ArcGIS kennen aber mit einfachen DataFrames noch nicht möglich waren. Ich möchte dies an ein paar Beispielen demonstrieren. Dazu müssen wir die Zeckenstiche in GeoDataFrame konvertiert und in ein Geopackage exportiert haben, wie in Input: GIS in Python beschrieben.\nEine typische GIS-Operation ist das “Buffern” von Objekten. Der ArcGIS Befehl “Buffer” erreichen wir in Geopandas mit .buffer(). Folgender Code macht einen Buffer mit einer Distanz von 10m.\nbuffered = zeckenstiche.buffer(10)\nUm Geopandas-Objekte zu plotten, kann man einfach .plot() verwenden. Zudem kann man mit boundary die Umrisse eines Polygons extrahieren:\nbase = buffered.boundary.plot() # plottet die boundries    \n\nzeckenstiche.plot(ax = base, color = \"black\") # plottet die Punkte",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Räumliche Operationen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Raeumliche_Operationen.html#union",
    "href": "C_Programmieren_3/6_Raeumliche_Operationen.html#union",
    "title": "Räumliche Operationen",
    "section": "Union",
    "text": "Union\nMit unary_union können wir aus unserer Point-Geometrie ein MultiPoint erstellen (siehe Aufbau von GeoDataFrames). Dieser Befehl lautet in ArcGIS Union.\n\nzeckenstiche_union = zeckenstiche[\"geometry\"].unary_union\n\ntype(zeckenstiche_union) # Es handelt sich nun um den Typ \"MultiPoint\"\n\nshapely.geometry.multipoint.MultiPoint\n\n\nWenn wir uns zeckenstiche_union nun mit print anschauen sehen wir, dass sämtliche Koordinaten in einem Objekt zusammengepackt sind:\n\nprint(zeckenstiche_union)\n\nMULTIPOINT ((2681092 1250672), (2681107 1250712), (2681111 1250683), (2681116 1250648), (2681117 1250725), (2681124 1250720), (2681128 1250683), (2681131 1250692), (2681138 1250725), (2681171 1250711))",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Räumliche Operationen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Raeumliche_Operationen.html#sec-raeumliche-operationen-mbg",
    "href": "C_Programmieren_3/6_Raeumliche_Operationen.html#sec-raeumliche-operationen-mbg",
    "title": "Räumliche Operationen",
    "section": "Minimum Bounding Geometry",
    "text": "Minimum Bounding Geometry\nÜber ein MultiPoint lassen sich jetzt wunderbar sogenannte (in ESRI Terminologie) Minimum Bounding Geometries rechnen. Mit den gleichnamigen Funktionen können wir nun eine convex_hull 1 sowie eine envelope 2 über alle Punkte rechnen.\n\nmy_convex_hull = zeckenstiche_union.convex_hull\nmy_envelope = zeckenstiche_union.envelope\n\nNun konvertiere ich beide Polygon-Geometrien in GeoSeries, damit sie einfacher zu visualisieren sind:\n\nmy_convex_hull = gpd.GeoSeries(my_convex_hull)\nmy_envelope = gpd.GeoSeries(my_envelope)\n\nUm die beiden Objekte nebeneinander zu visualisieren, importiere ich zuerst pyplot aus matplotlib (mit dem alias plt) und erstelle subplots\n\nfrom matplotlib import pyplot as plt\nfig, (ax1, ax2) = plt.subplots(1, 2,sharex=True, sharey = True,figsize = (9, 9))\n\n# Erstellt den linken Plot\nmy_convex_hull.plot(ax = ax1)\nax1.set_title(\"Convex Hull\")\nzeckenstiche.plot(ax = ax1, color = \"black\")\n\n# Erstellt den rechten Plot\nmy_envelope.plot(ax = ax2)\nax2.set_title(\"Envelope\")\nzeckenstiche.plot(ax = ax2, color = \"black\")",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Räumliche Operationen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Raeumliche_Operationen.html#overlay",
    "href": "C_Programmieren_3/6_Raeumliche_Operationen.html#overlay",
    "title": "Räumliche Operationen",
    "section": "Overlay",
    "text": "Overlay\nViele der Funktionen aus dem ESRI Toolset “Overlay” sind in der Geopandas Funktion overlay verpackt. Um sie zu demonstrieren nutze ich die Geometrien, die wir in weiter oben erstellt haben (buffered und my_convex_hull). Zuerst muss ich sie aber noch von GeoSeries in GeoDataFrames konvertieren.\n\nbuffered_gdf = gpd.GeoDataFrame(geometry = buffered, crs = 2056)               \nmy_convex_hull_gdf = gpd.GeoDataFrame(geometry = my_convex_hull, crs = 2056) \n\nNun kann ich beispielsweise die Overlay-Funktion difference ausführen:\n\nmy_difference = gpd.overlay(my_convex_hull_gdf,buffered_gdf, how='difference')\n\n\n# Bereitet die drei Subplots vor ################\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, sharex=True, sharey = True, figsize = (18,9))\n#################################################\n\n# Plot links ####################################\nmy_convex_hull_gdf.plot(ax = ax1)               #\nax1.set_title(\"1. Das Minimum Convex Polygon\")  # \nax1.set_axis_off()                              #\n# Plot mitte ####################################\nbuffered_gdf.plot(ax = ax2)                     #\nax2.set_title(\"2. Die gebufferten Punkte\")      # \nax2.set_axis_off()                              #\n# Plot rechts ###################################\nmy_difference.plot(ax = ax3)                    #\nax3.set_title(\"Differenz aus 1. & 2.\")          # \nax3.set_axis_off()                              #\n#################################################",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Räumliche Operationen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Raeumliche_Operationen.html#footnotes",
    "href": "C_Programmieren_3/6_Raeumliche_Operationen.html#footnotes",
    "title": "Räumliche Operationen",
    "section": "",
    "text": "Convex Hull stellt ein “Rahmen” um alle Punkte dar, wo alle Innenwinkel kleiner sind als 180° (konvex)↩︎\nEnvelope stellt ebenfalls ein “Rahmen um alle Punkte dar, die aber quadratisch geformt und am Koordiatensystem ausgerichtet ist.↩︎",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Räumliche Operationen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Uebung_14.html",
    "href": "C_Programmieren_3/6_Uebung_14.html",
    "title": "Übung 14",
    "section": "",
    "text": "Übung 14.1\nNun ist es Zeit, dass ihr selbst mit GeoDataFrames Hand anlegt. Achtet dabei immer auf die Datentypen eurer Daten (mit type) und konsultiert dazu Aufbau von GeoDataFrames. Zudem ist Geopandas gut dokumentiert, es lohnt ich diese immer wieder zu konsultieren: geopandas.org\nImportiere Geopandas und wandle zeckenstiche in eine GeoDataFrame um (zeckenstiche). Vergiss nicht, das Koordinatenbezugssystem festzulegen!",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Übung 14</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Uebung_14.html#übung-14.2",
    "href": "C_Programmieren_3/6_Uebung_14.html#übung-14.2",
    "title": "Übung 14",
    "section": "Übung 14.2",
    "text": "Übung 14.2\nBuffere die Zeckenstiche um eine Distanz von 12 Meter und speichere den Output in der Variabel zeckenstiche_buffer. Visualisiere die gebufferten Punkte mit .explore().\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Übung 14</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Uebung_14.html#übung-14.3",
    "href": "C_Programmieren_3/6_Uebung_14.html#übung-14.3",
    "title": "Übung 14",
    "section": "Übung 14.3",
    "text": "Übung 14.3\nExtrahiere die Umrisse von zeckenstiche_buffer und speichere diese in zeckenstiche_buffer_outline. Visualisiere anschliessend diese Umrisse.\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Übung 14</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Uebung_14.html#übung-14.4",
    "href": "C_Programmieren_3/6_Uebung_14.html#übung-14.4",
    "title": "Übung 14",
    "section": "Übung 14.4",
    "text": "Übung 14.4\nNutze nachstehenden Code, um zwei Datensätze im gleichen Plot darzustellen.\n\n\nMusterlösung\n# Nicht interaktiv:\nfrom matplotlib import pyplot as plt\nfig, ax = plt.subplots()\n\nzeckenstiche_buffer_outline.plot(ax = ax, color = \"green\")\nzeckenstiche_gpd.plot(ax = ax, color = \"pink\")\n\n\n\n\n\n\n\n\n\n\n\nMusterlösung\n# Interaktiv:\nbase = zeckenstiche_buffer_outline.explore(color = \"green\")\nzeckenstiche_gpd.explore(m = base, color = \"pink\")\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Übung 14</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Uebung_14.html#übung-14.5",
    "href": "C_Programmieren_3/6_Uebung_14.html#übung-14.5",
    "title": "Übung 14",
    "section": "Übung 14.5",
    "text": "Übung 14.5\nBerechne “Envelope” von zeckenstiche_gpd anhand der Beispiele in Räumliche Operationen. Speichere den Output als zeckenstiche_envelope.\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nDenk daran, dass du zuerst noch einen Union machen musst (siehe Räumliche Operationen)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Übung 14</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Uebung_14.html#übung-14.6",
    "href": "C_Programmieren_3/6_Uebung_14.html#übung-14.6",
    "title": "Übung 14",
    "section": "Übung 14.6",
    "text": "Übung 14.6\nExportiere zeckenstiche_gpd als “Geopackage” mit dem Namen “zeckenstiche.gpkg”. Lese nochmal Geodatenformate, wenn du nicht mehr weisst, wie das geht. Versuche anschliessend, “zeckenstiche.gpkg” wieder einzulesen.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Übung 14</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/7_Spatial_Joins.html",
    "href": "C_Programmieren_3/7_Spatial_Joins.html",
    "title": "Spatial Joins",
    "section": "",
    "text": "Wie funktioniert ein Spatial Join?\nIn dieser Aufgabe wollen wir für jeden Zeckenstich ermitteln, ob er sich im Wald befindet oder nicht. Den Wald-Layer kennt ihr bereits aus dem Block “Datenqualität und Unsicherheit” und wir haben ihn in Geodatenformate kurz angeschaut. Nutzen wir hier nochmal die Gelegenheit, um den Wald und die Zeckenstiche (siehe Tabelle 1) als Geodaten einzulesen und in einem grossen Plot zu visualisieren.\nIn Input: GIS in Python habt ihr euch mit den GIS-Funktionalitäten von geopandas vertraut gemacht. Eine ganz zentrale Funktion in GIS sind die sogenannten “Spatial Joins”. Dabei werden Attribute von einem Geodatensatz auf einen anderen Geodatensatz aufgrund einer räumlichen Beziehung der beiden Datensätze übertragen. Konkret für unsere Zeckenstiche bedeutet dies: Jedem Zeckenstich sollte die Eigenschaft “Wald: ja” / “Wald: nein” aus `wald zugewiesen werden. Am einfachsten lässt sich dies in einer Darstellung erklären:\nIn Python wird ein Spatial Join zwischen zeckenstiche und wald wie folgt durchgeführt (wichtig ist dabei auch die Reihenfolge der Argumente: left_df bestimmt den Geometrietyp des Outputs):\ngpd.sjoin(left_df = zeckenstiche_gpd, right_df = wald)\n\n\n\n\n\n\n\n\nID\naccuracy\nx\ny\ngeometry\nindex_right\nShape_Area\nWald_text\n\n\n\n\n0\n2550\n439.128951\n2681116\n1250648\nPOINT (2681116 1250648)\n0\n2.380876e+08\nnein\n\n\n1\n10437\n301.748542\n2681092\n1250672\nPOINT (2681092 1250672)\n0\n2.380876e+08\nnein\n\n\n2\n9174\n301.748542\n2681128\n1250683\nPOINT (2681128 1250683)\n0\n2.380876e+08\nnein\n\n\n3\n8773\n301.748542\n2681111\n1250683\nPOINT (2681111 1250683)\n0\n2.380876e+08\nnein\n\n\n4\n2764\n301.748529\n2681131\n1250692\nPOINT (2681131 1250692)\n0\n2.380876e+08\nnein\n\n\n5\n2513\n301.748529\n2681171\n1250711\nPOINT (2681171 1250711)\n1\n7.963237e+07\nja\n\n\n6\n9185\n301.748542\n2681107\n1250712\nPOINT (2681107 1250712)\n1\n7.963237e+07\nja\n\n\n7\n28521\n301.748542\n2681124\n1250720\nPOINT (2681124 1250720)\n1\n7.963237e+07\nja\n\n\n8\n26745\n301.748542\n2681117\n1250725\nPOINT (2681117 1250725)\n1\n7.963237e+07\nja\n\n\n9\n27391\n301.748542\n2681138\n1250725\nPOINT (2681138 1250725)\n1\n7.963237e+07\nja",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Spatial Joins</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/7_Spatial_Joins.html#wie-funktioniert-ein-spatial-join",
    "href": "C_Programmieren_3/7_Spatial_Joins.html#wie-funktioniert-ein-spatial-join",
    "title": "Spatial Joins",
    "section": "",
    "text": "Abbildung 47.1: “Spatial Join” zwischen zeckenstiche und wald. In diesem Spatial Join wurde die Geometrie von zeckenstiche übernommen, das heisst das Resultat des Joins ist ein Punkt-Layer.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Spatial Joins</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/7_Uebung_15.html",
    "href": "C_Programmieren_3/7_Uebung_15.html",
    "title": "Übung 15",
    "section": "",
    "text": "Übung 15.1\nLade das File “wald.gpkg” (siehe Tabelle 1) herunter und speichere es in deiner Workings Directory. Importiere den Datensatz und speichere ihn in der Variable wald.\nSchau dir wald an (mit type, .plot() etc.)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Übung 15</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/7_Uebung_15.html#sec-ex-spatialjoin",
    "href": "C_Programmieren_3/7_Uebung_15.html#sec-ex-spatialjoin",
    "title": "Übung 15",
    "section": "Übung 15.2",
    "text": "Übung 15.2\nFühre einen SpatialJoin zwischen wald und zeckenstiche durch. Vertausche die Reihenfolge (left_df, right_df) und schaue dir den Output an. Wodurch unterscheiden sich die beiden outputs? Was sagt dir das über die Funktionsweise von sjoin?\n\n\n\n\n\n\nHinweisWichtig!\n\n\n\nMelde dich bei den Betreuern wenn der SpatialJoin bei dir nicht funktioniert und du eine Fehlermeldung bekommst.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Übung 15</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/7_Uebung_15.html#sec-ex-count",
    "href": "C_Programmieren_3/7_Uebung_15.html#sec-ex-count",
    "title": "Übung 15",
    "section": "Übung 15.3",
    "text": "Übung 15.3\nFühre nun den SpatialJoin aus Übung 15.2 in der Reihenfolge aus, der dir am sinnvollsten erscheint. Weise den Output dieser Operation der Variabel zeckenstiche_join zu.\nNutze nun die dazugewonnene Spalte Wald_text um die Anzahl Zeckenstich-Meldungen im Wald zu zählen. Dazu musst du wie folgt vorgehen:\n\nEntsprechende Spalte selektieren (siehe Übung 4.5)\nWerte in der Spalte mit “ja” vergleichen\nAnzahl True mit sum() zählen (True entspricht immer 1, False entspricht immer 0)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Übung 15</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/7_Uebung_15.html#übung-15.4",
    "href": "C_Programmieren_3/7_Uebung_15.html#übung-15.4",
    "title": "Übung 15",
    "section": "Übung 15.4",
    "text": "Übung 15.4\nBerechne nun Anteil der Zeckenstiche im Wald (gemessen an der Anzahl Zeckenstich-Meldungen total). Weise den Output der Variabel anteil_wald zu.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Übung 15</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/9_Leistungsnachweis.html",
    "href": "C_Programmieren_3/9_Leistungsnachweis.html",
    "title": "Leistungsnachweis",
    "section": "",
    "text": "Ziel und Vorgehen\nFür den Leistungsnachweis von Programmieren sollt ihr den Anteil der Zeckenstiche im Wald unter der Berücksichtigung der Unsicherheit mit einer Monte Carlo Simulation ermitteln.\nGehe dazu wie folgt vor: Erstelle einen for loop (siehe Basic for loop), welcher pro Iteration folgende Schritte ausführt:\nflowchart LR\n   \n    A[\"zeckenstiche_full.csv\"]\n    G[\"Anteil Wald\"]\n    H[\"Boxplot\"]\n    subgraph loop [\"for loop (&gt;50x)\"]\n        direction TB\n        \n        B[\"zeckenstiche (DataFrame)\"]\n        C[\"Sim. Zeckenstiche (DataFrame)\"]\n        D[\"Sim. Zeckenstiche (GeoDataFrame)\"]\n        E[\"Sim. Zecken. Join (GeoDataFrame)\"]\n\n        B --&gt;|offset coordinate|C\n        C --&gt;|gpd.GeoDataFrame|D\n        D --&gt;|gpd.sjoin|E\n    end\n    A --&gt; |pd.read_csv|loop\n    loop --&gt;|Anteil Wald berechnen| G\n    G --&gt; H",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/9_Leistungsnachweis.html#ziel-und-vorgehen",
    "href": "C_Programmieren_3/9_Leistungsnachweis.html#ziel-und-vorgehen",
    "title": "Leistungsnachweis",
    "section": "",
    "text": "Schritt: Zeckenstiche importieren\nSchritt: Zeckenstiche auf der Basis von gemeldeten Stiche simulieren (siehe Funktionen in DataFrames)\nSchritt: Simulierte Zeckenstiche von pandas DataFrame in geopandas GeoDataFrame umwandeln (siehe DataFrames &gt; GeoDataFrames)\nSchritt: Spatial Join mit wald.gpkg (siehe Übung 15.2)\nSchritt: Der Anteil der Zeckenstiche im Wald Berechnen (siehe Übung 15.3)\nSchritt: Schritte 2 - 5 mindestens 50x Wiederholen (for loop)\nSchritt: Die verschiedenen Waldanteile visualiseren (z.B. in einem Boxplot, siehe Anhang 1: Daten visualisieren)\nSchritt: Schritte 6 und 7 für drei verschiedene Radien wiederholen\nSchritt (Optional): Eine Karte mit den simulierten Zeckenstichen erstellen (siehe Anhang 2: Geodaten visualisieren)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/9_Leistungsnachweis.html#anforderungen",
    "href": "C_Programmieren_3/9_Leistungsnachweis.html#anforderungen",
    "title": "Leistungsnachweis",
    "section": "Anforderungen",
    "text": "Anforderungen\nFühre die Analyse folgendermassen durch:\n\nmit dem ganzen Datensatz zeckenstiche_full.csv (1’076 Meldungen, siehe Tabelle 1)\nmit mindestens 50 Iterationen\nmit drei verschiedenen Distanz-Werten (distance = in Übung 9.5).\n\nVisualisiere für jeden Distanzwert die Verteilung der Anteile (z.B: mittels einem Boxplot)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/9_Leistungsnachweis.html#abgabeformat",
    "href": "C_Programmieren_3/9_Leistungsnachweis.html#abgabeformat",
    "title": "Leistungsnachweis",
    "section": "Abgabeformat",
    "text": "Abgabeformat\nLauffähigen Python Script file via Moodle.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/10_Anhang.html",
    "href": "C_Programmieren_3/10_Anhang.html",
    "title": "Anhang",
    "section": "",
    "text": "Anhang 1: Daten visualisieren\nEs ist äusserst Zentral, Daten regelmässig und oft zu visualisieren. Die de facto standart Library hierfür in Python ist matplotlib. Diese Library kann man direkt ansteuern wie in diesem Tutorial beschrieben wird. Wir verwenden die library jedoch etwas anders: Dabei nutzen wir die Tatsache aus, dass sowohl pandas wie auch geopandas eingebaute Methoden (methods) haben um deren Inhalte zu visualisieren. Die Methode heisst in beiden Fällen .plot(), wie wir weiter unten noch sehen werden.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/10_Anhang.html#sec-viz",
    "href": "C_Programmieren_3/10_Anhang.html#sec-viz",
    "title": "Anhang",
    "section": "",
    "text": "Histogramm aus List\npandas vereinfacht das Visualisieren von Daten sogar soweit, dass es sich jewils lohnt seine Listen, Dictionaries usw. zuerst in eine Series oder DataFrame zu überführen um sie zu visualisieren (wie ich zum Beispiel in Zufallszahlen generieren jeweils gemacht habe).\n\nimport random\nimport pandas as pd\n\nrandom_gamma = [random.gammavariate(1, 1) for x in range(1000)]\n\nrandom_gamma = pd.Series(random_gamma)\n\nrandom_gamma.plot(kind = \"hist\", bins = 50)\n\n\n\n\n\n\n\n\nWeitere Beispiele zu Histogrammen aus Listen findet ihr im Kapitel Zufallszahlen generieren .\n\n\nBoxplot aus List\nDas Visualisieren als Boxplot ist sehr ähnlich, man ersetzt \"hist\" lediglich durch \"box. Eine komplette liste der möglichen Argumente für findet ihr hier: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.plot.html\n\nrandom_gamma.plot(kind = \"box\")\n\n\n\n\n\n\n\n\n\n\nScatterplot aus DataFrame\nUm einen Scatterplot zu erstellen, braucht es eine DataFrame (eine Series reicht hierfür nicht aus).\n\nzeckenstiche = pd.read_csv(\"data/zeckenstiche.csv\")\n\n\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 zeckenstiche = pd.read_csv(\"data/zeckenstiche.csv\")\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\n   1013 kwds_defaults = _refine_defaults_read(\n   1014     dialect,\n   1015     delimiter,\n   (...)\n   1022     dtype_backend=dtype_backend,\n   1023 )\n   1024 kwds.update(kwds_defaults)\n-&gt; 1026 return _read(filepath_or_buffer, kwds)\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620, in _read(filepath_or_buffer, kwds)\n    617 _validate_names(kwds.get(\"names\", None))\n    619 # Create the parser.\n--&gt; 620 parser = TextFileReader(filepath_or_buffer, **kwds)\n    622 if chunksize or iterator:\n    623     return parser\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620, in TextFileReader.__init__(self, f, engine, **kwds)\n   1617     self.options[\"has_index_names\"] = kwds[\"has_index_names\"]\n   1619 self.handles: IOHandles | None = None\n-&gt; 1620 self._engine = self._make_engine(f, self.engine)\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880, in TextFileReader._make_engine(self, f, engine)\n   1878     if \"b\" not in mode:\n   1879         mode += \"b\"\n-&gt; 1880 self.handles = get_handle(\n   1881     f,\n   1882     mode,\n   1883     encoding=self.options.get(\"encoding\", None),\n   1884     compression=self.options.get(\"compression\", None),\n   1885     memory_map=self.options.get(\"memory_map\", False),\n   1886     is_text=is_text,\n   1887     errors=self.options.get(\"encoding_errors\", \"strict\"),\n   1888     storage_options=self.options.get(\"storage_options\", None),\n   1889 )\n   1890 assert self.handles is not None\n   1891 f = self.handles.handle\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/common.py:873, in get_handle(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\n    868 elif isinstance(handle, str):\n    869     # Check whether the filename is to be opened in binary mode.\n    870     # Binary mode does not support 'encoding' and 'newline'.\n    871     if ioargs.encoding and \"b\" not in ioargs.mode:\n    872         # Encoding\n--&gt; 873         handle = open(\n    874             handle,\n    875             ioargs.mode,\n    876             encoding=ioargs.encoding,\n    877             errors=errors,\n    878             newline=\"\",\n    879         )\n    880     else:\n    881         # Binary mode\n    882         handle = open(handle, ioargs.mode)\n\nFileNotFoundError: [Errno 2] No such file or directory: 'data/zeckenstiche.csv'\n\n\n\n\nzeckenstiche.plot(\"x\", \"y\", kind = \"scatter\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 zeckenstiche.plot(\"x\", \"y\", kind = \"scatter\")\n\nNameError: name 'zeckenstiche' is not defined\n\n\n\n\n\nStatische Karte aus GeoDataFrame\nUm aus GeoDataFrames Karten zu machen verwendet man ebenfalls die .plot() Methode. Um wirklich schöne Karten mit Python herzustellen braucht man viel Übung. Für eine schnelle Visualisierung reicht aber die .plot() Methode.\n\nimport geopandas as gpd\n\nzeckenstiche = gpd.read_file(\"data/zeckenstiche.gpkg\")\nwald = gpd.read_file(\"data/wald.gpkg\")\n\n\n---------------------------------------------------------------------------\nDataSourceError                           Traceback (most recent call last)\nCell In[5], line 3\n      1 import geopandas as gpd\n----&gt; 3 zeckenstiche = gpd.read_file(\"data/zeckenstiche.gpkg\")\n      4 wald = gpd.read_file(\"data/wald.gpkg\")\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/geopandas/io/file.py:294, in _read_file(filename, bbox, mask, columns, rows, engine, **kwargs)\n    291             from_bytes = True\n    293 if engine == \"pyogrio\":\n--&gt; 294     return _read_file_pyogrio(\n    295         filename, bbox=bbox, mask=mask, columns=columns, rows=rows, **kwargs\n    296     )\n    298 elif engine == \"fiona\":\n    299     if pd.api.types.is_file_like(filename):\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/geopandas/io/file.py:547, in _read_file_pyogrio(path_or_bytes, bbox, mask, rows, **kwargs)\n    538     warnings.warn(\n    539         \"The 'include_fields' and 'ignore_fields' keywords are deprecated, and \"\n    540         \"will be removed in a future release. You can use the 'columns' keyword \"\n   (...)\n    543         stacklevel=3,\n    544     )\n    545     kwargs[\"columns\"] = kwargs.pop(\"include_fields\")\n--&gt; 547 return pyogrio.read_dataframe(path_or_bytes, bbox=bbox, **kwargs)\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/geopandas.py:261, in read_dataframe(path_or_buffer, layer, encoding, columns, read_geometry, force_2d, skip_features, max_features, where, bbox, mask, fids, sql, sql_dialect, fid_as_index, use_arrow, on_invalid, arrow_to_pandas_kwargs, **kwargs)\n    256 if not use_arrow:\n    257     # For arrow, datetimes are read as is.\n    258     # For numpy IO, datetimes are read as string values to preserve timezone info\n    259     # as numpy does not directly support timezones.\n    260     kwargs[\"datetime_as_string\"] = True\n--&gt; 261 result = read_func(\n    262     path_or_buffer,\n    263     layer=layer,\n    264     encoding=encoding,\n    265     columns=columns,\n    266     read_geometry=read_geometry,\n    267     force_2d=gdal_force_2d,\n    268     skip_features=skip_features,\n    269     max_features=max_features,\n    270     where=where,\n    271     bbox=bbox,\n    272     mask=mask,\n    273     fids=fids,\n    274     sql=sql,\n    275     sql_dialect=sql_dialect,\n    276     return_fids=fid_as_index,\n    277     **kwargs,\n    278 )\n    280 if use_arrow:\n    281     meta, table = result\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/raw.py:196, in read(path_or_buffer, layer, encoding, columns, read_geometry, force_2d, skip_features, max_features, where, bbox, mask, fids, sql, sql_dialect, return_fids, datetime_as_string, **kwargs)\n     56 \"\"\"Read OGR data source into numpy arrays.\n     57 \n     58 IMPORTANT: non-linear geometry types (e.g., MultiSurface) are converted\n   (...)\n    191 \n    192 \"\"\"\n    194 dataset_kwargs = _preprocess_options_key_value(kwargs) if kwargs else {}\n--&gt; 196 return ogr_read(\n    197     get_vsi_path_or_buffer(path_or_buffer),\n    198     layer=layer,\n    199     encoding=encoding,\n    200     columns=columns,\n    201     read_geometry=read_geometry,\n    202     force_2d=force_2d,\n    203     skip_features=skip_features,\n    204     max_features=max_features or 0,\n    205     where=where,\n    206     bbox=bbox,\n    207     mask=_mask_to_wkb(mask),\n    208     fids=fids,\n    209     sql=sql,\n    210     sql_dialect=sql_dialect,\n    211     return_fids=return_fids,\n    212     dataset_kwargs=dataset_kwargs,\n    213     datetime_as_string=datetime_as_string,\n    214 )\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/_io.pyx:1239, in pyogrio._io.ogr_read()\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/_io.pyx:219, in pyogrio._io.ogr_open()\n\nDataSourceError: data/zeckenstiche.gpkg: No such file or directory\n\n\n\nEinfache Plots ohne anpassung:\n\nwald.plot()\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 wald.plot()\n\nNameError: name 'wald' is not defined\n\n\n\nAnpassung der Plot Grösse:\n\nwald.plot(figsize = (5,5))\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 wald.plot(figsize = (5,5))\n\nNameError: name 'wald' is not defined\n\n\n\nChoroplethenkarte Karte\n\nfrom matplotlib.colors import ListedColormap\n\nmy_cmap = ListedColormap([\"green\",\"lightgrey\"])\nwald.plot(column = \"Wald_text\", legend = True, cmap = my_cmap)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 4\n      1 from matplotlib.colors import ListedColormap\n      3 my_cmap = ListedColormap([\"green\",\"lightgrey\"])\n----&gt; 4 wald.plot(column = \"Wald_text\", legend = True, cmap = my_cmap)\n\nNameError: name 'wald' is not defined\n\n\n\nMehrere Layers:\n\nbase = wald.plot(column = \"Wald_text\", legend = True, cmap = my_cmap)\nzeckenstiche.plot(color = \"Red\", ax = base)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 base = wald.plot(column = \"Wald_text\", legend = True, cmap = my_cmap)\n      2 zeckenstiche.plot(color = \"Red\", ax = base)\n\nNameError: name 'wald' is not defined\n\n\n\n\n\nInteraktive Karten aus GeoDataFrame\nWeitere Informationen dazu findet ihr hier: https://geopandas.org/docs/user_guide/interactive_mapping.html\nVollautomatisch, ohne Anpassungen:\n\nzeckenstiche.explore()\n\nZeckenstiche Rot eingefärbt:\n\nzeckenstiche.explore(color = \"red\")\n\nZeckenstiche nach \"accuracy\" eingefärbt:\n\nzeckenstiche.explore(column = \"accuracy\")\n\nWald nach \"Wald_text\" eingefärbt (beachte, dass ich my_cmap weiter oben erstellt habe!):\n\nwald.explore(column = \"Wald_text\", cmap = my_cmap)\n\nZwei übereinander gelagerte Layers:\n\nbase = wald.explore(column = \"Wald_text\", cmap = my_cmap)\nzeckenstiche.explore(m = base, color = \"red\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 base = wald.explore(column = \"Wald_text\", cmap = my_cmap)\n      2 zeckenstiche.explore(m = base, color = \"red\")\n\nNameError: name 'wald' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/10_Anhang.html#sec-geoviz",
    "href": "C_Programmieren_3/10_Anhang.html#sec-geoviz",
    "title": "Anhang",
    "section": "Anhang 2: Geodaten visualisieren",
    "text": "Anhang 2: Geodaten visualisieren\nIn folgenden Beispielen zeigen wir noch ein paar einfache Wege, wie ihr die Zeckenstichdaten visualisieren könnt.\n\nimport pandas as pd\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport descartes\n\nwald = gpd.read_file(\"data/wald.gpkg\")\nzeckenstiche_full = pd.read_csv(\"data/zeckenstiche_full.csv\")\n\ngeom = gpd.points_from_xy(zeckenstiche_full['x'], zeckenstiche_full['y'])\n\nzeckenstiche_gpd = gpd.GeoDataFrame(\n    zeckenstiche_full,\n    geometry=geom,\n    crs = 2056)\n\n\n---------------------------------------------------------------------------\nDataSourceError                           Traceback (most recent call last)\nCell In[11], line 6\n      3 import matplotlib.pyplot as plt\n      4 import descartes\n----&gt; 6 wald = gpd.read_file(\"data/wald.gpkg\")\n      7 zeckenstiche_full = pd.read_csv(\"data/zeckenstiche_full.csv\")\n      9 geom = gpd.points_from_xy(zeckenstiche_full['x'], zeckenstiche_full['y'])\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/geopandas/io/file.py:294, in _read_file(filename, bbox, mask, columns, rows, engine, **kwargs)\n    291             from_bytes = True\n    293 if engine == \"pyogrio\":\n--&gt; 294     return _read_file_pyogrio(\n    295         filename, bbox=bbox, mask=mask, columns=columns, rows=rows, **kwargs\n    296     )\n    298 elif engine == \"fiona\":\n    299     if pd.api.types.is_file_like(filename):\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/geopandas/io/file.py:547, in _read_file_pyogrio(path_or_bytes, bbox, mask, rows, **kwargs)\n    538     warnings.warn(\n    539         \"The 'include_fields' and 'ignore_fields' keywords are deprecated, and \"\n    540         \"will be removed in a future release. You can use the 'columns' keyword \"\n   (...)\n    543         stacklevel=3,\n    544     )\n    545     kwargs[\"columns\"] = kwargs.pop(\"include_fields\")\n--&gt; 547 return pyogrio.read_dataframe(path_or_bytes, bbox=bbox, **kwargs)\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/geopandas.py:261, in read_dataframe(path_or_buffer, layer, encoding, columns, read_geometry, force_2d, skip_features, max_features, where, bbox, mask, fids, sql, sql_dialect, fid_as_index, use_arrow, on_invalid, arrow_to_pandas_kwargs, **kwargs)\n    256 if not use_arrow:\n    257     # For arrow, datetimes are read as is.\n    258     # For numpy IO, datetimes are read as string values to preserve timezone info\n    259     # as numpy does not directly support timezones.\n    260     kwargs[\"datetime_as_string\"] = True\n--&gt; 261 result = read_func(\n    262     path_or_buffer,\n    263     layer=layer,\n    264     encoding=encoding,\n    265     columns=columns,\n    266     read_geometry=read_geometry,\n    267     force_2d=gdal_force_2d,\n    268     skip_features=skip_features,\n    269     max_features=max_features,\n    270     where=where,\n    271     bbox=bbox,\n    272     mask=mask,\n    273     fids=fids,\n    274     sql=sql,\n    275     sql_dialect=sql_dialect,\n    276     return_fids=fid_as_index,\n    277     **kwargs,\n    278 )\n    280 if use_arrow:\n    281     meta, table = result\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/raw.py:196, in read(path_or_buffer, layer, encoding, columns, read_geometry, force_2d, skip_features, max_features, where, bbox, mask, fids, sql, sql_dialect, return_fids, datetime_as_string, **kwargs)\n     56 \"\"\"Read OGR data source into numpy arrays.\n     57 \n     58 IMPORTANT: non-linear geometry types (e.g., MultiSurface) are converted\n   (...)\n    191 \n    192 \"\"\"\n    194 dataset_kwargs = _preprocess_options_key_value(kwargs) if kwargs else {}\n--&gt; 196 return ogr_read(\n    197     get_vsi_path_or_buffer(path_or_buffer),\n    198     layer=layer,\n    199     encoding=encoding,\n    200     columns=columns,\n    201     read_geometry=read_geometry,\n    202     force_2d=force_2d,\n    203     skip_features=skip_features,\n    204     max_features=max_features or 0,\n    205     where=where,\n    206     bbox=bbox,\n    207     mask=_mask_to_wkb(mask),\n    208     fids=fids,\n    209     sql=sql,\n    210     sql_dialect=sql_dialect,\n    211     return_fids=return_fids,\n    212     dataset_kwargs=dataset_kwargs,\n    213     datetime_as_string=datetime_as_string,\n    214 )\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/_io.pyx:1239, in pyogrio._io.ogr_read()\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/_io.pyx:219, in pyogrio._io.ogr_open()\n\nDataSourceError: data/wald.gpkg: No such file or directory\n\n\n\n\nKernel Density Plot\nMit der Erweiterung seaborn lassen sich mit wenigen Zeilen Code eine Kernel Density rechnen und visualisieren. Siehe nachstehenden Code:\n\nimport seaborn as sns\n\nf, ax = plt.subplots(1, figsize=(6, 6))\nwald.boundary.plot(linewidth=0.1, ax=ax)\nzeckenstiche_gpd.plot(color='red', linewidth=0.1, ax=ax)\n\nsns.kdeplot(x = zeckenstiche_full.x, y= zeckenstiche_full.y,shade = False,n_levels = 10, cmap = \"viridis\", ax = ax)\n\nax.set_axis_off()\nplt.show()\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[12], line 1\n----&gt; 1 import seaborn as sns\n      3 f, ax = plt.subplots(1, figsize=(6, 6))\n      4 wald.boundary.plot(linewidth=0.1, ax=ax)\n\nModuleNotFoundError: No module named 'seaborn'\n\n\n\n\n\nHintergrundkarte\nMit der Erweiterung contextily kann man sehr schnell und einfach Hintergrundkarten in den Plot einbinden. Dafür muss das GeoDataFrame vorher aber in WGS84 Koordinaten (EPSG 3857) konvertiert werden (mit to_crs, s.u.).\n\nimport contextily as ctx\n\nf, ax = plt.subplots(1, figsize=(6, 6))\nzeckenstiche_gpd.to_crs(epsg = 3857).plot(ax = ax)\nctx.add_basemap(ax)\n\nax.set_axis_off()\nplt.show()\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 import contextily as ctx\n      3 f, ax = plt.subplots(1, figsize=(6, 6))\n      4 zeckenstiche_gpd.to_crs(epsg = 3857).plot(ax = ax)\n\nModuleNotFoundError: No module named 'contextily'\n\n\n\n\n\nKDE mit Hintergrundkarte\nKernel Denisty und Hintergrundkarte können auch kombiniert werden:\n\nlat = zeckenstiche_gpd.to_crs(epsg = 3857).geometry.x\nlng = zeckenstiche_gpd.to_crs(epsg = 3857).geometry.y\n\nf, ax = plt.subplots(1, figsize=(6, 6))\n\nsns.kdeplot(x = lat,y = lng,shade = False,n_levels = 25, cmap = \"viridis\", ax = ax)\nctx.add_basemap(ax)\n\nax.set_axis_off()\nplt.show()\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 lat = zeckenstiche_gpd.to_crs(epsg = 3857).geometry.x\n      2 lng = zeckenstiche_gpd.to_crs(epsg = 3857).geometry.y\n      4 f, ax = plt.subplots(1, figsize=(6, 6))\n\nNameError: name 'zeckenstiche_gpd' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/1_Netzwerkanalyse_I.html",
    "href": "D_Netzwerkanalyse_1/1_Netzwerkanalyse_I.html",
    "title": "Netzwerkanalyse I",
    "section": "",
    "text": "Die Lerneinheit vermittelt die Grundlagen bei der Verwendung von Netzwerk-Geodaten. Die Anwendungsfelder reichen von Streckenfindung und Reisezeitberechnungen zu Energienetzwerk-Systeme bis hin zu Gewässernetzen in der Hydrologie. Diese Lerneinheit vermittelt die dafür relevanten Grundlagen aus der Graphentheorie und knüpft dabei an die bekannten Grundlagen der Vektordatenmodellierung (Definitionen, Elemente von Graphen, Eigenschaften von Graphen, Bäume) an. Zudem werden im theoretischen Teil Netzwerkmasse, insbesondere Zentralitätsmasse nähergebracht. Der praktische Teil basiert auf der Einführung und Verwendung von QGIS als Alternative zu den ESRI-Produkten.\n\n\n\n\n\n\nHinweisÜbungsziele\n\n\n\n\nEinfache GIS-Operationen mit QGIS durchführen können (Clip, Reproject, Abfrage der Attributtabelle, Symbolisierung, Export als jpg)\nSchnittstelle zwischen QGIS und anderen GIS-Software am Beispiel GRASS kennenlernen\nErste Netzwerkoperationen mit QGIS/GRASS GIS durchführen\nNetzwerk-Zentralitätsmasse verstehen und für einfache Netzwerkdaten berechnen können",
    "crumbs": [
      "Netzwerkanalyse I"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html",
    "title": "Vorbereitung",
    "section": "",
    "text": "Datensätze\nDamit wir im ersten Teil von Netzwerkanalyse direkt loslegen können, solltet ihr euch vorgängig mit QGIS vertraut machen. Dafür haben wir ein paar Übungen zusammengestellt, die ihr als Vorbereitung auf Netzwerkanalyse I erledigen solltet.\nLaden Sie das File netzwerkanalyse.gpkg von Moodle herunter. Hier befinden sich alle Datensätze, die im Laufe des Blocks “Netzwerkanalyse” benötigt werden:",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#datensätze",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#datensätze",
    "title": "Vorbereitung",
    "section": "",
    "text": "Tabelle 51.1: Datensätze im File netzwerkanalyse.gpkg für den Block “Netzwerkanalyse”\n\n\n\n\n\n\n\n\n\n\nLayer\nKoord. System\nBeschreibung\n\n\n\n\nGemeinde_Waedenswil\nEPSG 2056\nDie Gemeindegrenze von Wädenswil. Dieser Datensatz basiert auf swissBOUNDARIES3D von Swisstopo.\n\n\nosm_highway\nEPSG 4326\nAlle “Highway” Linien aus dem OpenStreetmaps (Stand nach* Übung 5: OpenStreetMap Vektordaten herunterladen)\n\n\nosm_highway_prepared\nEPSG 2056\nAlle “Highway” Linien transformiert und neu projiziert (Output aus Übung 1.2: Daten clippen)\n\n\nshops_waedenswil\nEPSG 2056\nAlle Läden in Wädenswil, für Übung 4.2: Traveling Salesperson für mehr Standorte\n\n\nbuildings_waedenswil_polygons\nEPSG 2056\nAlle Gebäudestandorte (Polygon Daten) in Wädenswil, für Übung 4.3 (fakultativ, Guezli-Challenge): Traveling Salesperson für noch mehr Standorte\n\n\nabfallentsorgung_waedenswil\nEPSG 2056\nEntsorgungsstellen Wädenswil\n\n\nwaedenswil_centrality\nEPSG 2056\nZentralitätsmasse für Wädenswil (aus Übung 2.3: Zentralitätsmasse berechnen)\n\n\nHaltestellen_waedenswil\nEPSG 2056\nHaltestellen in Wädenswil",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-1-qgis-installieren",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-1-qgis-installieren",
    "title": "Vorbereitung",
    "section": "Übung 1: QGIS installieren",
    "text": "Übung 1: QGIS installieren\nAuf der QGIS Homepage qgis.org finden Sie die aktuellen QGIS Versionen für Windows, Linux, Mac und weitere Betriebssysteme in 32 und 64 bit. Laden Sie den passenden Standalone Installer des “Longterm release (most stable)” herunter (aktuell 3.34). Installieren Sie QGIS nach dem Download.\n\n\n\n\n\n\nWichtig\n\n\n\nWir empfehlen dringend, dass ihr QGIS auf Englisch umstellt:\nSettings → Options → General → User interface translation",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-2-tutorials-anschauen",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-2-tutorials-anschauen",
    "title": "Vorbereitung",
    "section": "Übung 2: Tutorials anschauen",
    "text": "Übung 2: Tutorials anschauen\nSchauen Sie sich danach zum Einstieg einzelne Videos vom Youtube Nutzer Marshal Mappers an. Schauen Sie die Videos bis Sie die grundlegendsten Arbeitsschritte von QGIS (Daten importieren, Werkzeuge finden, Karte zu pdf exportieren) verstanden haben. Erstellen Sie dann ein neues Projekt (Projekt→New) und speichern Sie dieses direkt ab (Projekt→Save As..).",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-3-daten-importieren",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-3-daten-importieren",
    "title": "Vorbereitung",
    "section": "Übung 3: Daten importieren",
    "text": "Übung 3: Daten importieren\nWährend Shapefiles im GIS-Unterricht bisher oft zur Speicherung von Vektordaten verwendet wurden, werden in QGIS vor allem Geopackage Dateien verwendet (.gpkg). QGIS kann Shapefiles durchaus lesen und schreiben, wir werden in den Übungen aber vor allem mit Geopackage Daten arbeiten. Geopackages sind eine alternative Methode, Vektordaten abzuspeichern. Sie beheben einige Defizite, die Shapefiles mit sich bringen. Siehe dazu auch die Website “Shapefiles must die”.\n\nNeues QGIS Projekt starten und Projektdatei speichern\nCRS auf EPSG 2056 setzen\nAus dem File netzwerkanalyse.gpgk den Layer Gemeinde_Waedenswil (siehe Tabelle 51.1) in QGIS importieren\nSymbologie folgendermassen ändern: Fläche transparent, Stadtgrenze schwarz",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#sec-ex-network-plugins",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#sec-ex-network-plugins",
    "title": "Vorbereitung",
    "section": "Übung 4: Plugin installieren",
    "text": "Übung 4: Plugin installieren\nQGIS wird von zahlreichen Einzelpersonen und Gruppen entwickelt. Aus diesem Grund ist die Software modular aufgebaut und nur ein Teil wird mit der Standard-Installation mitgeliefert. Für einige Funktionen müssen zusätzliche Erweiterungen (sogenannte “Plugins”) installiert werden. Installieren Sie das Plugin “QuickOSM”, um OpenStreetMap (OSM) Vektordaten rasch und einfach lokal abspeichern zu können.\n\nReiter Plugins→Manage and Install Plugins\nIm Suchfenster “QuickOSM” suchen\nPlugin anwählen und auf “install” klicken\n\nDie wichtigsten Metadaten zu allen Plugins werden auf plugins.qgis.org festgehalten. Dort findet man auch Links zur Projektseite, weiteren Dokumentation und ggf. Tutorials: Zu QuickOSM sind die Metadaten hier abrufbar: https://plugins.qgis.org/plugins/QuickOSM/",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#sec-ex-network-osmdownload",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#sec-ex-network-osmdownload",
    "title": "Vorbereitung",
    "section": "Übung 5: OpenStreetMap Vektordaten herunterladen",
    "text": "Übung 5: OpenStreetMap Vektordaten herunterladen\nMit dem neuen Plugin “QuickOSM” laden Sie nun den Strassendatensatz der Gemeinde Wädenswil herunter. Dies geschieht folgendermassen:\n\nRechtsklick auf den Layer Gemeinde_Waedenswil → Zoom to layer\nReiter Vektor → Quick OSM → Quick OSM\nWählen Sie bei der Option key “highway” und lassen value leer\nWählen Sie Option “Canvas Extent”\nKlicken Sie anschliessend auf “Run query”\n\nDas Query lädt nebst den Liniendaten auch noch Punkt- und Polygon-Daten herunter. Diese interessieren uns nicht und können entfernt werden (Rechtsklick→remove).",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-6-temporäre-datei-abspeichern",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-6-temporäre-datei-abspeichern",
    "title": "Vorbereitung",
    "section": "Übung 6: Temporäre Datei abspeichern",
    "text": "Übung 6: Temporäre Datei abspeichern\nOutputs werden in QGIS standardmässig in einem Temp-Folder abgelegt. Diese Dateien werden nach Beendigung von QGIS gelöscht. Um die Daten auch zu einem späteren Zeitpunkt verwenden zu können, müssen sie an einem geeigneten Ort abgespeichert werden. Führen Sie diesen Schritt mit den eben beschafften OSM Strassendaten (nur Linien) aus. Im gleichen Schritt können Sie alle unnötigen Spalten aus der grossen Attributtabelle löschen.\n\nRechtsklick auf den temporären Linien-Layer → Export → Save Features As…\nUnter “Select fields to export and their export options” nur Spalte highway auswählen\nFormat: Geopackage\nFilename: Geeigneter Speicherort1 aufsuchen und Datei abspeichern als “osm_highway.gpkg” (Erweiterung muss nochmals angegeben werden)\n\n\n\n\n\n\n\nHinweisMerken Sie sich:\n\n\n\n\nEs lohnt sich, vor jedem Projekt eine sinnvolle Ordnerstruktur aufzubauen\nNeben Shapefiles gibt es weitere (bessere?) Wege, wie Vektordaten abgespeichert werden können. Eine gute Variante ist Geopackage.\nQGIS ist mittlerweile ein mächtiges Werkzeug, welches für die Bearbeitung vieler klassischer GIS Fragestellungen geeignet ist.\nQGIS ist modular aufgebaut, wichtige Funktionen sind über Plugins verfügbar. Dadurch kommt QGIS nicht aus “einem Guss” daher.\nOutputs werden in temporären Dateien abgespeichert, die bei der Schliessung von QGIS gelöscht werden. Sollen Geodaten permanent verfügbar sein, müssen sie entsprechend explizit abgespeichert werden.",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#footnotes",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#footnotes",
    "title": "Vorbereitung",
    "section": "",
    "text": "Merken Sie sich den Speicherort, Sie werden das File in der kommenden Übung brauchen.↩︎",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/3_QGIS.html",
    "href": "D_Netzwerkanalyse_1/3_QGIS.html",
    "title": "Aufgabe 1: Operationen mit QGIS",
    "section": "",
    "text": "Übung 1.1: Daten transformieren\nStarten Sie QGIS, erstellen Sie ein neues QGIS Projekt und speichere dieses an einem geeigneten Ort (siehe Vorbereitungsübungen) ab. Weisen Sie dem Projekt das Koordinatensystem EPSG 2056 zu und importiere die Gemeindegrenze sowie die OSM Strassendaten aus der Vorbereitungsübung (siehe Tabelle 51.1).\nDie OSM Daten sind aktuell noch im Koordinatensystem WGS84 (EPSG 4326). Die Gemeindegrenze hingegen ist mit den neuen Schweizer Landeskoordinaten CH1903+ LV95 (EPSG 2056) abgespeichert. Wir wollen in unserer Analyse mit CH1903+ LV95 (EPSG 2056) arbeiten. Transformieren Sie dazu den Strassendatensatz in das Koordinatensystem CH1903+ LV95 (EPSG 2056). Nutzen Sie dazu das Tool Reproject Layer. Wichtig: Speichern Sie den transformierten Strassendatensatz in einer neuen Datei (siehe Abbildung 52.2)\nViele wichtige Tools lassen sich über die Menü Bar aufrufen (v.a. “Vector” und “Raster”). Die Tools lassen sich auch relativ rasch mit der Suchfunktion in “Processing Toolbox” finden.\nSpeichern Sie den neuen Strassendatensatz in einer neuen Datei, nicht als temporärer Layer. Normalerweise spielt dies keine Rolle, doch im Falle von “reproject” entsteht beim Speichern als temporärer Layer ein Fehler.",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>Aufgabe 1: Operationen mit QGIS</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/3_QGIS.html#sec-ex-network-transfrom",
    "href": "D_Netzwerkanalyse_1/3_QGIS.html#sec-ex-network-transfrom",
    "title": "Aufgabe 1: Operationen mit QGIS",
    "section": "",
    "text": "Abbildung 52.1\n\n\n\n\n\n\n\n\n\n\nAbbildung 52.2: Tool Reproject Layer",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>Aufgabe 1: Operationen mit QGIS</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/3_QGIS.html#sec-ex-clip",
    "href": "D_Netzwerkanalyse_1/3_QGIS.html#sec-ex-clip",
    "title": "Aufgabe 1: Operationen mit QGIS",
    "section": "Übung 1.2: Daten clippen",
    "text": "Übung 1.2: Daten clippen\nZoomen sie auf die Gemeindegrenze (Layers Panel → Rechtsklick auf Datensatz → Zoom to layer). Sie stellen fest, dass die Strassendaten über die Gemeindegrenze hinaus verlaufen. Wir möchten für die kommenden Übungen nur die Strassen, die innerhalb der Gemeinde Wädenswil liegen. Dazu müssen wir das Strassennetz mit der Gemeindegrenze verschneiden (“clip”). Führen Sie das gleichnamige Werkzeug mit dem Input-Layer “OSM_highway” und dem Clip-Layer Gemeinde_Waedenswil aus. Speichern Sie die Ausgabe in einer neuen Datei.\nEs gibt eine ganze Reihe Werkzeuge zum Begriff “clip”. Entscheiden Sie selbst, welches für diese Fragestellung geeignet ist.\n\n\n\n\n\n\nHinweis\n\n\n\n\nAchten Sie darauf, dass dem neuen (“clipped”) Datensatz das richtige Koordinatensystem zugewiesen wurde. Wenn nicht, gehe zu: Properties &gt; Source &gt; Assigned Coordinate Reference System (CRS), wähle EPSG:2056 - CH1903+ / LV95 und klicke auf Apply",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>Aufgabe 1: Operationen mit QGIS</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "",
    "text": "Übung 2.1: Topologie bereinigen\nDie mächtigsten (aber nicht die einzigen1) Netzwerkanalyse-Werkzeuge in QGIS stammen aus dem eigenständigen GIS “GRASS GIS”, welches bei der Installation von QGIS mitinstalliert wird. Diese können innerhalb von QGIS verwendet werden.\nDas OSM Strassennetz “osm_highway” ist topologisch nicht perfekt für unsere Zwecke vorbereitet. An Kreuzungen fehlen teilweise Knoten, welche ein “Abbiegen” auf der Kreuzung ermöglichen. Um diesen Umstand zu beheben, nutzen wir das Tool v.clean und führen damit die Operation “break” durch. Dadurch werden Linien an Kreuzungen unterbrochen. Diese Operation löst einige topologische Fehler, führt z.B. bei Brücken und Tunnels aber zu neuen Unstimmigkeiten, die Sie an dieser Stelle aber getrost ignorieren können.",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.1-topologie-bereinigen",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.1-topologie-bereinigen",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "",
    "text": "Werkzeug v.clean auswählen\nParameter:\n\nLayer to clean : Transformierter und geclippter OSM Strassendatensatz\nCleaning tool : break\nv.out.ogr output type: auto\ncleaned (output): Save to File…\n\nMit “Run” ausführen",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.2-losgelöste-getrennte-elemente-entfernen",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.2-losgelöste-getrennte-elemente-entfernen",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "Übung 2.2: Losgelöste (getrennte) Elemente entfernen",
    "text": "Übung 2.2: Losgelöste (getrennte) Elemente entfernen\nAufmerksamen Anwendern könnte nun auffallen, dass gewisse Bestandteile des Netzwerks nicht mit dem Hauptnetz verbunden sind. Diese getrennten Elemente können mit dem Werkzeug v.net.components identifiziert werden. Das Werkzeug prüft, welche Bestandteile des Netzwerkes miteinander verbunden sind und gruppiert diese mit Nummern. Diese Nummern werden in der Spalte “comp” abgespeichert.\nIm Idealfall sollte unser Netzwerk aus einer Gruppe bestehen; so wäre jeder Knotenpunkt mit jedem andern Knotenpunkt verbunden: Bei uns ist dies jedoch nicht der Fall. Damit wir in den nächsten Übungen mit einem sauberen Datensatz arbeiten können, bereinigen wir dieses Problem an dieser Stelle:\n\nFühren Sie das Werkzeug v.net.components aus\n\nType of components : “strong”\nV.out.ogr output type: auto\nNetwork_Components_Line: Save to File…\nNetwork_Components_Point: Save to File…\n\nDer neue Linien-Datensatz verfügt (wie oben beschrieben) über eine Spalte “comp”. Überprüfen Sie dies, indem Sie die Attributtabelle anschauen.\nFärben Sie die Linien nach der Spalte (“comp”) ein, sodass jede Gruppe eine Farbe erhält.\nErmitteln Sie die Nummer der Hauptkategorie (z.B. mit dem Werkzeug “Identify Features”)\nÖffnen Sie die Attributtabelle und machen sie eine “Selektion anhand einer Abfrage” (“Select Features using an expression” [1])\nSelektieren Sie die Hauptkategorie mittels einer korrekten Abfrage (z.B. comp = 99).\nUm die anderen Kategorien zu entfernen, haben Sie nun zwei Möglichkeiten:\n\nEine Editiersession starten [2], die Selektion invertieren [3] und die selektierten Daten löschen [4]. ODER\nSelektierte Daten (ohne Invertierung) in ein neues File exportieren mittels Rechtsklick auf den Layer → “Save as” → Häkchen bei “Save only selected features”\n\nSpeichern Sie den Layer anschliessend mit folgendem Namen ab: “osm_highway_prepared.gpkg”\n\n\n\n\n\n\n\nAbbildung 53.1",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#sec-ex-centrality-calculate",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#sec-ex-centrality-calculate",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "Übung 2.3: Zentralitätsmasse berechnen",
    "text": "Übung 2.3: Zentralitätsmasse berechnen\nNun kann mit der eigentlichen Netzwerkanalyse begonnen werden. Wir rechnen für unser bereinigtes Strassennetz verschiedene Zentralitätsmasse.\n\nv.net.centrality starten\nParameter\n\nInput vector line layer : Bereinigter Output aus letzter Übung\nv.out.ogr output type : auto\nNetwork Centrality: Save to File…\n\nMit “run” ausführen\nSpeichern Sie die resultierende Datei in ihrem Ordner ab (“waedenswil_centrality.gpkg”)",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.4-zentralitätsmasse-visualisieren",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.4-zentralitätsmasse-visualisieren",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "Übung 2.4: Zentralitätsmasse Visualisieren",
    "text": "Übung 2.4: Zentralitätsmasse Visualisieren\nVisualisieren Sie die Ausprägung “Closeness” der berechneten Zentralitätswerte über die Symbologie (Layer Properties → Style → Graduated). Wählen Sie eine geeignete Methode und passen Sie den Stil an, bis er Ihnen gefällt. Spielen Sie dabei mit der Klassifikationsmethode (Mode: Equal interval, Quantile, Natural Breaks..) sowie der Color ramp rum. Achten Sie darauf, dass Sie immer auf “Classify” klicken müssen, um Änderungen anzuwenden.",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.5-zentralitätsmasse-vergleichen",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.5-zentralitätsmasse-vergleichen",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "Übung 2.5: Zentralitätsmasse vergleichen",
    "text": "Übung 2.5: Zentralitätsmasse vergleichen\nInstallieren Sie das Plugin “QuickMapServices”, um eine OSM Hintergrundkarte einzubinden (e.g. Web → QuickMapServices → OSM → OSM Standard). Um direkt in QGIS die Zentralitätsmasse zu vergleichen, duplizieren sie den entsprechenden Layer noch zweimal (rechtsklick &gt; Duplicate) – so können Sie jede der Zentralitäten separat symbolisieren und vergleichen. Sie können auch für jedes der Zentralitätsmasse eine Karte exportieren via Project &gt; Import / Export Export Map to Image.\nVergleichen Sie die drei Zentralitätsmasse und setzen Sie sie in den Kontext der Theorie.",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#footnotes",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#footnotes",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "",
    "text": "Da QGIS wie bereits erwähnt von verschiedenen Personen und Gruppen entwickelt wird, gibt es auch Doppelspurigkeiten, die man so in einer kommerziellen Software wie ArcGIS weniger vorfindet. In dieser Hinsicht ist QGIS sehr ähnlich wie die Programmiersprachen R und Python.↩︎",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/1_Einleitung.html",
    "href": "D_Netzwerkanalyse_2/1_Einleitung.html",
    "title": "Netzwerkanalyse II",
    "section": "",
    "text": "HinweisÜbungsziele\n\n\n\n\nIn einem gegebenen Netzwerk kürzeste Pfade mit QGIS berechnen können\nWeitere GRASS GIS Werkezeuge innerhalb von QGIS ansteuern können\nVerschiedene QGIS / GRASS GIS Tools kennenlernen und deren Outputs interpretieren können\nEigene einfache Vektor-Datensätze erstellen können, resp. Punkte von Hand digitalisieren können\nAlternative, professionelle Routing Services kennenlernen und ausserhalb herkömmlicher Services (z.B. Google) nutzen",
    "crumbs": [
      "Netzwerkanalyse II"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/1_Shortest_Path.html",
    "href": "D_Netzwerkanalyse_2/1_Shortest_Path.html",
    "title": "Aufgabe 3: Kürzeste Pfade (shortest path)",
    "section": "",
    "text": "Übung 3.1: Projekt vorbereiten\nStarten Sie QGIS und beginnen Sie ein neues Projekt mit dem CRS CH1903+ LV95 (EPSG 2056). Lesen Sie den Datensatz “osm_highway_prepared.gpkg” von letzter Woche ein. Wer den Datensatz von letzter Woche nicht auffinden kann, findet die Datei in Tabelle 51.1. Prüfen Sie, ob das CRS richtig erkannt wurde (Rechtsklick → Properties → Reiter Source → Set source coordinate reference system → Hier sollte EPSG 2056 stehen).\nWir brauchen zudem eine Hintergrundkarte zur Orientierung. Blenden Sie mit dem Plugin “QuickMapServices” die Openstreetmap Hintergrundkarte ein (Web → QuickMapServices → OSM → OSM Standard) ein. Falls Sie diese Option nicht finden, müssen Sie das enstprechede Plugin “QuickMapServices” installieren (siehe dazu Übung 4: Plugin installieren).\nDie Hintergrundkarte dient lediglich zur Orientierung, die Farben lenken uns jedoch vom Netzwerk ab. Wechseln Sie deshalb den Darstellungsmodus auf Graustufen mittels Rechtklick auf den Layer “OSM Standard” → Properties → Symbology → Grayscale Auswahl: “By lightness”.",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>54</span>  <span class='chapter-title'>Aufgabe 3: Kürzeste Pfade (shortest path)</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/1_Shortest_Path.html#sec-ex-shortestpath",
    "href": "D_Netzwerkanalyse_2/1_Shortest_Path.html#sec-ex-shortestpath",
    "title": "Aufgabe 3: Kürzeste Pfade (shortest path)",
    "section": "Übung 3.2: Kürzester Pfad berechnen",
    "text": "Übung 3.2: Kürzester Pfad berechnen\nNun können wir mittels “Shortest path (point to point)” (aus dem Toolset “Network analyses” den kürzesten Pfad zwischen zwei Knotenpunkten auf dem Netzwerk berechnen. Starten sie das Tool und wählen sie als Input Datensatz (“Vector Layer representing network”) osm_highway_prepared aus.\nDie Start- und Endpunkte können Sie interaktiv in der Karte setzen. Klicken Sie dazu auf das Symbol neben den entsprechenden Feldern (“Start point” bzw. “End point”) und klicken Sie in der Karte an die gewünschten Stellen. Führen Sie das Tool mit “Run” aus.\nVisualisieren Sie nun den neuen Layer “Shortest Path” so, dass er gut ersichtlich ist.\nHinweis: Auch GRASS GIS bietet einen Shortest Path Algorithmus an (v.net.path). Dieser ist darauf ausgelegt, viele kürzeste Pfade für viele Punkte zu berechnen, und nimmt als Input deshalb ein Textfile.",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>54</span>  <span class='chapter-title'>Aufgabe 3: Kürzeste Pfade (shortest path)</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/1_Shortest_Path.html#übung-3.3-mit-ors-routing-vergleichen",
    "href": "D_Netzwerkanalyse_2/1_Shortest_Path.html#übung-3.3-mit-ors-routing-vergleichen",
    "title": "Aufgabe 3: Kürzeste Pfade (shortest path)",
    "section": "Übung 3.3: Mit ORS Routing vergleichen",
    "text": "Übung 3.3: Mit ORS Routing vergleichen\nNun wollen wir diese Route mit derjenigen eines professionellen Routing Services vergleichen. https://maps.openrouteservice.org/ bietet ihre Dienste bis zu einem bestimmten Kontingent kostenlos an. Installieren Sie das Plug-In “ORS Tools” um diesen Service zu nutzen.\nFühren Sie das Tool nach der Installation via Web → ORS Tools → ORS Tools aus. Gehen Sie zu Settings siehe Abbildung 54.2).\n\n\n\n\n\n\nAbbildung 54.2: Öffnen der Einstellungen im ORS Tool\n\n\n\nFügen Sie unter “API Key” den Schlüssel ein (siehe Abbildung 54.3). Den Schlüssel findet ihr auf Moodle. Über diesen Schlüssel wird sichergestellt, dass die Anzahl Abfragen pro Minute und Tag ein gewisses Maximum nicht überschreiten.\n\n\n\n\n\n\nAbbildung 54.3: Einfügen des API Keys\n\n\n\nGeben Sie Start und Endpunkt mit der Maus ein (Klick auf das +, siehe Abbildung 54.4) und orientieren sich dabei an dem Layer “Shortest_Path” (aus der vorherigen Übung). Die Punkte setzen Sie mit einem Linksklick, den letzen Punkt setzen Sie mit einem Doppelklick.\n\n\n\n\n\n\nAbbildung 54.4: Beachten Sie, dass Sie mit + eine ganze Route setzen müssen und nicht einzelne Punkte.\n\n\n\nAllenfalls verschwindet das “ORS Tools” Fenster, sie können es aber über die Toolbar (siehe Abbildung 54.5) wieder aufrufen.\n\n\n\n\n\n\nAbbildung 54.5: ORS Routing\n\n\n\nMit einem Klick auf dieses Symbol erscheint das ORS Routing wieder.\nFühren Sie die Berechnung mit “Apply” aus und vergleichen Sie den resultierenden Pfad mit dem “Shortest Path” aus Übung 3.2: Kürzester Pfad berechnen. Führen Sie die gleiche Berechnung mit verschiedenen Einstellungen durch (kürzeste Route, schnellste Route, Fahrrad, zu Fuss). Vergleichen Sie die unterschiedlichen Routen mit unserer eigenen Berechnung und visualisieren Sie diese in einer Karte.\nBerechnen Sie nun mit OSM Routing den kürzesten Pfad zwischen dem Campus Grüental und dem Campus Reidbach, auch wieder je einmal mit der Verkehrsmodalität Auto, Fahrrad und Fussweg. Vergleichen Sie die drei Resultate.\n\n\n\n\n\n\nHinweis\n\n\n\nDas ORS Tools Plugin bietet keine Möglichkeit, die blauen Linien zu entfernen, die die ausgewählten Punkte auf der Karte verbinden (https://github.com/GIScience/orstools-qgis-plugin/issues/120). Diese Linien sind temporär, d.h. sie werden beim nächsten Öffnen des QGIS-Projekts wieder verschwinden.",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>54</span>  <span class='chapter-title'>Aufgabe 3: Kürzeste Pfade (shortest path)</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html",
    "href": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html",
    "title": "Aufgabe 4: Traveling Salesperson",
    "section": "",
    "text": "Übung 4.1: Traveling Salesperson für Campus Standorte\nDas Problem des Handlungsreisenden (engl. Traveling Salesperson Problem) ist ein kombinatorisches Optimierungsproblem, in dem die Aufgabe darin besteht, eine Reihenfolge für den Besuch mehrerer Orte so zu wählen, dass keine Station ausser der ersten mehr als einmal besucht wird, die gesamte Reisestrecke des Handlungsreisenden möglichst kurz und die erste Station gleich wie letzten Station ist.\nAngenommen Sie sind ein Kurrierdienst und müssen ausgehend von der Halbinsel Au aus alle Campus-Standorte der ZHAW Wädenswil besuchen. Sie wollen die Route so optimieren, dass Sie den kürzeste Weg zurücklegen. Dafür verwenden Sie das gleichnamige Tool (v.net.salesmen), um genau dieses Problem zu lösen.",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Aufgabe 4: Traveling Salesperson</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html#übung-4.1-traveling-salesperson-für-campus-standorte",
    "href": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html#übung-4.1-traveling-salesperson-für-campus-standorte",
    "title": "Aufgabe 4: Traveling Salesperson",
    "section": "",
    "text": "Erstellen Sie dazu als erstes eine neue Geopackage Datei (Layer→Create Layer→New Geopackage Layer) um die Campus Standorte zu erfassen.\n\nMit dem Feld “Database” ist der Pfad inkl. Dateiname der zu erstellenden Datei gemeint. Wählen Sie hier an einem geeigneten Speicherort den Dateiname “campus_waedenswil.gpkg”\n“Table name” ist der Name des Layers innerhalb der Geopackage Datei (im Gegensatz zu einem Shapefile können innerhalb eines Geopackage mehrere Layers von unterschiedlichen Datentypen koexistieren)\n\nWählen Sie bei “Geometry Type” “Point” aus und bei CRS EPSG 2056\nFügen Sie eine Spalte in der Attributtabelle hinzu indem Sie unter “New field”→“Name” den Wert “Standort_name” eingeben (Hier wollen wir “Grüental”, “Reidbach”.. erfassen) Wählen Sie einen geeigneten Datentyp sowie eine geeignete Maximallänge\nBestätigen Sie mittels “Add field to list”\nErstellen Sie das Geopackage mit “OK”\n\n\nStarten Sie mit einem Klick auf den Stift die Editiersession und fügen Sie mit dem “Add Feature” Werkzeug Features hinzu. Digitalisieren Sie so die Campus Standorte (Grüental, Reidbach, Seifenstreuli, Schloss) sowie den Ausgangspunkt (Halbinsel Au). Wählen Sie pro Standort einen für Sie geeigneten Punkt, möglichst auf dem OSM Strassennetz.\nSpeichern Sie die erfassten Punkte mit einem Klick auf “Save Edits”.\nStarten Sie nun das Tool v.net.salesman (über die Processing Toolbox) und wählen Sie als Input Layer den OSM Strassendatensatz und als “Center Point Layer” die eben digitalisierten Standorte.\nv.out.ogr output type: auto.\nBetrachten Sie die Outputdaten.",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Aufgabe 4: Traveling Salesperson</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html#sec-ex-network-traveling-shops",
    "href": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html#sec-ex-network-traveling-shops",
    "title": "Aufgabe 4: Traveling Salesperson",
    "section": "Übung 4.2: Traveling Salesperson für mehr Standorte",
    "text": "Übung 4.2: Traveling Salesperson für mehr Standorte\nDer Traveling-Salesperson-Pfad für fünf Punkte zu berechnen ist relativ trivial und könnte “von Hand” gerechnet werden. Anspruchsvoller wird es jedoch, wenn sich die Anzahl der Standorte erhöht. Nehmen wir an, Sie wollen eine Einkaufstour durch alle Läden in Wädenswil machen: Nutzen Sie die OSM Daten und v.net.salesman um eine sinnvolle Route zu berechnen.\n\nOSM Daten der Läden laden: Vector→QuickOSM→QuickOSM\nkey “shop”→Run query sowie Gebiet wählen (siehe dazu Übung 5: OpenStreetMap Vektordaten herunterladen)\nPunkt-Daten der Shops in CRS 2056 konvertieren (reproject, siehe Übung 1.1: Daten transformieren). Clippen ist fakultativ (nicht erreichbare Knotenpunkte werden schlicht ignoriert)\nv.net.salesman mit diesen Standorten durchführen",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Aufgabe 4: Traveling Salesperson</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html#sec-ex-network-traveling-buildings",
    "href": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html#sec-ex-network-traveling-buildings",
    "title": "Aufgabe 4: Traveling Salesperson",
    "section": "Übung 4.3 (fakultativ, Guezli-Challenge): Traveling Salesperson für noch mehr Standorte",
    "text": "Übung 4.3 (fakultativ, Guezli-Challenge): Traveling Salesperson für noch mehr Standorte\nUm unsere Rechenmaschine richtig herauszufordern, können wir den Traveling Salesperson Pfad für alle Gebäudestandorte in Wädenswil berechnen. Nutzen Sie hierzu QuickOSM um “building” herunterzuladen. Reprojizieren Sie die Polygon-Daten in CRS 2056 und konvertieren Sie diese in Punkte, indem Sie das Centroid pro Polygon berechnen (Tool “Polygon Centroids”). Berechnen Sie anschliessend den Traveling Salesperson. Ermitteln Sie die Gesamtdistanz dieses Pfades, indem Sie mit dem Field Calculator die Länge pro Segment rechnen (length) und anschliessend die Summe aller Längen ermitteln (View→Statistical Summary). Wer zuerst die korrekte Distanz in den Chat schreibt, wird mit Ruhm und Ehre belohnt und zur/zum “AGI Studentin/Studenten des Tages” erkoren!\n\nFür viele klassische Fragestellungen (z.B. shortest path, traveling salesmen) bietet QGIS / GRASS einen passenden Algorithmus\nDie Tools werden teilweise sehr unterschiedlich angesprochen (shortest path braucht Textfiles, Traveling salesmen braucht Punkt-Features) und liefern unterschiedliche Outputs",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Aufgabe 4: Traveling Salesperson</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/1_Einleitung.html",
    "href": "D_Netzwerkanalyse_3/1_Einleitung.html",
    "title": "Netzwerkanalyse III",
    "section": "",
    "text": "Angenommen Sie sind auf Wohnungssuche in Wädenswil. Dabei gilt es nebst dem Budget viele wichtige raumgebundene Variablen zu berücksichtigen, dazu verwenden Sie natürlich QGIS. Sie wollen drei Kriterien untersuchen:\n\nLaufdistanz zur nächsten Entsorgungsstelle\nErschliessung an die öffentlichen Verkehrsmittel (unter Berücksichtigung des Fahrplans)\nDistanz zur Durchfahrtsstrasse\n\nWir werden für jeden dieser drei Kriterien einen Rasterdatensatz kreieren, den wir zum Schluss miteinander verrechnen können. So finden wir den optimalen Standort unter der Berücksichtigung aller drei Kriterien. Starten Sie dazu QGIS und laden Sie folgende Daten in das Projekt:\n\nStrassennetz Wädenswil (“osm_highway_prepared.gpkg”, siehe Tabelle 51.1)\nEntsorgungsstellen Wädenswil (“abfallentsorgung_waedenswil.gpkg”, siehe Tabelle 51.1)\nGemeindegrenze Wädenswil (“Gemeinde_Waedenswil.gpkg”, siehe Tabelle 51.1)\nOptional: OSM Hintergrundkarte grau eingefärbt (siehe Übung 3.1: Projekt vorbereiten)\n\n\n\n\n\n\n\nHinweisÜbungsziele\n\n\n\n\nSie sind in der Lage, einfache Reisezeitberechnungen in QGIS selber durchzuführen.\nSie erweitern Ihr Skillset zur Umwandlung von verschiedenen Geodatentypen (Vektor zu Raster, Raster zu Vektor, Linien zu Punkte, usw.)\nSie können eine einfache Multi-Kriterien-Analyse (MCA) mit Raster-Daten in QGIS selbständig durchführen.\nSie können einfache Map Overlay-Operationen in QGIS selber ausführen.",
    "crumbs": [
      "Netzwerkanalyse III"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html",
    "href": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html",
    "title": "Aufgabe 5: Entsorgungsstelle",
    "section": "",
    "text": "Übung 5.1: Linien in Segmente unterteilen\nDa sie gerne hopfenhaltige Getränke in Dosen und Glasflaschen konsumieren, ist Ihnen bei der Standortwahl die Distanz zur nächsten Entsorgungsstelle sehr wichtig. Je näher die Wohnung an einer solchen Entsorgungsstelle wäre, desto weniger weit müssten Sie das Recycling Material mit Ihrem Wägelchen durch die Gegend fahren. Wir berechnen deshalb die Isochronen Linien zu den Entsorgungsstellen auf dem Strassennetz.\nVisualisieren Sie das Resultat in dem Sie die Symbolisierung des neu entstanden Linienlayers entsprechend anpassen (Spalte “cat” einfärben). Sind das nun bereits Isolinien?",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>Aufgabe 5: Entsorgungsstelle</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#übung-5.1-linien-in-segmente-unterteilen",
    "href": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#übung-5.1-linien-in-segmente-unterteilen",
    "title": "Aufgabe 5: Entsorgungsstelle",
    "section": "",
    "text": "Starten Sie das Tool v.net.iso um die Isochronen-Linien auf dem Strassennetz zu berechnen.\nWählen Sie als Input Vector Line das Strassennetz\nAls “Center Points layer” wählen Sie die Entsorgungsstellen\nIm Feld “Cost for Isolines” können Sie die Schwellenwerte festlegen, bei denen die Isochronenlinien gezogen werden sollen. Die Einheit entspricht den “Map units” (Meter) und werden kommagetrennt eingegeben. Um den vollen Effekt des Tools auszukosten verwenden wir eine grosse Anzahl von Schwellenwerten (z.B. alle 200m von 0 bis 3 km):\n200, 400, 600, 800, 1000, 1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600, 2800, 3000\nWählen Sie wie immer den v.out.ogr output type: “auto”\nFühren Sie das Werkzeug anschliessend mit “Run” aus.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>Aufgabe 5: Entsorgungsstelle</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#übung-5.2-linien-in-punkte-umwandeln",
    "href": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#übung-5.2-linien-in-punkte-umwandeln",
    "title": "Aufgabe 5: Entsorgungsstelle",
    "section": "Übung 5.2: Linien in Punkte Umwandeln",
    "text": "Übung 5.2: Linien in Punkte Umwandeln\nUm aus den Linien eine Oberfläche zu erhalten müssen wir die Kategorien aus dem Output von v.net.iso interpolieren. Dies funktioniert besser mit Punkten als Linien. In einem ersten Schritt müssen wir also den Output aus v.net.iso in Punkte umwandeln. Verwenden Sie hierfür das Werkzeug “Convert Line/Polygon Vertices to Points” (SAGA). Belassen sie das Häkchen bei “Insert additional Points” und setzten Sie die Distanz (“Insertion Distance”) auf 100 Meter. Führen Sie das Werkzeug mit “run” aus.\n\n\n\n\n\n\nHinweis\n\n\n\nIn einigen Fällen kann es sein, dass SAGA von QGIS nicht erkannt wird, obwohl es auf dem Computer installiert ist. Damit SAGA in QGIS trotzdem benutzt werden kann, muss einmalig folgende Schritte ausgeführt werden.\n\nInstallieren Sie in QGIS das Plugin “Processing Saga NextGen Provider”.\nGehen Sie in QGIS zu Settings &gt; Options &gt; Processing &gt; Providers\nUnter SAGA folder geben Sie den Pfad an, wo SAGA auf Ihrem Computer installiert ist. Dieser Pfad sollte in etwa so aussehen: C:\\Program Files\\QGIS 3.34.10\\apps\\saga",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>Aufgabe 5: Entsorgungsstelle</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#sec-ex-interpolate-points",
    "href": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#sec-ex-interpolate-points",
    "title": "Aufgabe 5: Entsorgungsstelle",
    "section": "Übung 5.3: Punkte interpolieren",
    "text": "Übung 5.3: Punkte interpolieren\nNun haben wir Punkte, die mit einer Interpolation in eine Oberfläche überführt werden können. Verwenden Sie dazu das Tool “Inverse distance weighted” (SAGA). Überlegen sie, was Sie interpolieren möchten und legen sie das entsprechende Feld in der Option “Attribute” fest. Zusätzlich können Sie folgende Parameter wählen:\n\nCellsize: 25\nSearch Range: [0] local\nMaximum Search Distance: 500\nWeighting Function: [1] Inverse Distance to a power\n\nClippen sie den Output anschliessen auf die Gemeindegrenze mit dem Werkzeug “Clip Raster by mask layer”. Speichern Sie den geclippten Layer mit dem Namen abfall_raster.tif in ihrem Projektordner.\nUm den Datensatz zu visualisieren können sie im Reiter “Symbology” der Layereigenschaften den Rendertype “Singleband Pseudocolor” auswählen. Wählen Sie einen geeigneten Farbverlauf und klicken sie auf “classify” und anschliessend auf “ok”.\n\n\n\n\n\n\nHinweis\n\n\n\nGruppieren Sie alle Layers im Zusammenhang mit den Entsorungsstellen mittels Selektion &gt; Rechtsklick &gt; Group selected um den Überblick zu behalten.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>Aufgabe 5: Entsorgungsstelle</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#übung-5.4-isolinien-berechnen",
    "href": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#übung-5.4-isolinien-berechnen",
    "title": "Aufgabe 5: Entsorgungsstelle",
    "section": "Übung 5.4: Isolinien berechnen",
    "text": "Übung 5.4: Isolinien berechnen\nDieser nächste Schritt dient nur zu Illustrationszwecken: Wir möchten aus der generierten Oberfläche Isolinien berechnen. Nutzen sie hierfür das Tool Raster→Extraktion→Contour…. Spielen sie mit verschiedenen Intervallen (Interval between..) rum bis Ihnen eine Darstellung gefällt. Überlagern Sie den interpolierten Raster, die Isolinien sowie die Entsorgungsstellen und freuen sie sich ab diesem Ergebnis!\n\n\n\n\n\n\nAbbildung 56.1: Isolinien berechnen",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>Aufgabe 5: Entsorgungsstelle</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html",
    "href": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html",
    "title": "Aufgabe 6: ÖV-Güteklassen",
    "section": "",
    "text": "Übung 6.1: Datensatz clippen und betrachten\nAls weiteres Kriterium wollen Sie eine gute Erschliessung mit dem öffentlichen Verkehr. Dabei geht um den ÖV-Anschluss unter Berücksichtigung des elektronischen Fahrplans. Dafür hat das ARE einen Datensatz herausgeben, den Sie hier auffinden können: https://s.geo.admin.ch/7e80a8bd28\nLaden Sie den Datensatz “ÖV-Güteklassen ARE” herunter und importieren Sie ihn in Ihr Projekt.\nClippen Sie den Datensatz mit der Gemeindegrenze von Wädenswil. Symbolisieren Sie den Datensatz anhand des Feldes “KLASSE” und betrachten Sie anschliessend die Attributtabelle.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>Aufgabe 6: ÖV-Güteklassen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html#übung-6.1-datensatz-clippen-und-betrachten",
    "href": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html#übung-6.1-datensatz-clippen-und-betrachten",
    "title": "Aufgabe 6: ÖV-Güteklassen",
    "section": "",
    "text": "TippTipp zum Herunterladen!\n\n\n\n\n\n\nÖV-Güteklassen",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>Aufgabe 6: ÖV-Güteklassen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html#übung-6.2-buchstaben-in-nummerische-kategorien-überführen",
    "href": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html#übung-6.2-buchstaben-in-nummerische-kategorien-überführen",
    "title": "Aufgabe 6: ÖV-Güteklassen",
    "section": "Übung 6.2: Buchstaben in nummerische Kategorien überführen",
    "text": "Übung 6.2: Buchstaben in nummerische Kategorien überführen\nDa es sich bei den Klassen um Buchstaben handelt, können wir sie für unsere Analyse in dieser Form nicht verwenden. Wir müssen die Buchstaben noch in Zahlen konvertieren (A zu 1, B zu 2 usw.). Verwenden Sie hierfür den Field Calculator der Attributtabelle. Versuchen Sie die Konversion Buchstaben in Zahlen mit einer if() Funktion um zu setzen. Falls Sie nicht weiter kommen, finden Sie weiter unten einen Lösungsvorschlag.\n\n\n\n\n\n\nTippHinweise\n\n\n\n\nBevor Sie die Funktion anwenden können müssen Sie noch den “Output field name” definieren.\nSobald sie den Field Calculator ausführen wechselt QGIS in den Editiermodus. Änderungen werden nur gespeichert, wenn die Editiersession beendet wird.\nWenn sie im mittleren Bereich auf unter “Fields and Values” auf ein Feld klicken haben sie rechts die Möglichkeit, die Werte dieser Felder zu betrachten und ebenfalls mit Doppelklick in ihre Formel zu übernehmen.\n\n\n\n\n\n\n\nAbbildung 57.1: Field Calculator\n\n\n\nZur Erinnerung: Der Field Calculator besteht aus drei Bereichen: Im mittleren Bereich können Sie Funktionen sowie Felder der Attributtabelle suchen und mittels einfachem anklicken Hilfestellung erhalten (rechts). Mittels Doppelklick wird die Funktion oder die Feldbezeichnung in den “Function Editor” (links) übertragen. Hier wird die eigentliche Funktion zusammengebaut die ausgeführt werden soll.\n\n\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nif(\"KLASSE\" = 'A' ,1,\n  if(\"KLASSE\" = 'B' ,2,\n    if(\"KLASSE\" = 'C' ,3,\n      if(\"KLASSE\" = 'D' ,4,0)\n    )\n  )\n)",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>Aufgabe 6: ÖV-Güteklassen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html#sec-ex-polygon-to-raster",
    "href": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html#sec-ex-polygon-to-raster",
    "title": "Aufgabe 6: ÖV-Güteklassen",
    "section": "Übung 6.3: Polygon in Raster konvertieren",
    "text": "Übung 6.3: Polygon in Raster konvertieren\nKonvertieren Sie das Polygon nun in ein Raster mit dem Werkzeug “Rasterize (Vector To Raster)”. Führen Sie das Tool mit den folgenden Einstellungen aus:\n\nField to use for a burn-in value: KLASSE (numerisch)\nOutput raster size units: Georeferenced Units\nWidth/Horizontal resolution: 25\nHeight/Vertical resolution: 25\n\n\nBeachten Sie, dass nun alle Bereiche in Wädenswil, die keiner Kategorie zugewiesen waren, nun keinen Wert erhalten haben. Für unsere Abstufung bräuchten wir hier aber den Wert “5” (1 – 4 haben wir bereits zugewiesen). Benutzen Sie das Tool “r.null”, um alle Null Werte in 5 zu konvertieren (“the value to replace the null value by”).\nClippen sie den Output anschliessen mit dem Werkezeug “Clip raster by mask layer”. Aus bisher unerklärlichen Gründen werden nach diesem Schritt 0-Werte erzeugt (alle Bereiche innerhalb des Raster-Extent aber ausserhalb des Polygons). Diese sollten aber NULL sein, nicht 0. Führen Sie deshalb das Tool “r.null” nochmals aus und setzen Sie bei “List of cell values to be set to NULL” den Wert 0 ein.\nSpeichern Sie den Output mit dem Namen oev_raster.tif in ihrem Projektordner und gruppieren Sie alle Layers im Zusammenhang mit den ÖV-Güteklassen.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>Aufgabe 6: ÖV-Güteklassen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/4_Zentralitaetsmasse.html",
    "href": "D_Netzwerkanalyse_3/4_Zentralitaetsmasse.html",
    "title": "Aufgabe 7: Zentralitätsmasse",
    "section": "",
    "text": "Übung 7.1: Zentralitätsmasse betrachten und auswählen\nDa Sie aber auf keinen Fall an einer Durchfahrtsstrasse wohnen möchten, müssen Sie dies in der Wohnungssuche ebenfalls berücksichtigen. Laden Sie deshalb den Datensatz “waedenswil_centrality.gpkg” aus Übung 2.3: Zentralitätsmasse berechnen. Falls Sie diesen nicht mehr haben, können Sie die Zentralitätsmasse neu berechnen (v.net sowie v.net.centrality) oder Sie verwenden den Datensatz “waedenswil_centrality.gpkg” in Tabelle 51.1. Prüfen Sie anhand der Symbolisierung, welches Mass “Durchfahrtsstrassen” am besten abbildet.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>58</span>  <span class='chapter-title'>Aufgabe 7: Zentralitätsmasse</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/4_Zentralitaetsmasse.html#übung-7.2-zentralitätsmasse-in-fläche-überführen",
    "href": "D_Netzwerkanalyse_3/4_Zentralitaetsmasse.html#übung-7.2-zentralitätsmasse-in-fläche-überführen",
    "title": "Aufgabe 7: Zentralitätsmasse",
    "section": "Übung 7.2: Zentralitätsmasse in Fläche überführen",
    "text": "Übung 7.2: Zentralitätsmasse in Fläche überführen\nDas gewählte Zentralitätsmass können wir nun ebenfalls mit dem Tool “Inverse distance weighted” (SAGA) in eine Oberfläche überführen. Führen sie das Tool analog Übung 5.3: Punkte interpolieren, mit dem gewählten Zenralitätsmass aus. Sie können die Parameter des Tools nach eigenem Gutdünken auch anpassen (wir empfehlen auf jedenfall die gleiche Output Cellsize von 25m zu verwenden um im Anschluss die Flächen miteinander verrechnen zu können).\nClippen sie anschliessend den Output mit dem Werkezeug “Clip raster by Mask Layer” (GDAL). Speichern Sie den Output unter centrality_raster.tif in ihrem Projektordner und gruppieren Sie alle Layers im Zusammenhang mit den Zentralitätsmassen.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>58</span>  <span class='chapter-title'>Aufgabe 7: Zentralitätsmasse</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/5_Flaechen_verrechnen.html",
    "href": "D_Netzwerkanalyse_3/5_Flaechen_verrechnen.html",
    "title": "Aufgabe 8: Flächen verrechnen",
    "section": "",
    "text": "Übung 8.1: Rasterdatensätze skalieren\nIn dieser Übung verschneiden wir die Informationen aus Entsorgungsstellen (abfall_raster.tif), ÖV-Güteklassen (oev_raster.tif), und Zentralitätsmass (centrality_raster.tif), die wir in den vorherigen Übungen berechnet und in Raster überführt haben. Durch die Verschneidung können wir den optimalen Wohnort eruieren. Diese Methode ist auch als Multikriterienevaluation bekannt und kennt ihr bereits vom GIS “Basic” Modul. In einem ersten Schritt müssen wir alle drei Rasterdatensätze auf eine einheitliche Skala (z.B. 0 – 100) bringen um sie anschliessend miteinander verrechnen zu können. Dafür brauchen wir die Minimum- und Maximumwerte der drei Raster Datensätzen oev_raster.tif, centrality_raster.tif, abfall_raster.tif. Gehen Sie dafür in die Properties→Information von jedem Layer und notieren Sie sich die minimalen und maximalen Zellenwerte.\nÖffnen Sie anschliessend das Tool Rescale Raster und skalieren Sie jeden der drei Rasterdatensätze jeweils so, dass Sie Werte von 0 bis 100 erhalten. Geben Sie dabei bei “New minimum value” 0 und bei “New maximum value” 100 ein.\nSpeichern Sie die Ergebnisse unter folgenden Namen ab: oev_scaled.tif, abfall_scaled.tif, centrality_scaled.tif.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>59</span>  <span class='chapter-title'>Aufgabe 8: Flächen verrechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/5_Flaechen_verrechnen.html#übung-8.2-zusammenführen-mit-raster-calculator",
    "href": "D_Netzwerkanalyse_3/5_Flaechen_verrechnen.html#übung-8.2-zusammenführen-mit-raster-calculator",
    "title": "Aufgabe 8: Flächen verrechnen",
    "section": "Übung 8.2: Zusammenführen mit Raster Calculator",
    "text": "Übung 8.2: Zusammenführen mit Raster Calculator\nNutzen Sie nun den Raster Calculator (Raster→Raster Calculator) um die drei Rasterdatensätze miteinander zu verrechnen.\n\nDie einfachste Variante ist die Berechnung des Mittelwertes der drei Rasterdatensätze. Dafür muss man alle drei summieren und durch drei dividieren:\n\\(raster_{neu}\\) = \\(\\frac{oev_{scaled}+abfall_{scaled}+centrality_{scaled}}{3}\\)\nOptional kann man auch die drei Rasterdatensätze unterschiedlich gewichten, wie beispielweise nachstehende Berechnung zeigt. Beachten Sie, dass in diesem Fall nicht mehr durch 3, sondern durch die Summe der Gewichte dividiert wird. Visualisieren und interpretieren Sie anschliessend das Resultat.\n\\(raster_{neu}\\) = \\(\\frac{oev_{scaled}\\times1+abfall_{scaled}\\times10+centrality_{scaled}\\times5}{16}\\)\nZum Abschluss clippen Sie den Output mit dem Werkezeug Clip raster by Mask Layer (GDAL) auf die Gemeindegrenze von Wädenswil. Speichern Sie den Output unter final_result.tif in ihrem Projektordner ab. Passen Sie die Symbolisierung entsprechend an.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>59</span>  <span class='chapter-title'>Aufgabe 8: Flächen verrechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/6_Leistungsnachweis.html",
    "href": "D_Netzwerkanalyse_3/6_Leistungsnachweis.html",
    "title": "Leistungsnachweis",
    "section": "",
    "text": "Um den Leistungsnachweis für Netzwerkanalyse zu erbringen, müsst ihr die Übungen aus Aufgabe 5: Entsorgungsstelle, Aufgabe 6: ÖV-Güteklassen, Aufgabe 7: Zentralitätsmasse und Aufgabe 8: Flächen verrechnen, ausführen und dokumentieren (maximal zwei A4-Seiten).\n\nAbgeben müsst Ihr ein PDF Dokument mit Eurem Lösungsansatz der Multikriterien-Analyse (Aufgabe 8: Flächen verrechnen) inkl. einer kurzen Beschreibung (ca. 400 - 600 Wörter), wie Ihr hier vorgegangen seid.\nBeschreibt vor allem auch, was für ein Zentralitätsmass Ihr für die Teilfrage “Durchfahrtsstrasse” gewählt habt. Begründet Eure Wahl durch einen konzeptionellen Vergleich mit den beiden anderen Zentralitätsmassen.\nFür den Leistungsnachweis erwarten wir, dass Ihr die Kriterien (ÖV, Abfall, Durchfahrtsstrasse) unterschiedlich gewichtet und die Wahl der Gewichte erklärt.\nAchtet darauf, dass Eure Karte die nötigen Elemente enthält (Datenherkunft, Datum, Legende usw.).\nAbgabe erfolgt via Moodle",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>60</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/1_Einleitung.html",
    "href": "E_WebGIS_1/1_Einleitung.html",
    "title": "WebGIS I",
    "section": "",
    "text": "HinweisÜbungsziele\n\n\n\n\nDu bist in der Lage auf dem ArcGIS Online Organisationskonto Deine Inhalte zu organisieren und die Freigabeeigenschaften von Inhalten zu ändern.\nDu kannst in ArcGIS Pro eine Karte vorbereiten, eine Zeitanimation aktivieren und ArcGIS Pro Karten auf einem ArcGIS Online Organisationskonto als Web Maps veröffentlichen.\nDu kannst eine Web Map zielgerichtet gestalten und basierend auf bestehenden Web Maps neue Web Map Applikationen erstellen.\nDu weisst, wie Du eine Story Map erstellen und diese mit Inhalten füllen kannst.",
    "crumbs": [
      "WebGIS I"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html",
    "title": "Übung Web Map",
    "section": "",
    "text": "Übung 1: Erste Schritte mit ArcGIS Online (Online Tutorial)\nFühre das Online Tutorial «Erste Schritte mit ArcGIS Online» durch. Damit erlernst Du die grundlegenden Funktionalitäten der Kartenerstellung in ArcGIS Online.\nLink zum Tutorial",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-2-arcgis-online-inhaltsseite-organisieren",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-2-arcgis-online-inhaltsseite-organisieren",
    "title": "Übung Web Map",
    "section": "Übung 2: ArcGIS Online: Inhaltsseite organisieren",
    "text": "Übung 2: ArcGIS Online: Inhaltsseite organisieren\nIn ArcGIS Online kann die eigene Inhaltsseite personalisiert werden. Es können Ordner erstellt werden in denen Inhalte verwaltet und organisiert werden können.\n\nMelde Dich mit Deinen persönlichen Nutzerdaten auf dem ArcGIS Online Organisationskonto der ZHAW an: ZHAW ArcGIS Maps\nWechsle von der Startseite in das Register Inhalt. Im Ordner «Alle eigenen Inhalte» sollten die beiden Inhalte «At-Risk Population in Houston» (Instant App) und «Houston Evacuation Map» (Web Map) welche Du im Rahmen der ersten Übung (Online Tutorial) erstellt hast, aufgeführt sein.\n\n\n\n\n\nErstelle einen neuen Ordner mit dem Namen «Modul AGI» in dem Du alle Inhalte ablegen kannst, welche Du im Rahmen dieses Moduls auf ArcGIS Online hochlädst. Klicke hierfür auf «Neu», und gib den Namen für den neu zu erstellenden Ordner ein.\n\n\n\n\n\nVerschiebe nun die beiden Inhalte «At-Risk Population in Houston» (Web Mapping Application) und «Houston Evacuation Map» (Web Map) in den soeben neu erstellten Ordner. Gehe hierfür zurück auf den Ordner «Alle meine Inhalte». Selektiere die beiden Inhalte und klicke auf die Option «Verschieben».\n\nWähle im sich öffnenden Fenster «Element verschieben» den Ordner «Modul AGI» und verschiebe diese Inhalte in den neuen Ordner\n\n\n\n\n\nLege alle Deine Inhalte, welche Du im Rahmen dieses Moduls auf ArcGIS Online hochlädst im Ordner «Modul AGI» ab.\nDu kannst jederzeit neue Ordner erstellen und so Deine Inhalte auf ArcGIS Online organisieren.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-3-arcgis-online-freigabeeigenschaften-bei-bestehenden-inhalten-ändern",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-3-arcgis-online-freigabeeigenschaften-bei-bestehenden-inhalten-ändern",
    "title": "Übung Web Map",
    "section": "Übung 3: ArcGIS Online: Freigabeeigenschaften bei bestehenden Inhalten ändern",
    "text": "Übung 3: ArcGIS Online: Freigabeeigenschaften bei bestehenden Inhalten ändern\nBei der Durchführung des Esri Online Tutorials «Erste Schritte mit ArcGIS Online» hast Du sowohl die Web Map als auch die Web Mapping Application für «Alle (öffentlich)» freigegeben. Ändere nun die Freigabe dieser beiden Inhalte, damit diese nur noch von Dir aufgerufen werden können.\n\nZeige die Inhalte im Ordner «Modul AGI».\nKlicke bei der Web Mapping Application «At-Risk Population in Houston» auf das Globus-Symbol.\n\nÄndere im Freigabefenster nun die Freigabeeigenschaften für diesen Inhalt. Diese Anwendung soll nun nicht mehr für die Öffentlichkeit freigegeben sein, sondern nur noch für Dich (Du kannst die Anwendung öffnen, andere haben jedoch keinen Zugriff mehr darauf). Wähle hierfür die Option «Eigentümer».\n\n\n\n\n\nFühre dasselbe für die Web Map «Houston Evacuation Map» durch.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-4-arcgis-pro-karte-einrichten",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-4-arcgis-pro-karte-einrichten",
    "title": "Übung Web Map",
    "section": "Übung 4: ArcGIS Pro: Karte einrichten",
    "text": "Übung 4: ArcGIS Pro: Karte einrichten\nLade die Daten von Moodle herunter (ZIP-File: Daten Einführungsübung ArcGIS Online), extrahiere die Daten unter einem sinnvollen Ordnerpfad und erstelle ein neues ArcGIS Pro Projekt mit dem Namen E_ArcGIS_Online im Ordner, in dem Du die Übungsdaten extrahiert hast.\n\n\n\n\n\n\nTipp\n\n\n\nÜbrigens: Du kannst alle Deine Karten (Maps) welche Du im Laufe dieses Unterrichtsblocks erstellst in diesem Projekt speichern\n\n\n\nStarte ArcGIS Pro und erstelle ein neues ArcGIS Pro Projekt mit dem Namen «E_ArcGIS_Online».\nMelde Dich mit Deinen persönlichen Benutzerdaten (kürzel_student / PW) in ArcGIS Pro beim ArcGIS Online Portal der ZHAW an (sofern Du noch nicht angemeldet bist).\nBenenne die neue Map als «Einführung» (Contents Pane &gt; Kontextmenü Map &gt; Properties &gt; Map Properties &gt; General Tab &gt; bei Name Eingabe vornehmen &gt; mit OK bestätigen).\n\nGehe in das Catalog Window und überprüfe die Inhalte im Projektordner. Zusätzlich zur Projekt-GDB sollte die Geodatenbank «uebung_online_publikation.gdb» aufgeführt sein. Falls nicht, erstelle im Catalog Pane eine Verbindung zum Ordner her, in dem Du die heutigen Übungsdaten entpackt hast (Catalog Pane &gt; Project &gt; Folders &gt; Kontextmenü Add Folder Connection).\n\n\n\n\n\nDie Geodatenbank «uebung_online_publikation.gdb» enthält folgende Feature Classes:",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-5-arcgis-pro-koordinatensystem-anpassen",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-5-arcgis-pro-koordinatensystem-anpassen",
    "title": "Übung Web Map",
    "section": "Übung 5: ArcGIS Pro: Koordinatensystem anpassen",
    "text": "Übung 5: ArcGIS Pro: Koordinatensystem anpassen\nDamit die Daten später auf ArcGIS Online veröffentlicht werden können, muss den Daten das Koordinatensystem «WGS 1984 Web Mercator Auxiliary Sphere» zugewiesen werden. Momentan ist den fünf Layern noch das Schweizerische Koordinatensystem zugewiesen. Führe für jeden einzelnen Layer eine Koordinatentransformation durch.\n\n\n\n\n\n\nTipp\n\n\n\nUm Probleme bei der Veröffentlichung auf ArcGIS Online zu vermeiden empfiehlt es sich, immer mit dem Koordinatensystem «WGS 1984 Web Mercator Auxiliary Sphere» zu arbeiten.\n\n\n\nÖffne das Geoprocessing Window (Menü Analysis &gt; Tools)\n\nSuche nach «Project» und öffne das Tool «Project (Data Management Tools). Transformiere die fünf Layers vom Schweizerischen Koordinatensystem in das projizierte weltweite Koordinatensystem. Definiere hierfür die nötigen Werkzeug-Parameter. Speichere die Output Layers in der gleichen Geodatenbank (uebung_online_publikation.gdb), jeweils ohne «_lv95» (bsp. picknickplatz). Das Koordinatensystem WGS 1984 Web Mercator Auxiliary Sphere findest Du unter folgendem Pfad: Projected coordinate system &gt; World &gt; WGS 1984 Web Mercator (auxiliary sphere). Füge es doch zu Deinen Favoriten hinzu.\n\n\n\n\n\nNach Ausführung des Werkzeugs «Project» werden die Layers automatisch der Karte «Einfuehrung» hinzugefügt.\n\nWichtig: Entfernen Sie den Layer «veloweg» aus Ihrer Karte.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-6-arcgis-pro-vorbereitung-der-karte",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-6-arcgis-pro-vorbereitung-der-karte",
    "title": "Übung Web Map",
    "section": "Übung 6: ArcGIS Pro: Vorbereitung der Karte",
    "text": "Übung 6: ArcGIS Pro: Vorbereitung der Karte\nSymbolisiere die vier Layer in einer Art und Weise, dass sie gut voneinander unterschieden werden können. Weise dem Layer «stadtkreis» eine Einzelwert-Legende basierend auf dem Feld «kname» zu und versehe diesen Layer mit einer Transparenz. Ändere zudem die Basemap auf «Light Gray Canvas».\n\nAktiviere nun für den Layer «zeckenstiche» die Zeiteigenschaften:\n\nContents Window &gt; Kontextmenü Layer «zeckenstiche» &gt; Properties.\nWähle unter Time folgende Einstellungen und bestätige sie mit OK:\n\nLayer Time: Each feature has a single time field\nTime Field: date\n\n\n\nFür den Layer «zeckenstiche» hast Du die Zeiteigenschaften aktiviert und Du kannst nun im Menüband «Time» die Eigenschaften der Zeitanimation definieren und anpassen.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-7-arcgis-pro-veröffentlichen-publishing-einer-karte",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-7-arcgis-pro-veröffentlichen-publishing-einer-karte",
    "title": "Übung Web Map",
    "section": "Übung 7: ArcGIS Pro: Veröffentlichen (Publishing) einer Karte",
    "text": "Übung 7: ArcGIS Pro: Veröffentlichen (Publishing) einer Karte\nIm Folgenden wird diese Karte mitsamt all ihren Inhalten, Symbolisierung und Funktionalitäten als Web Map auf ArcGIS Online veröffentlicht (direkt via ArcGIS Pro). Vergewissere Dich, dass Du mit dem ZHAW ArcGIS Online Organisationskonto verbunden bist (Portal Connection) und speichere das ArcGIS Pro Projekt.\n\nWechsle in das Menüband «Share»\nWähle anschliessend «Web Map»\n\nGebe der Karte einen Namen (Zecken Stadt Zürich Vorname Name), schreibe eine kurze Zusammen-fassung und definiere Tags. Wähle folgende Einstellungen:\n\nSelect a Configuration: Copy all data Exploratory\nLocation Folder: Modul AGI (Die Inhalte werden in ArcGIS Online in diesem Ordner abgelegt)\nShare With: Groups (wähle «Modul Angewandte Geoinformatik HS 2021»; die Karte und die Feature Layers werden nur für diese Gruppe freigegeben).\n\n\n\n\n\n\nKlicke auf «Analyze» und löse bei Bedarf die angezeigten Probleme. Nutze zur Lösung der etwaigen Probleme die ArcGIS Webhelp. Sofern die Warnung «Layer does not have a feature template set» erscheint, kann diese vernachlässigt werden.\nDie Meldung «00374 Unique numeric IDs are not assigned» kann über das Kontextmenü gelöst werden. (Kontextmenü -&gt; «Auto-Assign IDs Sequentially»)\nVeröffentliche anschliessend die Web Map mit «Share». Dieser Vorgang kann einige Zeit in Anspruch nehmen.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-8-arcgis-pro-veröffentlichen-publishing-eines-layers",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-8-arcgis-pro-veröffentlichen-publishing-eines-layers",
    "title": "Übung Web Map",
    "section": "Übung 8: ArcGIS Pro: Veröffentlichen (Publishing) eines Layers",
    "text": "Übung 8: ArcGIS Pro: Veröffentlichen (Publishing) eines Layers\nIn der vorangehenden Übung 7 hast Du eine gesamte Karte als Web Map veröffentlicht. Manchmal müssen oder sollen jedoch nur einzelne (oder mehrere) Layers als Web Layers veröffentlicht werden ohne gleichzeitige Erstellung einer Web Map. Erstelle nun in Deinem ArcGIS Pro Projekt eine neue Karte und lade den Layer «veloweg» hinzu. Anschliessend kann dieser Layer als einzelner Feature Layer auf ArcGIS Online veröffentlicht werden.\n\nGehe wiederum ins Menü «Share» und wähle «Web Layer &gt; Publish Web Layer».\n\nGebe dem Layer den Namen «Velowege Vorname Name», schreibe eine kurze Zusammenfassung und definiere Tags. Wähle folgende Einstellungen:\n\nLayer Type: Feature\nLocation Folder: Modul AGI (Der Layer wird in ArcGIS Online in diesem Ordner abgelegt)\nShare With: Groups (wähle «Modul Angewandte Geoinformatik HS 2022»; der Feature Layer wird nur für diese Gruppe freigegeben).\n\n\n\n\n\n\nKlicke auf «Analyze» und löse angezeigte Probleme.\nDie Meldung «00374 Unique numeric IDs are not assigned» kann über das Kontextmenü gelöst werden. (Kontextmenü -&gt; «Auto-Assign IDs Sequentially»)\nVeröffentliche anschliessend den Web Layer «Velowege Vorname Name» mit «Share». Dieser Vorgang kann einige Zeit in Anspruch nehmen.\nSpeichere das ArcGIS Pro Projekt.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-9-arcgis-online-web-map-anpassen",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-9-arcgis-online-web-map-anpassen",
    "title": "Übung Web Map",
    "section": "Übung 9: ArcGIS Online: Web Map anpassen",
    "text": "Übung 9: ArcGIS Online: Web Map anpassen\nWechsle in einen Internet Browser und melde Dich beim ZHAW ArcGIS Online Organisationskonto an. Wechsle anschliessend in das Menü «Inhalt» und betrachte die Inhalte im Ordner «Modul AGI». Momentan sollten zwei Feature Layer inkl. Service Definition, zwei Web Maps und eine Web Mapping Application (Instant App) als Inhalte sichtbar sein.\n\nInhalte können auch gelöscht werden, beispielsweise benötigst Du die Web Mapping Application «At-Risk Population in Houston» und die Web Map «Houston Evacuation Map» nicht mehr. Selektiere die beiden Inhalte und durch Klicken auf «Löschen» kannst Du diese Inhalte unwiderruflich löschen. Merke Dir: Sofern Du nur die Web Map löschst, funktioniert die Web Mapping Application nicht mehr. Jede Web Mapping Application basiert immer auf einer Web Map!\n\nÖffne nun die Web Map «Zecken Stadt Zürich Vorname Name». Klicke auf «…» und wähle «In Map Viewer öffnen» (evtl. in neuem Browser-Fenster öffnen).\n\nDie Web Map enthält die vier Feature Layer «zeckenstiche», «picknickplatz», «vitaparcours» und «stadtkreis». Ändere nun die Namen der Layer (bsp. Zeckenstiche Zeit-animiert statt zeckenstiche):\n\nGehe auf «Inhalt».\nÖffne bei Layer «zeckenstiche» das Kontextmenü durch Klicken auf «…»\nWähle «Umbenennen» und ändere den Layernamen auf «Zeckenstiche Zeit-animiert»\n\n\n\n\n\nPasse die Namen der anderen Layers an (bsp. Grossschreibung)\n\nFüge nun das Veloweg-Netz der Stadt Zürich als zusätzlichen Feature Layer zur Karte.\n\nWähle «Hinzufügen» und dann «Durchsuchen von Layern» (beende bei Bedarf die Zeitanimation).\n\n\n\n\n\nSuche unter «Eigene Inhalte». Gib im Suchfeld «Veloweg» ein. Der Layer sollte dann angezeigt werden. Füge den Layer durch Klicken auf «+» der Karte hinzu. Der Layer wird der Karte hinzugefügt.\n\n\n\n\n\n\nVerändere die Layer-Reihenfolge. Verschiebe den Layer «Velowege» unterhalb von «Vita Parcours».\n\nGehe in den Reiter «Layer».\nVerschiebe mittels drag and drop den Layer «Velowege» an die gewünschte Position und ändere den Namen des Layers.\nAlternative: Klicke unter Inhalt beim Layer «Velowege» auf die drei vertikalen Punkte und verschiebe den Layer an den gewünschten Ort.\n\n\n\n\n\n\nÄndere das Symbol für den Layer «Velowege» (bsp. ein dezentes dunkelgrau).\n\nSelektiere den Layer «Velowege» in der Layer-Ansicht.\nÖffne das Menü «Styles» (vertikales Menü rechts).\n\n\n\n\n\nGehe auf «Style-Optionen»\nKlicke auf das Stift-Symbol und ändere die Linienfarbe und -breite.\n\n\n\n\n\nBestätige die Eingaben mit “Fertig” &gt; “Fertig”\n\nLade nun den Layer «Zeckenstiche Zeit-animiert» ein zweites Mal zur Webmap. Hierfür musst Du die Web-Feature-Layers «Zecken Stadt Zürich Vorname Name» nochmals zur Karte hinzufügen und anschliessend die Layers, welche nicht doppelt vorhanden sein sollen wieder entfernen. Ändere anschliessend den Style und deaktiviere die Zeitanimation.\n\nWähle «Hinzufügen». Füge den Web-Layer mit dem Namen «Zecken Stadt Zürich Vorname Name_WFL1» mittels «+» Button zur Karte hinzu.\n\nHebe zuerst mittels «Gruppierung aufheben) die Gruppierung auf (dieser Feature Layer enthält vier verschiedene Layers). Entferne anschliessend die Layers «Picknickplatz», «Vitaparcours» und «Stadtkreis» aus der Webmap, denn diese Layers sollen nicht doppelt in der Webmap enthalten sein. Führe dies für jeden Layer einzeln durch.\n\nÄndere anschliessend beim neu hinzugefügten Zeckenstich-Layer den Namen zu «Gemeldete Zeckenstiche».\nDeaktiviere nun die Option Zeitanimation im Layer «Gemeldete Zeckenstiche». Gehe in diesem Layer auf «Eigenschaften anzeigen» und deaktiviere die Zeiteigenschaften im entsprechenden Abschnitt.\n\nVerschiebe danach diesen Layer unterhalb des Layers «Zeckenstiche Zeit-animiert».\nVerändere beim Layer «Zeckenstiche Zeit-animiert» den Style, so dass sich die animierten Zeckenstiche deutlich von den gemeldeten Zeckenstichen unterscheiden lassen. Wähle beispielsweise ein gelbes Punktsymbol inklusive Blooming-Effekt. Symboleffekte können via Reiter «Effekte» definiert werden.\nEntferne beim Layer «Zeckenstiche Zeit-animiert» das Pop-up via «Pop-up konfigurieren». Somit wird verhindert, dass das Pop-up beim Anklicken eines Zeckenstich-Standortes zwei Mal aufgerufen wird.\n\n\n\n\n\nPop-ups können übrigens über das Menü «Pop-ups» benutzerdefiniert angepasst werden. Probiere diverse Optionen für andere Layer aus.\nDie Zeit-Animation kann im linken Bereich über das Menü «Karteneigenschaften» und dann «Optionen des Zeitschiebereglers» angepasst werden (Intervall, Geschwindigkeit etc.). Probiere auch hier unterschiedliche Optionen aus.\n\nErstelle nun noch zwei Bookmarks (Lesezeichen) für die Stadtkreise 7 und 10. Zoome hierfür in den Bereich des Stadtkreises 7. Gehe dann auf «Lesezeichen» &gt; «Lesezeichen hinzufügen», gib «Stadtkreis 7» ein und bestätige die Eingabe mit der Enter-Taste. Gehe gleich vor für den Stadtkreis 10. Zoome nachfolgend wieder auf das gesamte Stadtgebiet.\nDie Karte ist nun soweit vorbereitet, damit basierend auf dieser Web Map eine Web Mapping Applikation erstellt werden kann (folgende Übungen). Speichere die Karte via «Speichern und öffnen &gt; Speichern».\nErst nachdem die Layers einer Karte fertig symbolisiert sind, die Pop-ups konfiguriert und die Layer-Funktionalitäten etc. definiert sind kann eine Web Mapping Applikation erstellt werden. Die Web Mapping Applikation übernimmt die grundlegenden Einstellungen, welche in der Web Map definiert sind.\n\n\n\n\n\n\nTipp\n\n\n\nIn der Regel müssen sowohl die Web Map als auch die Web Mapping Applikation auf dieselbe Art und Weise freigegeben werden. Dies gilt natürlich auch für alle Web-Layers welche in einer Karte enthalten sind.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-10-arcgis-online-web-app-erstellen-via-instant-maps",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-10-arcgis-online-web-app-erstellen-via-instant-maps",
    "title": "Übung Web Map",
    "section": "Übung 10: ArcGIS Online: Web App erstellen via “Instant Maps”",
    "text": "Übung 10: ArcGIS Online: Web App erstellen via “Instant Maps”\nErstelle nun eine Web Mapping Applikation basierend auf der vorher konfigurierten Web Map. In dieser Übung arbeiten wir mit «Instant Maps». Hierfür muss die Karte zuerst im «Map Viewer» geöffnet werden. Anschliessend generierst Du die Web Mapping Applikation über die Option «Instant Apps» (analog Übung 1 – Online Tutorial).\n\nWähle die Option «Schieberegler» und gehe auf «Vorschau». Gehe Zurück und erstelle die App mit «Auswählen».\nBenenne die App als «Zecken App Zürich Vorname Name», lege sie im Ordner Modul AGI ab und wähle «App erstellen»\n\n\n\n\n\nGehe durch die 5 Schritte, aktiviere die Pop-Ups, die Lesezeichen und die Layer Liste. Veröffentliche anschliessend die Web App.\nErgänze die Web App nun noch mit einem zusätzlichen WMS-Layer. Gehe hierfür zuerst auf www.geolion.zh.ch und suche nach «Klimamodell». Gehe auf «Klimamodell ZH: Analysekarten (Raster)», öffne das Register «Datenbezug» und wähle den Link unter Datenbezug -&gt; «WMS».\nWechsle in ArcGIS Online auf «Inhalt» und füge den WMS-Klimamodell via « + Neues Element» hinzu. Wähle die Option «URL».\n\nKopiere nun die WMS-URL in geolion und füge sie in ArcGIS Online im entsprechenden Feld ein. Füge nach http ein s ein (https://wms.zh.ch…..) Wähle die Option WMS (OGC) und klicke auf «Weiter». Wähle in der Liste den WMS-Layer «Lufttemperatur Tag».\nDefiniere folgende Parameter:\n\nTitel = Lufttemperatur Tag\nOrdner = Modul AGI\nTags = Temperatur\nZusammenfassung = Lufttemperatur Tag auf 2m Höhe über Grund um 14 Uhr\n\n\nÖffne in ArcGIS Online die Web Map «Zecken Stadt Zürich Vorname Name». Gehe auf «Hinzufügen &gt; Layer durchsuchen» und füge den Layer «Lufttemperatur Tag» zur Web Map hinzu. Verändere die Layerhierarchie und platziere die Temperaturkarte zuunterst.\nSpeichere die Änderungen.\nÖffne nun die Web App. Der Layer «Lufttemperatur Tag» ist nun auch in der Web App enthalten und kann je nach Bedarf ein- und ausgeblendet werden (so wie alle anderen Layer auch).",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-11-arcgis-online-web-app-erstellen-via-experience-builder",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-11-arcgis-online-web-app-erstellen-via-experience-builder",
    "title": "Übung Web Map",
    "section": "Übung 11: ArcGIS Online: Web App erstellen via “Experience Builder”",
    "text": "Übung 11: ArcGIS Online: Web App erstellen via “Experience Builder”\nNun wirst Du eine zweite Web App erstellen, dieses Mal mit Unterstützung des Experience Builders. Der Experience Builder erlaubt eine viel flexiblere Gestaltung der Web App, insbesondere können verschiedenste Widgets in die Applikation integriert werden.\n\nÖffne wiederum die Web Map «Zecken Stadt Zürich Vorname Name» und wähle im Menü links die Option «App erstellen &gt; Experience Builder»\nWähle die Vorlage «Foldable». Du kannst eine Vorschau betrachten und dann via «Erstellen» in die Design-Oberfläche wechseln.\nNun kannst Du die Web App nach Belieben konfigurieren, mit Widgets ergänzen und Funktionalitäten einbinden.\nKlicke nach Abschluss der Konfiguration auf «Speichern unter» und weise einen sinnvollen Namen zu. Veröffentliche anschliessend die Anwendung.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/3_Uebung_Story_Map.html",
    "href": "E_WebGIS_1/3_Uebung_Story_Map.html",
    "title": "Übung Story Map",
    "section": "",
    "text": "Übung 1: Story Map im ZHAW ArcGIS Online Portal erstellen\nStory Maps vermitteln in interaktiver Form Informationen zu einem Ort, Ereignis, Problem, Trend oder Muster in einem geographischen Kontext. Textliche Inhalte können mit Fotos, Videos, Audiodateien und interaktiven Karten kombiniert werden.\nFür diese Übung werden keine Daten zur Verfügung gestellt. Du kannst eine Story Map basierend auf einem in diesem Modul behandelten Themenbereich und deren vorhandenen Daten aufbauen – oder alternativ – die Grundlage für die Story Map (eine mögliche Dokumentationsart) Deines Semesterprojekts entwerfen. Die Story Map erstellst Du auf dem ZHAW ArcGIS Online Portal.\nDer einfachste Weg eine Story Map zu erstellen, geht am schnellsten via ZHAW ArcGIS Online Oberfläche im Menü «Inhalt». Am besten erstellst Du vorgängig einen eigenen Ordner, in dem alle Inhalte der Story Map abgelegt sind.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>62</span>  <span class='chapter-title'>Übung Story Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/3_Uebung_Story_Map.html#übung-1-story-map-im-zhaw-arcgis-online-portal-erstellen",
    "href": "E_WebGIS_1/3_Uebung_Story_Map.html#übung-1-story-map-im-zhaw-arcgis-online-portal-erstellen",
    "title": "Übung Story Map",
    "section": "",
    "text": "Melde Dich mit Deinen persönlichen Nutzerdaten auf dem ArcGIS Online Organisationskonto der ZHAW an: https://zhaw.maps.arcgis.com\nWechsle von der Startseite in das Register Inhalt. Erstelle bei Bedarf einen neuen Ordner für die Story Map (via Symbol «Neuen Ordner erstellen»).\nGehe auf «App Erstellen».\n\nWähle die Option «StoryMaps»\n\nÜber das Hilfemenü (oben rechts) hast Du Zugriff auf verschieden Links, unter denen Du Hilfe zur Erstellung einer Story Map erhältst.\n\nÖffne die Links jeweils in einem neuen Browser-Tab.\n\nÜberblick: Allgemein Information zu Story Maps.\nDokumentation: Lese was eine Story Map ist und informiere Dich, wie Du eine erste Story erstellen und veröffentlichen kannst.\n\nRessourcen: Hier findest Du Tipps, was Du bei der Erstellung von Story Maps beachten musst damit diese aussagekräftig und fesselnd sind. Beachte hier die Story «Nine steps to great storytelling» (https://storymaps.arcgis.com/stories/429bc4eed5f145109e603c9711a33407). Über folgendes Tutorial wird Dir vermittelt, wie Du deine Story erstellen kannst: Tutorial\nFAQ: Hier findest Du Antworten zu häufig gestellten Fragen.\n\nErstelle nun den ersten Entwurf einer Story Map. Über die Option «Entwerfen» kannst Du das Erscheinungsbild Deiner Story anpassen.\n\nÜber die Option «Vorschau» kannst Du dir eine Vorschau der erarbeiteten Story anzeigen lassen (am besten in einem neuen Browser-Tab öffnen).\n\nDie Option «Veröffentlichen» ermöglicht Dir, die Story zu veröffentlichen und die Freigabeeinstellungen anzupassen.\n\nErstelle nun Deine Story Map, fülle die Story mit Inhalten (Text, Bilder, Grafiken, Web Maps, Videos, Links etc.). Nutze selbständig die zur Verfügung stehenden Hilfe-Optionen (vorangehende Seite). Beachte: Bevor Du eine Web Map in eine Story Map integrieren kannst, muss diese vorgängig erstellt werden. Dabei müssen alle Inhalte auf die gleiche Art und Weise freigegeben werden.\nArbeite selbständig und sei kreativ. Probiere verschiedene Dinge aus. Beachte jeweils die Freigabeeigenschaften.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>62</span>  <span class='chapter-title'>Übung Story Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/4_Leistungsnachweis.html",
    "href": "E_WebGIS_1/4_Leistungsnachweis.html",
    "title": "Leistungsnachweis",
    "section": "",
    "text": "Es muss eine voll funktionsfähige Story Map erstellt werden, welche eine integrierte Web Map aus der vorherigen Übung enthält. Die Story Map soll in einer eigenen Gruppe veröffentlicht werden.\nGehe folgendermassen vor:\n\nErstelle in ArcGIS Online eine neue eigene Gruppe.\nBenenne die Gruppe als «Leistungsnachweis Vorname Name».\nDefiniere folgende Gruppeneigenschaften:\n\nWer kann diese Gruppe sehen? -&gt; Nur Gruppenmitglieder\nWer kann Mitglied dieser Gruppe sein? -&gt; Nur Mitglieder der eigenen Organisation\nWie können Personen dieser Gruppe beitreten? -&gt; Nach Einladung\nWer kann Inhalte beitragen? -&gt; Alle Gruppenmitglieder\n\nFüge Hanno Rahn (rahn_zhaw) und Evelyn Terzer (terz_zhaw) deiner eigenen Gruppe «Leistungsnachweis Vorname Name» als Mitglied hinzu (via Benutzer einladen) ohne eine Bestätigung anzufordern.\nVeröffentliche deine Story Map für alle Mitglieder Deiner Gruppe «Leistungsnachweis Vorname Name».\n\nGib deine Lösung bis spätestens Freitag 20. Dezember 2024 auf Moodle ab. Lade hierzu den Link zu deiner Story Map hoch. Achte auf die korrekten Berechtigungen von Story Map und Web Map. Beide müssen diesselben Berechtigungen haben.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>63</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/1_Einleitung.html",
    "href": "E_WebGIS_2/1_Einleitung.html",
    "title": "WebGIS II",
    "section": "",
    "text": "HinweisÜbungsziele\n\n\n\n\nDu kannst eine Map mit mehreren Layern und einer Legende in Python erstellen.\nDu kannst deine Map und weitere Elemente mittels Chunk Options als HTML publizieren. \nOptional: Du kennst die grundlegenden Webtechnologien wie HyperText Markup Language (HTML), JavaScript und Cascading Style Sheets (CSS).\nOptional: Du hast dich mit Leaflet, der beliebtesten Open-Source-JavaScript-Bibliothek, vertraut gemacht.\nOptional: Du kannst das GeoJson-Dateiformat verwenden.",
    "crumbs": [
      "WebGIS II"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "",
    "text": "Übung 1: Vorbereitung\nIn dieser Übung wollen wir mit unseren originalen und simulierten Zeckenstichen aus dem Block Programmieren eine interaktive Karte erstellen. Zudem werdet ihr weitere Tools und Tipps erhalten, wie ihr euren Code aufwerten und zum Schluss als HTML darstellen könnt.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-1-vorbereitung",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-1-vorbereitung",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "",
    "text": "Bitte ladet zuerst die Übungsdaten hier runter und entpackt diese.\nKreiert eine neue Python-Environment und installiert die für diese Übung benötigten Packages via Terminal gemäss Conda Environment erstellen\nconda create --name geopython3\nconda activate geopython3\nconda install -c conda-forge geopandas folium matplotlib mapclassify jupiterlab quarto\nStartet nun Positron via Terminal gemäss Conda Environment erstellen\nKreiert ein neues Quarto-File (New &gt; New File… &gt; Quarto Document) und speichert es in eurem Arbeitsordner ab.\n\n\nAufbau eines Quarto Dokumentes\nEin Quarto Dokument hat grob drei Elemente: (1) Den Header bzw. die Metadaten, (2) die Code Chunks und (3) die Textbereiche\n\nDer Header wird beim Erstellen des Dokumentes bereits erstellt. Beim format könnt ihr definieren, wie am Ende eurer Dokument gerendert werden soll. Möglich sind u.a. HTML, PDF und MS Word. Wir belassen für heute das vordefinierte Format html, weitere Anpassungen folgen weiter unten.\n---\ntitle: \"Untitled\"\nformat: html\n---\nDer Code wird in sogenannten Code Chunks geschrieben. Eine neue Zelle fügt ihr ein, indem ihr Ctrl+Shift+I drückt. Falls in der eckigen Klammer nicht python stehen sollte, müsst ihr das in diesem Fall anpassen.\nZwischen die Code Chunks könnt ihr euren Text schreiben. Die Basics, wie ihr euren Text formatieren könnt, findet ihr hier\n\nEin Auschnitt des Quarto Dokumentes für die Übungen von Programmieren I hat z.B. so ausgesehen: \n\n\nPackages und Daten laden\nImportiert nun als erstes die zwei Packages geopandas und folium. Schreibt den Code in einer Code Cell.\nLadet zudem die drei Datensätze wald.gpkg, zeckenstiche_original.gpkg und zeckenstiche_simuliert.gpkg mit der read_file Funktion von Geopandas.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-2-base-map",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-2-base-map",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 2: Base Map",
    "text": "Übung 2: Base Map\nNun können wir unsere Karte bauen. Zuerst müssen wir eine Basiskarte erstellen, zu welcher wir dann die weiteren Layer hinzufügen können. Dazu nutzen wir nun Folium. Als Mittelpunkt der Karte wählen wir die WGS84 Koordinaten der Stadt Zürich (Zurich latitude: 47.36667, longitude: 8.55) aus.\n\n# Zurich latitude longitude: 47.36667, 8.55\nmap = folium.Map(location=[47.36667, 8.55], zoom_start = 13, tiles = \"cartodbpositron\")\n\nIhr könnt mit den Tiles und dem Zoom Level experimentieren. Information zu den Tiles findet ihr hier.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-3-wald-layer-hinzufügen",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-3-wald-layer-hinzufügen",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 3: Wald Layer hinzufügen",
    "text": "Übung 3: Wald Layer hinzufügen\nNun wollen wir die Waldflächen als unseren ersten Layer hinzufügen. Ihr habt die .explore() Funktion bereits kennengelernt. Sie verfügt über diverse interessante Attribute, welche wir nun benutzen wollen.\nDa unser Wald-Datensatz aus zwei Zeilen mit Wald und Nicht-Wald besteht, müssen wir die Waldflächen zuerst noch rausfiltern.\nFolium kann nur das weltweite CRS WGS84 (EPSG:4326) verarbeiten und da der Geodataframe Wald das Schweizer CRS CH1903+ / LV95 (EPSG:2056) verwendet, müssen wir dieses mittels to_crs() transformieren, bevor wir ihn visualisieren können.\nTipp: Wenn ihr am Schluss des Commands ein ; hinzufügt, wird kein Output generiert. Somit wird nicht für jeden Layer den wir hinzufügen, eine Karte erstellt.\n\n# Wald zur Karte hinzufügen\nis_wald = wald[wald[\"Wald_text\"] == \"ja\"] # Selektieren nur den Wald\nis_wald.to_crs(4326).explore(\n    m = map,           # Fügt diesen Layer der Map map hinzu\n    color = \"green\",   # Der Layer wird grün dargestellt\n    tooltip = False,   # Es werden keine Daten angezeigt, wenn man über ein Objekt hovered.\n    highlight = False, # Das Objekt wird nicht hervorgehoben, wenn man darüber hovered.\n    name = \"Wald\"      # Der Name des Layers\n);",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-4-original-und-simulierter-zeckenstich-layer-hinzufügen",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-4-original-und-simulierter-zeckenstich-layer-hinzufügen",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 4: Original und simulierter Zeckenstich Layer hinzufügen",
    "text": "Übung 4: Original und simulierter Zeckenstich Layer hinzufügen\nNun wollen wir neben dem Wald Layer (Polygon) den originalen Zeckenstiche Layer (Punkte) hinzufügen. Kopiere dazu den unteren Code.\n\n# Original Zeckenstiche zur Karte hinzufügen\nzeckenstiche_original_gpd.to_crs(4326).explore(\n    m = map,                                     # Fügt diesen Layer der Map map hinzu\n    color = \"red\",                               # Der Layer wird rot dargestellt\n    marker_kwds = dict(radius = 1, fill = True), # Optionen für das Aussehen der Punkte\n    tooltip = \"ID\",                              # Beim Hovern über das Objekt wird die ID dargestellt\n    name = \"Original Zeckenstiche\"               # Der Name des Layers\n);\n\nNun wollen wir die simulierten Zeckenstiche darstellen. Als Vorlage könnt ihr den Code von oben kopieren. Erweitere die Funktion explore um folgende Logik:\n\nGerne würden wir die Spalte “Radius” mit der Farbvariation viridis visualisieren. Nutze hierfür die Attribute column und cmap.\nZudem soll die Legende des Layers dargestellt werden. Zudem wollen wir keine Colorbar als Legende haben. Nutze dafür die Optionen der Legende legend_kwds = dict(colorbar = False).\nIn den Tooltips sollen neben der ID noch der Radius und der Run dargestellt werden.\nNenne den Layer “Simulation Zeckenstiche”.\n\nWeitere Informationen zur explore Funktion findet ihr hier.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-5-layer-control-hinzufügen",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-5-layer-control-hinzufügen",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 5: Layer Control hinzufügen",
    "text": "Übung 5: Layer Control hinzufügen\nZum Abschluss wollen wir noch ein Layer Control hinzufügen, damit wir die verschiedenen Layer ein- und ausblenden können. Schaut dafür im User Guide von Folium und sucht nach der Layer Control Funktion und versucht diese eurer map hinzuzufügen. Zum Schluss kannst du die map aufrufen, damit diese Dargestellt wird. Das finale Produkt sollte wie folgt aussehen:\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nNun ist unsere Map fertig. Inspiziert diese und spielt mit den Radien und Runs herum und versucht auch die Grössen und Farben der Points anzupassen, bis Ihr mit dem Resultat zufrieden seid.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-6-quarto-dokument-verschönern",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-6-quarto-dokument-verschönern",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 6: Quarto Dokument verschönern",
    "text": "Übung 6: Quarto Dokument verschönern\n\nVorbereiten von Quarto und Darstellung (Preview) unseres Dokumentes\nWir erweiteren jetzt unseren Header mit den Metadaten. Dies bewirkt, dass euer Quarto Output neben einem Titel auch einen Autor hat. Zudem sagen wir Quarto, dass wir mit Python3 arbeiten. Für unseren Ausgabeformat, welches HTML sein soll, definieren wir folgende globale Optionen:\n\nembed-resources: true: Generiert ein einzelnes HTML File.\ncode-fold: true: Alle Code Cells werden eingeklappt.\n\n---\ntitle: Visualisierung Zeckenstiche\nauthor: Vorname Nachname\njupyter: python3\nformat:\n    html:\n        embed-resources: true\n        code-fold: true\n---\nQuarto gibt uns zudem die Möglichkeit, unser File als Vorschau darzustellen. Wechselt hierfür zum Terminal in Positron. Mit dem Command quarto preview NameQuartoDokument.qmd erhaltet ihr ein Preview in eurem Browser. Achtet darauf, dass im Terminal geopython3 als Interpreter steht.\n\n\nCell Options\nCell Options können dazu benutzt werden, um das Verhalten einer Cell zu verändern. Dabei werden diese Optionen mittels des Vorschubs #| am Anfang der Cell eingefügt. Wenn ihr eine Option für alle Cells haben wollt, könnt ihr diese als globale Optionen in den Metadaten von Quarto setzen (analog zu code-fold: true).\n#| echo: false\n#| code-summary: This is a Title for a collapsed Code Block\n\nPython Code...\nDie häufigsten Options sind:\n\neval: Soll die Code Cell ausgeführt werden.\necho: Soll der Code der Cell angezeigt werden.\noutput: Soll der Code Output dargestellt werden.\ncode-fold: Soll die Code Cell eingeklappt werden.\ncode-summary: Wenn code-fold auf true gesetzt ist kann ein Titel für die Code Cell gesetzt werden.\n\nEs gibt aber noch viele weitere Möglichkeiten (siehe hier).\n\n\nPage Layout\nMit Quarto könnt ihr euer Webseiten-Layout relativ einfach anpassen. Ihr könnt zum Beispiel mit folgendem Code ein Grid erstellen, welcher aus zwei Spalten besteht. Eine Spalte ist 9 und die zweite 3 breit. Die Gesamtbreite ist immer 12.\n::: {.grid}\n\n::: {.g-col-9}\nText 1\n:::\n\n::: {.g-col-3}\nText 2\n:::\n\n:::\nWeitere Möglichkeiten findet ihr hier.\n\n\nTabellen\nEine Tabelle muss nach folgender Markdown Syntax erstellt werden (siehe Quarto Tables):\n|Name |Gender|Age  |Origin | \n|-----|:-----|:---:|:-----:|\n|Jack |Male  |23   |USA    |\n|Susan|Female|22   |Canada |\n\n: Name der Tabelle {#tbl-names}\n\nDie erste Zeile ist die Tabellenüberschrift\nDie zweite Zeile beinhaltet Bindestriche “-” und optionalen Doppelpunkten “:”, um den Text in den Spalten auszurichten.\n\n:--- für die linke Ausrichtung\n:---: für die mittlere Ausrichtung\n---: für die rechte Ausrichtung\n\nDie weiteren Zeilen beinhalten der Tabelleninhalt.\nMit dem : unter der Tabelle kannst du den Namen der Tabelle definieren. Mit {#tbl-???} kannst du den Namen für einen Querverweise im Text erstellen. Dieser kann dann mittels @tbl-??? im Text aufrufen.\n\nEine praktische Hilfe für das Erstellen einer Tabelle ist der Tablesgenerator.\n\n\nBilder\nEin Bild kann ebenfalls via Markdown Syntax hinzugefügt werden. Zuerst folgt die Caption des Bildes, gefolgt vom Bild selbst. Mit {#fig-???} kannst du einen Querverweis für das Bild erstellen. Gleich wie bei der Tabelle kannst du ihn im Text mittels @fig-??? aufrufen.\n![Caption](../images/test.png){#fig-???}\nWeitere Information findet ihr auf Quarto.\n\n\nAufgabe\nSeht euch die Webseite an. Versucht nun die Struktur dieser Webseite so gut wie möglich in eurem Quarto Dokument nachzubauen. Nutzt dafür die oben beschriebenen Methoden. Das Bild findet ihr in den Übungsdaten.\nBenutze zudem die Cell Options, um euren Code sauber darzustellen. Nutzt dazu echo und output, um unnötige Cell Codes und Outputs nicht auszugeben. Benenne zudem alle eingeklappten Code Cells sinnvoll mittels code-summary.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-7-notebook-in-html-konvertieren-und-publizieren",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-7-notebook-in-html-konvertieren-und-publizieren",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 7: Notebook in HTML konvertieren und publizieren",
    "text": "Übung 7: Notebook in HTML konvertieren und publizieren\nDamit wir nun unser Quarto Dokument publizieren können, müssen wir davon einen Output generieren.\nDazu nutzen wir wieder Quarto im Terminal. Aber anstelle des preview Commands nutzen wir den render Command, sprich quarto render NameQuartoDokument.qmd. Da wir in den Quarto Metadaten als Format HTML angegeben haben, wird Quarto ein HTML File generieren.\nErstellt nun einen neuen Ordner und kopiert euer HTML File hinein. Ändere den Namen des HTMLs auf index.html. Euer HTML werden wir nun kurzfristig auf Netlify publizieren. Öffnet dazu diesen Link und drag und drop euren eben erstellten Ordner. Über den angezeigten Link könnt ihr nun, nachdem ihr das automatisch generierte Passwort eingegeben habt, eine Stunde lang auf eure Webseite zugreifen.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html",
    "title": "(Optional) Übung Leaflet",
    "section": "",
    "text": "Übung 1: Erste Schritte mit HTML\nHTML Tutorial\nDie HyperText Markup Language (HTML) ist die Standard Markup Language für Inhalte, die in einem Webbrowser angezeigt werden sollen. Einfach ausgedrückt ist HTML die Sprache um den Inhalt einer Webseite zu definieren. Praktisch alle Webseiten basieren auf HTML.\nLass uns mit einem einfachen Editor eurer Wahl ein erstes einfaches HTML-Dokument erstellen.\nVorgeschlagene Editoren:\nÖffnet den Editor Eurer Wahl und erstellt eine grundlegende HTML-Struktur, indem ihr das folgende Codefragment einfügt.\nSpeichert das Dokument als index.html in Eurem Arbeitsverzeichnis ab und öffnet es in einem von euch bevorzugten Browser. Ihr solltet etwas ähnliches wie die folgende Abbildung sehen (Abbildung 65.1).\nAlle HTML-Dokumente müssen mit einer Dokumenttyp-Deklaration beginnen: &lt;!DOCTYPE html&gt;. Das HTML-Dokument selbst beginnt mit &lt;html&gt; und endet mit &lt;/html&gt;. Der sichtbare Teil des HTML-Dokuments liegt zwischen &lt;body&gt; und &lt;/body&gt;. In diesem Abschnitt haben wir unsere erste Überschrift &lt;h1&gt;&lt;/h1&gt; positioniert, sowie das HTML-Element &lt;p&gt;&lt;/p&gt;, welches einen Absatz innerhalb des Body-Abschnitts definiert. Mehr zum Thema fHTML-Elemente findet Ihr unter folgendem Link HTML Elemente.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-1-erste-schritte-mit-html",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-1-erste-schritte-mit-html",
    "title": "(Optional) Übung Leaflet",
    "section": "",
    "text": "Sublimetext\nNotepad++\nAtom\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Page title&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;My first heading&lt;/h1&gt;\n        &lt;p&gt;The first paragraph.&lt;/p&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\nAbbildung 65.1: Ihre Erste HTML-Seite",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-2-erste-schritte-mit-javascript-und-der-leaflet-bibliothek",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-2-erste-schritte-mit-javascript-und-der-leaflet-bibliothek",
    "title": "(Optional) Übung Leaflet",
    "section": "Übung 2: Erste Schritte mit JavaScript und der Leaflet-Bibliothek",
    "text": "Übung 2: Erste Schritte mit JavaScript und der Leaflet-Bibliothek\nJavaScript Tutorial\nIn der Welt der Webentwicklung ist HTML die Basis von allem, da es uns die Möglichkeit gibt, unsere Inhalte im Web darzustellen. Das, was die Dinge wirklich interessant und interaktiv macht, ist jedoch JavaScript. JavaScript ist im Moment die beliebteste Programmiersprache der Welt. Wenn HTML den Inhalt der Webseite definiert, definiert JavaScript dessen Verhalten. In HTML wird der JavaScript-Code zwischen den Tags &lt;script&gt; und &lt;/script&gt; in einem beliebigen Teil unseres HTML-Codes (Head oder Body) eingefügt.\nIn dieser Übung verwenden wir zur Entwicklung einer einfachen Webkarte die Library Leaflet. Leaflet ist die beliebteste Open-Source-JavaScript-Library für die Entwicklung interaktiver Webkarten. Ihr Hauptvorteil besteht darin, dass sie effizient auf allen wichtigen Desktop- und Mobilplattformen läuft und auf einer einfach zu verwendenden und gut dokumentierten Anwendungsprogrammierschnittstelle (API) basiert.\n\nGeht zurück in Euer HTML-Dokument, das Ihr in Übung 1 erstellt habt und löscht die Elemente &lt;h1&gt; und &lt;p&gt;, sodass nur noch der leere &lt;body&gt; übrig ist.\n\nAls nächsten Schritt werden wir ein &lt;div&gt;-Element für die Definition unserer Karte erstellen. Ein &lt;div&gt; HTML-Element ist ein allgemeiner Container, der keine Auswirkung auf den Inhalt oder das Layout hat, bis er in irgendeiner Art und Weise mit Hilfe einer Styling-Sprache angesteuert wird. Hier kommt der dritte wichtige Akteur der Webentwicklung ins Spiel. Nämlich die Sprache Cascading Style Sheets kurz CSS. CSS ist die Sprache, die verwendet wird, um ein HTML-Dokument zu gestalten und um zu beschreiben, wie unsere Inhalte im Web dargestellt werden sollen. In HTML wird der CSS-Code zwischen den Tags &lt;style&gt; und &lt;/style&gt; innerhalb der &lt;head&gt;-Tags eingefügt.\nCSS Tutorial\n\nErstellt ein div-Element, um die Karten-ID festzulegen, damit wir unsere Karte gestalten können.\n&lt;div id = \"map\"&gt;&lt;/div&gt;\nVerwendet den # CSS-Selektor CSS-Selektoren innerhalb der &lt;style&gt;&lt;/style&gt;-Tags, um unsere Karte auf Vollbild zu setzen, indem Ihr die absolute Positionierung in die Ecken setzen.\n&lt;style&gt;\n    #map {position: absolute; top: 0; bottom: 0; left: 0; right: 0;}\n&lt;/style&gt;\nNun werden wir die Leaflet-Bibliothek in unser File einbinden. Geht dazu auf Leaflet. Kopiert die folgenden zwei Codezeilen, welche die Leaflet CSS- und JavaScript-Dateien enthalten, in den Head-Bereich Eures HTML-Dokuments.\n&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.css\" integrity=\"sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=\" crossorigin=\"\" /&gt;\n&lt;script src=\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.js\" integrity=\"sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=\" crossorigin=\"\"&gt;&lt;/script&gt;\nAls nächstes erstellen wir eine neue Variable (innerhalb von &lt;script&gt;&lt;/script&gt;), welcher wir unsere bereits definierte Karte zuweisen. Im Folgenden definieren wir das Zentrum unserer Karte sowie die gewünschte Schärfeebene.\nvar map = L.map('map', {center: [46.944, 8.028], zoom: 8}); // Focus on Switzerland\nUm einen geigneten Tile Layer zu finden, könnt Ihr die Website Maptiler durchforsten. Wählt eine Map die Euch gefällt aus, scrollt nach unten zu den Tiles und kopiert den Link (siehe Abbildung 65.2).\n\n\n\n\n\n\nAbbildung 65.2: Tile kopieren\n\n\n\n\nFügt den Link mit der Methode L.tileLayer() hinzu. Diese Methode von Leaflet erlaubt es uns den Tile Layer zu hosten (Leaflet-Erweiterungsmethoden). Aus Referenzierungsgründen ist es wichtig das Wir auch die Attribution hinzufügen (siehe Abbildung 65.3), welche am Ende der gleichen Webseite zu finden ist (Tipp: Ihr könnt diesen Schritt aus dem Code unten kopieren).\nFüge schliesslich alles mit der Methode addTo(map) zu unserer Karte hinzu.\n\n\n\n\n\n\nAbbildung 65.3: Kopieren der Attribution für die Nennung der Autoren\n\n\n\n\n\n\n\n\n\n\n\nTipp\n\n\n\nUm die Daten zu erhalten, müsst Ihr ein kostenloses Konto erstellen. (Ihr könnt dazu eure ZHAW-E-Mail-Konto verwenden).\n\n\nNachdem Ihr die oben genannten Schritte durchgeführt habt, sollte Euer Code wie folgt aussehen:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.css\" integrity=\"sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=\" crossorigin=\"\" /&gt;\n        &lt;script src=\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.js\" integrity=\"sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=\" crossorigin=\"\"&gt;&lt;/script&gt;\n        &lt;style&gt;\n            #map {position: absolute; top: 0; bottom: 0; left: 0; right: 0;}\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id = \"map\"&gt;&lt;/div&gt;\n        &lt;script&gt;\n            var map = L.map('map', {center: [46.944, 8.028],zoom: 8});\n            L.tileLayer('https://api.maptiler.com/maps/streets-v2/256/{z}/{x}/{y}.png?key=4X87DmrzALHNsvjVPyhW', {attribution: '&lt;a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\"&gt;&copy; MapTiler&lt;/a&gt; &lt;a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\"&gt;&copy; OpenStreetMap contributors&lt;/a&gt;'}).addTo(map);\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\nSpeichert das Dokument (index.html) und öffnet es in Eurem bevorzugten Browser. Das Ergebnis sollte ähnlich aussehen wie Abbildung 65.4.\n\n\n\n\n\n\n\nAbbildung 65.4: Interaktive Webkarte mit Leaflet JavaScript-Bibliothek",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-3-geojson-datei-zur-webkarte-hinzufügen",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-3-geojson-datei-zur-webkarte-hinzufügen",
    "title": "(Optional) Übung Leaflet",
    "section": "Übung 3: GeoJson-Datei zur Webkarte hinzufügen",
    "text": "Übung 3: GeoJson-Datei zur Webkarte hinzufügen\nGeoJson ist ein sehr verbreitetes Dateiformat zur Kodierung einer Vielzahl von geografischen Datenstrukturen. In der Webkartenentwicklung können GeoJson Variablen innerhalb einer JavaScript-Datei zugewiesen werden.\n\nLadet von Moodle die Übungsdateien herunter und speichert alles im gleichen Ordner, in dem Euer Dokument index.html liegt. Einer der Hauptvorteile von JavaScript ist, dass es sich gut in ein HTML-Dokument integrieren lässt. Mit den Tags `&lt;script&gt;&lt;/script&gt; können wir beliebig viele JavaScript-Dateien mit dem Haupt-HTML-Dokument verknüpfen. Dies werden wir mit der Datei kantons.js tun.\nVerknüpft die Datei kantons.js im Head Eueres Dokuments (nach dem Leaflet Script) wie folgt:\n&lt;script src=\"kantons.js\"&gt;&lt;/script&gt;\nÖffnet nun die Datei kantons.js und kopiert den Namen der Variable, in der die Geojson-Daten gespeichert sind. Fügt diese anschliessend wie folgt zu Eurer Karte hinzu:\nL.geoJSON(nameOfTheVariable).addTo(map); \n\nNach dem Speichern und Aktualisieren Eures index.html-Dokuments sollte Eure Karte wie Abbildung 65.5 aussehen.\n\n\n\n\n\n\nAbbildung 65.5: Interaktive Webkarte mit den Kantonen der Schweiz",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-4-farbe-in-die-webkarte-einbringen",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-4-farbe-in-die-webkarte-einbringen",
    "title": "(Optional) Übung Leaflet",
    "section": "Übung 4: Farbe in die Webkarte einbringen",
    "text": "Übung 4: Farbe in die Webkarte einbringen\nDas Ziel dieser Übung ist die Entwicklung einer interaktiven Choroplethenkarte. Jeder der räumlichen Einheiten (Kanton der Schweiz), wird eine Farbe zugewiesen. Jede Farbe basiert dabei auf einem spezifischen Geojson-Attribut, in unserem Fall die Bevölkerungszahl jedes Kantons.\n\nÖffnet erneut die Datei kantons.js und untersuchet die Geojson-Datei. Suchet nach dem Attribut welches die Bevölkerungszahl der Kantone representiert (siehe Abbildung 65.6).\n\n\n\n\n\n\n\nAbbildung 65.6: JavaScript-Datei mit einer Sammlung von geografischen Datenstrukturen im Geojson-Format\n\n\n\n\nAls Nächstes werden wir die folgenden beiden Funktionen (getColor(d), style(feature)) verwenden, um jedem Kanton eine Farbe auf der Grundlage seiner Bevölkerungszahl zuzuweisen. Kopiert die folgenden Funktionen und fügt diese nach der map-Variablen in Euer Dokument ein.\nfunction getColor(d) {\n    return d &gt; 1000000 ? '#084594' :\n    d &gt; 500000 ? '#2171b5' :\n    d &gt; 200000 ? '#4292c6' :\n    d &gt; 100000 ? '#6baed6' :\n    d &gt; 50000 ? '#9ecae1' :\n    d &gt; 20000 ? '#c6dbef' :\n    d &gt; 10000 ? '#deebf7' :\n    '#f7fbff';\n}\n\nfunction style(feature) {\n    return {\n        // using the population property as argument\n        fillColor: getColor(feature.properties.Bevolkerung),\n        weight: 2,\n        opacity: 1,\n        color: 'white',\n        dashArray: '3',\n        fillOpacity: 0.7\n    };\n}\nDie erste Funktion (getColor(d)) gibt das Argument d als Farbcode (z.B. #9ecae1) zurück, nachdem dessen Wert überprüft wurde. Wenn d zum Beispiel grösser als 1’000’000 ist, erhalten wir die Farbe #084594.\nDie Funktion (getColor(d)) wird dann innerhalb der zweiten Funktion (style(feature)) aufgerufen und nimmt als Argument das Attribut Bevolkerung der Variable kantons, die in der Datei kantons.js gespeichert ist. Schliesslich weist die Funktion style(feature) als Füllfarbe (fillColor) das Ergebnis der Funktion getColor(d) zu.\nWir fügen nun als Style-Eigenschaft unseres L.geoJson-Objekts die Funktion style(feature) wie folgt hinzu:\nL.geoJSON(kantons, {style: style}).addTo(map); \n\nNachdem Euer Dokument gespeichert und Euer Browser aktualisiert ist, sollte Eure Karte wie Abbildung 65.7 aussehen.\n\n\n\n\n\n\nAbbildung 65.7: Web Interaktive Choroplethenkarte mit den Kantonen der Schweiz",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-5-hinzufügen-von-interaktion-zur-webkarte",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-5-hinzufügen-von-interaktion-zur-webkarte",
    "title": "(Optional) Übung Leaflet",
    "section": "Übung 5: Hinzufügen von Interaktion zur Webkarte",
    "text": "Übung 5: Hinzufügen von Interaktion zur Webkarte\nNachdem wir die Choroplethenkarte entwickelt haben, wäre es schön, wenn wir ihr etwas Interaktivität geben könnten. Dazu verwenden wir eine der wichtigsten Funktionen von JavaScript, den Event Listener. Kurz gesagt definieren Event Listener die Art und Weise, wie die Endbenutzer mit dem Webinhalt interagieren können. Der wohl bekannteste ist der Onclick-Listener. Onclick-Listener definieren, was passiert, wenn der Benutzer irgendwo auf der Seite klickt. In unserem Fall ist es unser Ziel, dass wir auf jede räumlichen Einheiten (Kantone) in unserer Karte klicken können und wir im Gegenzug möglichst viele Informationen zurückerhalten. Genauer gesagt wollen wir, dass bei jedem Klick auf einen Kanton der Name und die Bevölkerungszahl auf dem Bildschirm angezeigt wird.\nIn einem ersten Schritt müssen wir sicherstellen, dass unsere GeoJSON-Ebene über eine Variable zugänglich ist, indem wir sie vor unseren Listenern definieren.\n\nErstellt eine Variable mit dem Namen geojson, direkt nach der Variable map wie folgt:\nvar map = L.map(\"map\", {center: [46.984, 8.950], zoom:7}); // focus on Switzerland\nvar geojson;\nZuerst definieren wir, was bei einem Klick passieren soll. In userem Fall soll ein Popup mit dem Namen und der Bevölkerungszahl des Kontons erscheinen. Die Funktion sieht wie folgt aus:\nfunction showInfo(e) {\n    geojson.bindPopup(\"Kanton: \" + \" \" + e.target.feature.properties.NAME + \n    '&lt;/b&gt;&lt;br /&gt;' + \n    \"Bevolkerung: \" + e.target.feature.properties.Bevolkerung);\n}\nIn der obigen Funktion (showInfo(e)) verknüpfen wir mit unserer Geojson-Variable ein Popup-Objekt (Leaflet popup), in das wir einen Text sowie die Attribute NAME und Bevolkerung jedes der in unserem e.target-Objekt enthaltenen räumlichen Merkmale einbinden. In unserem Fall ist das e.target-Objekt die Variable kantons (gespeichert in der Datei kantons.js). (Mehr über e.target)\nAls nächsten Schritt verwenden wir die Funktion onEachFeature, um die Funktion showInfo(e) mit dem onclick-Listener zu verknüpfen. Dies ist die Standardfunktion zur Verknüpfung der JavaScript-Listener mit den jeweiligen Funktionen, die für die Ausführung einer bestimmten Aufgabe erstellt wurden. Wir hätten zum Beispiel eine andere Funktion definieren können, die jedes Mal aufgerufen wird, wenn wir den Mauszeiger über ein bestimmtes Element unserer HTML-Struktur bewegen. In unserem Fall definieren wir den onclick listener wie folgt:\nfunction onEachFeature(feature, layer) {\n    layer.on({\n        click: showInfo\n    });\n}\nDer letzte Schritt besteht darin, unsere GeoJSON-Ebene anzupassen, indem wir ihr die Option onEachFeature hinzufügen (L.geoJson documentation).\ngeojson = L.geoJson(kantons, {\n    style: style,\n    onEachFeature: onEachFeature\n}).addTo(map);\n\nNachdem Ihr Eure HTML-Struktur aktualisiert habt, speichert Eure Datei index.html und aktualisiert den Browser. Versucht nun auf der Karte herumzuklicken und schaut was passiert. Ihr solltet etwas ähnliches sehen wie Abbildung 65.8.\n\n\n\n\n\n\nAbbildung 65.8: Web Interaktive Choroplethenkarte mit den Kantonen der Schweiz (mit Interaktivität)",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-6-der-webkarte-eine-legende-hinzufügen",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-6-der-webkarte-eine-legende-hinzufügen",
    "title": "(Optional) Übung Leaflet",
    "section": "Übung 6: Der Webkarte eine Legende hinzufügen",
    "text": "Übung 6: Der Webkarte eine Legende hinzufügen\nUm eine Legende zu unserer Webkarte hinzuzufügen, werden wir JavaScript und CSS verwenden.\n\nVerwendet die beiden verbleibenden Dateien control.js und control.css (zu finden im Ordner data). Speichert diese beiden Dateien in Eurem Arbeitsverzeichnis (der Pfad, in dem sich auch index.html und kantons.js befinden)\nVerknüpft diese beiden Dateien mit Eurem Haupt-HTML-Dokument am Ende des Body-Abschnitts wie folgt.\n&lt;!-- Linking the js and css code for the legend --&gt;\n&lt;script src=\"control.js\"&gt;&lt;/script&gt;\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"control.css\"/&gt;\nSpeichert die Datei index.html und aktualisieren die Browserseite. Die Webseite sollte nun wie Abbildung 65.9 aussehen.\n\n\n\n\n\n\n\nAbbildung 65.9: Web Interaktive Choroplethenkarte mit den Kantonen der Schweiz (Endgültige Version)\n\n\n\nÖffnet die beiden Dateien, die Ihr zuletzt zur Karte hinzugefügt habt, und versucht, den darin enthaltenen Code zu interpretieren. Versucht, etwas zu ändern und seht anschliessend, wie sich diese Aktion auf Eure Karte auswirkt.\nGlückwunsch!! Ihr habt soeben Eure erste voll funktionsfähige interaktive Webkarte erstellt und dabei nur die grundlegenden Webtechnologien verwendet. Man könnte dieses HTML nun zum Beispiel über Netlify Drop Online zur Verfügung stellen.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#endgültige-lösung",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#endgültige-lösung",
    "title": "(Optional) Übung Leaflet",
    "section": "Endgültige Lösung",
    "text": "Endgültige Lösung\nindex.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.css\" integrity=\"sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=\" crossorigin=\"\" /&gt;\n        &lt;script src=\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.js\" integrity=\"sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=\" crossorigin=\"\"&gt;&lt;/script&gt;\n        &lt;script src=\"kantons.js\"&gt;&lt;/script&gt;\n        &lt;style&gt;\n            #map {position: absolute; top: 0; bottom: 0; left: 0; right: 0;}\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id = \"map\"&gt;&lt;/div&gt;\n        &lt;script&gt;\n            var map = L.map('map', {center: [46.944, 8.028],zoom: 8});\n            var geojson;\n            // function for coloring the cantons based on their population property\n            \n            function getColor(d) {\n                return d &gt; 1000000 ? '#084594' :\n                d &gt; 500000 ? '#2171b5' :\n                d &gt; 200000 ? '#4292c6' :\n                d &gt; 100000 ? '#6baed6' :\n                d &gt; 50000 ? '#9ecae1' :\n                d &gt; 20000 ? '#c6dbef' :\n                d &gt; 10000 ? '#deebf7' :\n                '#f7fbff';\n            }\n            \n            function style(feature) {\n                return {\n                    fillColor: getColor(feature.properties.Bevolkerung), // using the population property as argument\n                    weight: 2,\n                    opacity: 1,\n                    color: 'white',\n                    dashArray: '3',\n                    fillOpacity: 0.7\n               };\n           }\n           \n            function showInfo(e) {\n                geojson.bindPopup(\"Kanton: \" + \" \" + e.target.feature.properties.NAME + '&lt;/b&gt;&lt;br/&gt;' + \"Bevolkerung: \" + e.target.feature.properties.Bevolkerung);\n            }\n            \n            function onEachFeature(feature, layer) {\n                layer.on({\n                    click: showInfo\n                });\n            }\n            \n            L.tileLayer('https://api.maptiler.com/maps/streets-v2/256/{z}/{x}/{y}.png?key=4X87DmrzALHNsvjVPyhW', {attribution: '&lt;a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\"&gt;&copy; MapTiler&lt;/a&gt; &lt;a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\"&gt;&copy; OpenStreetMap contributors&lt;/a&gt;'}).addTo(map);\n\n            geojson = L.geoJson(kantons, {\n                style: style,\n                onEachFeature: onEachFeature\n            }).addTo(map);\n        &lt;/script&gt;\n        \n        &lt;!-- Linking the js and css code for the legend --&gt;\n        &lt;script src=\"control.js\"&gt;&lt;/script&gt;\n        &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"control.css\"/&gt;\n    &lt;/body&gt;\n&lt;/html&gt;",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  }
]