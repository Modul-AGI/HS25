{
  "hash": "0f302555f8d6a69f1bb5d5563276a264",
  "result": {
    "engine": "jupyter",
    "markdown": "# *Function* Basics {#sec-function-basics}\n\nEin Grundprinzip von Programmieren ist \"DRY\" (*Don't repeat yourself*). Wenn unser Script viele ähnliche Codezeilen enthält ist das ein Zeichen dafür, dass man besser eine *Function* schreiben sollte. Das hat viele Vorteile: Unter anderem wird der Code lesbarer, einfacher zu warten und kürzer. \n\nUm mit Python gut zurechtzukommen ist das Schreiben von eigenen *Functions* unerlässlich. Dies ist auch nicht weiter schwierig: Eine *Function* wird mit `def` eingeleitet, braucht einen Namen, einen Input und einen Output.\n\nWenn wir zum Beispiel eine Function erstellen wollen die uns grüsst, so geht dies folgendermassen:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef sag_hallo():\n    return \"Hallo!\"\n```\n:::\n\n\n- Mit `def` sagen wir: \"Jetzt definiere ich eine Function\". \n- Danach kommt der Name der *Function*, in unserem Fall `sag_hallo` (mit diesem Namen können wir die *Function* später wieder aufrufen). \n- Als Drittes kommen die runden Klammern, wo wir bei Bedarf Inputvariablen (sogenannte Parameter) festlegen können. In diesem ersten Beispiel habe ich keine Parameter festgelegt.\n- Nach der Klammer kommt ein Doppelpunkt was bedeutet: \"jetzt wird gleich definiert, was die Funktion tun soll\".\n- Auf einer neuen Zeile wird eingerückt festgelegt, was die Function eben tun soll. Meist sind hier ein paar Zeilen Code vorhanden.\n- Die letzte eingerückte Zeile (in unserem Fall ist das die einzige Zeile) gibt mit `return` an, was die *Function* zurück geben soll (der Output). In unserem Fall soll sie \"Hallo!\" zurück geben.\n\nDas war’s schon! Jetzt können wir diese *Function* schon nutzen:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nsag_hallo()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n'Hallo!'\n```\n:::\n:::\n\n\nDiese *Function* ohne Input ist wenig nützlich. Meist wollen wir der *Function* etwas - einen Input - übergeben können. Beispielsweise könnten wir der *Function* unseren Vornamen übergeben, damit wir persönlich gegrüsst werden:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef sag_hallo(vorname):\n    return \"Hallo \" + vorname + \"!\" \n```\n:::\n\n\nNun können wir der Function ein Argument übergeben. In folgendem Beispiel ist `vorname` ein Parameter, \"Guido\" ist sein Argument.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nsag_hallo(vorname = \"Guido\")\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n'Hallo Guido!'\n```\n:::\n:::\n\n\nWir können auch eine *Function* gestalten, die mehrere Parameter annimmt. Beispielweise könnte `sag_hallo()` zusätzlich noch einen Parameter `nachname` erwarten:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef sag_hallo(vorname, nachname):\n    return \"Hallo \" + vorname + \" \" + nachname + \"!\" \n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nsag_hallo(vorname = \"Guido\", nachname = \"van Rossum\")\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n'Hallo Guido van Rossum!'\n```\n:::\n:::\n\n\n",
    "supporting": [
      "4_Functions_I_files/figure-pdf"
    ],
    "filters": []
  }
}