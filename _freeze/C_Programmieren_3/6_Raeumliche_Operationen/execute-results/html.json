{
  "hash": "6e66a7782d1ee8a1a190675b99487277",
  "result": {
    "engine": "jupyter",
    "markdown": "# Räumliche Operationen {#sec-raeumliche-operationen}\n\nWas bringt uns diese *Geo* Erweiterung? Mit *GeoDataFrames* sind nun alle räumliche Operationen möglich, die wir bereits aus ArcGIS kennen aber mit einfachen *DataFrames* noch nicht möglich waren. Ich möchte dies an ein paar Beispielen demonstrieren. Dazu müssen wir die Zeckenstiche in GeoDataFrame konvertiert und in ein Geopackage exportiert haben, wie in @sec-pythongis beschrieben.\n\n::: {#f567b923 .cell execution_count=1}\n``` {.python .cell-code}\nimport geopandas as gpd\n\nzeckenstiche = gpd.read_file(\"data/zeckenstiche.gpkg\")\n```\n:::\n\n\n:::{.callout-note}\n\n- Die verschiedenen räumlichen Operationen in Geopandas erwarten unterschiedlichen Input, deshalb müssen wir manchmal zwischen *Geometrien*, *Geoseries* und *GeoDataFrames* hin und her konvertieren (siehe @sec-pythongis-datenstruktur). \n- Welcher Datentyp eure Operation *braucht*, seht ihr in [der Dokumentation](https://geopandas.org/). Welcher Datentyp ihr *habt*, seht ihr mit `type()`.\n- Um ein Objekt von einem Format in das andere zu konvertieren (angenommen das Objekt heisst `x`), braucht ihr folgenden Code:\n\n::: {#b093f9e0 .cell execution_count=2}\n``` {.python .cell-code}\n# von GeoDataFrame zu Geoseries:\nzecken_geoseries = gpd.GeoSeries(zeckenstiche[\"geometry\"])          \n\n# von GeoSeries zurück zu GeoDataFrame:\nzecken_geodataframe = gpd.GeoDataFrame(geometry = zecken_geoseries) \n```\n:::\n\n\n:::\n\n## Buffer\n\nEine typische GIS-Operation ist das \"Buffern\" von Objekten. Der ArcGIS Befehl [\"Buffer\"](https://pro.arcgis.com/en/pro-app/tool-reference/analysis/buffer.htm) erreichen wir in Geopandas mit `.buffer()`. Folgender Code macht einen Buffer mit einer Distanz von 10m. \n\n::: {#44103b85 .cell execution_count=3}\n``` {.python .cell-code}\nbuffered = zeckenstiche.buffer(10) \n```\n:::\n\n\nUm Geopandas-Objekte zu plotten, kann man einfach `.plot()` verwenden. Zudem kann man mit `boundary` die Umrisse eines Polygons extrahieren:\n\n::: {#49f418a4 .cell execution_count=4}\n``` {.python .cell-code}\nbase = buffered.boundary.plot() # plottet die boundries    \n\nzeckenstiche.plot(ax = base, color = \"black\") # plottet die Punkte\n```\n\n::: {.cell-output .cell-output-display}\n![](6_Raeumliche_Operationen_files/figure-html/cell-5-output-1.png){width=431 height=442}\n:::\n:::\n\n\n## Union\n\nMit `unary_union` können wir aus unserer *Point*-Geometrie ein *MultiPoint* erstellen (siehe @sec-pythongis-datenstruktur). Dieser Befehl lautet in ArcGIS [Union](https://pro.arcgis.com/de/pro-app/latest/tool-reference/analysis/union.htm).\n\n::: {#d8111513 .cell execution_count=5}\n``` {.python .cell-code}\nzeckenstiche_union = zeckenstiche[\"geometry\"].unary_union\n\ntype(zeckenstiche_union) # Es handelt sich nun um den Typ \"MultiPoint\"\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nshapely.geometry.multipoint.MultiPoint\n```\n:::\n:::\n\n\nWenn wir uns `zeckenstiche_union` nun mit `print` anschauen sehen wir, dass sämtliche Koordinaten in einem Objekt zusammengepackt sind: \n\n::: {#11d16138 .cell execution_count=6}\n``` {.python .cell-code}\nprint(zeckenstiche_union)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMULTIPOINT ((2681092 1250672), (2681107 1250712), (2681111 1250683), (2681116 1250648), (2681117 1250725), (2681124 1250720), (2681128 1250683), (2681131 1250692), (2681138 1250725), (2681171 1250711))\n```\n:::\n:::\n\n\n## Minimum Bounding Geometry {#sec-raeumliche-operationen-mbg}\n\nÜber ein *MultiPoint* lassen sich jetzt wunderbar sogenannte (in ESRI Terminologie) [Minimum Bounding Geometries](https://pro.arcgis.com/de/pro-app/tool-reference/data-management/minimum-bounding-geometry.htm) rechnen. Mit den gleichnamigen Funktionen können wir nun eine `convex_hull` [^convex-hull] sowie eine `envelope` [^envelope] über alle Punkte rechnen.\n\n[^convex-hull]:  Convex Hull stellt ein \"Rahmen\" um alle Punkte dar, wo alle Innenwinkel kleiner sind als 180° (*konvex*)\n[^envelope]: Envelope stellt ebenfalls ein \"Rahmen um alle Punkte dar, die aber quadratisch geformt und am Koordiatensystem ausgerichtet ist.\n\n::: {#d0d1b490 .cell execution_count=7}\n``` {.python .cell-code}\nmy_convex_hull = zeckenstiche_union.convex_hull\nmy_envelope = zeckenstiche_union.envelope\n```\n:::\n\n\nNun konvertiere ich beide Polygon-Geometrien in *GeoSeries*, damit sie einfacher zu visualisieren sind:\n\n::: {#1642bb63 .cell execution_count=8}\n``` {.python .cell-code}\nmy_convex_hull = gpd.GeoSeries(my_convex_hull)\nmy_envelope = gpd.GeoSeries(my_envelope)\n```\n:::\n\n\nUm die beiden Objekte nebeneinander zu visualisieren, importiere ich zuerst `pyplot` aus `matplotlib` (mit dem alias `plt`) und erstelle `subplots`\n\n::: {#d81a7f33 .cell execution_count=9}\n``` {.python .cell-code}\nfrom matplotlib import pyplot as plt\nfig, (ax1, ax2) = plt.subplots(1, 2,sharex=True, sharey = True,figsize = (9, 9))\n\n# Erstellt den linken Plot\nmy_convex_hull.plot(ax = ax1)\nax1.set_title(\"Convex Hull\")\nzeckenstiche.plot(ax = ax1, color = \"black\")\n\n# Erstellt den rechten Plot\nmy_envelope.plot(ax = ax2)\nax2.set_title(\"Envelope\")\nzeckenstiche.plot(ax = ax2, color = \"black\")\n```\n\n::: {.cell-output .cell-output-display}\n![](6_Raeumliche_Operationen_files/figure-html/cell-10-output-1.png){width=724 height=375}\n:::\n:::\n\n\n## Overlay\n\nViele der Funktionen aus dem ESRI Toolset [\"Overlay\"](https://pro.arcgis.com/de/pro-app/tool-reference/analysis/an-overview-of-the-overlay-toolset.htm) sind in der *Geopandas* Funktion `overlay` verpackt. Um sie zu demonstrieren nutze ich die Geometrien, die wir in weiter oben erstellt haben (`buffered` und `my_convex_hull`). Zuerst muss ich sie aber noch von *GeoSeries* in *GeoDataFrames* konvertieren.\n\n::: {#fd22e3aa .cell execution_count=10}\n``` {.python .cell-code}\nbuffered_gdf = gpd.GeoDataFrame(geometry = buffered, crs = 2056)               \nmy_convex_hull_gdf = gpd.GeoDataFrame(geometry = my_convex_hull, crs = 2056) \n```\n:::\n\n\nNun kann ich beispielsweise die Overlay-Funktion `difference` ausführen:\n\n::: {#01224c47 .cell execution_count=11}\n``` {.python .cell-code}\nmy_difference = gpd.overlay(my_convex_hull_gdf,buffered_gdf, how='difference')\n```\n:::\n\n\n::: {#81cd30bc .cell .column-page execution_count=12}\n``` {.python .cell-code}\n# Bereitet die drei Subplots vor ################\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, sharex=True, sharey = True, figsize = (18,9))\n#################################################\n\n# Plot links ####################################\nmy_convex_hull_gdf.plot(ax = ax1)               #\nax1.set_title(\"1. Das Minimum Convex Polygon\")  # \nax1.set_axis_off()                              #\n# Plot mitte ####################################\nbuffered_gdf.plot(ax = ax2)                     #\nax2.set_title(\"2. Die gebufferten Punkte\")      # \nax2.set_axis_off()                              #\n# Plot rechts ###################################\nmy_difference.plot(ax = ax3)                    #\nax3.set_title(\"Differenz aus 1. & 2.\")          # \nax3.set_axis_off()                              #\n#################################################\n```\n\n::: {.cell-output .cell-output-display}\n![](6_Raeumliche_Operationen_files/figure-html/cell-13-output-1.png){width=1358 height=425}\n:::\n:::\n\n\n",
    "supporting": [
      "6_Raeumliche_Operationen_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}