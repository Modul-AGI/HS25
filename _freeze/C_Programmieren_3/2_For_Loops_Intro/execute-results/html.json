{
  "hash": "8801c72f6ce131ba3481acebd455053b",
  "result": {
    "engine": "jupyter",
    "markdown": "# Einführung in *for loop*  {#sec-forloops-1}\n\n## Die Grundform\nNirgends ist der Aspekt der Automatisierung so sichtbar wie in *for loops*. Loops sind \"Schleifen\" wo eine Aufgabe beliebig lange wiederholt wird. Auch *for loops* sind im Grunde genommen simple. Auf den ersten Blick sieht eine *for loop* aus wie eine *Function* definition (siehe @sec-function-basics und @sec-function-advanced). Im folgenden Beispiel seht ihr ein minimales Beispiel einer *for loop*.\n\n::: {#f8a39f08 .cell execution_count=1}\n``` {.python .cell-code}\nfor platzhalter in [0,1,2]:\n    print(\"Iteration\",platzhalter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIteration 0\nIteration 1\nIteration 2\n```\n:::\n:::\n\n\n- `for` legt fest, dass eine For-Loop beginnt\n- Nach `for` kommt eine Platzhalter-Variabel, die ihr beliebig benennen könnt. Im obigen Beispiel lautet diese `platzhalter`\n- Nach dem Platzhalter kommt der Begriff `in`. Dieser Begriff kommt zwingend nach dem Platzhalter.\n- Nach `in` wird der \"Iterator\" festgelegt, also worüber der For-Loop iterieren soll (hier: über eine `List` mit den Werten `[0,1,2]`). \n- Danach kommt ein Doppelpunkt `:` der zeigt: \"Nun legen wir gleich fest was im For-Loop passieren soll\" (ähnlich wie in einer *Function*)\n- Auf einer neuen Zeile wird eingerückt festgelegt, was in der *For-Loop* passieren soll. Dieser Teil kann beliebig lange sein, ein *for loop* ist dann fertig, wenn man nicht mehr eingerückt wird. In unserem Fall wird mit `print`[^print] etwas in die Konsole ausgegeben.\n- Achtung: `return()` gibt’s in For-Loops nicht!\n\n[^print]: Mit `print` können wir Variabeln in die Konsole \"ausdrucken\" lassen. Innerhalb von `print` können dazu verschiedene Variablen kommagetrennt aufgeführt werden, ohne sie mit `+` verbinden zu müssen wie damals in @sec-function-basics.\n\n## Der Iterator\n\nIm obigen Beispiel haben wir über eine *List* iteriert, wir haben also eine Liste als Iterator verwendet. Es gibt aber noch andere \"Dinge\", über die wir iterieren können. Angenommen wir wollen den gleichen *for loop* mit den Zahlen von 0 bis 100 oder 100 bis 1'000 durchführen. Es wäre ganz schön mühsam, alle Zahlen von 0 bis 100 manuell in einer Liste zu erfassen. Zu diesem Zweck können wir die Funktion `range` verwenden. Mit `range(3)` erstellen wir einen Iterator mit den Werten 0, 1 und 2. Mit `range(100,1001)` erhalten wir die Werte von 100 bis 1'000. \n\nDer gleiche *loop* wie oben lautet mit `range` folgendermassen:\n\n::: {#d9ccf4e1 .cell execution_count=2}\n``` {.python .cell-code}\nfor platzhalter in range(3):\n    print(\"Iteration\",platzhalter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIteration 0\nIteration 1\nIteration 2\n```\n:::\n:::\n\n\n## Der Platzhalter\n\nDie Platzhaltervariabel liegt immer zwischen `for` und `in`, den Namen dieser Variabel könnt ihr frei wählen. Ich habe sie im obigen Beispiel `platzhalter` genannt. Speziell an dieser Variabel ist, dass sie während der Dauer des *Loops* ihren Wert verändert. Mehr dazu in @sec-forloops-2.\n\n",
    "supporting": [
      "2_For_Loops_Intro_files"
    ],
    "filters": [],
    "includes": {}
  }
}