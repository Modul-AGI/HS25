{
  "hash": "92cee8dc94c668e3667b1c0ad1de9ac8",
  "result": {
    "engine": "jupyter",
    "markdown": "---\noutput: false\necho: true                       # set to true to show solution\ncode-fold: true                  # set to true to show solution\ncode-summary: \"Musterlösung\"    \n---\n\n## Übung 12\n\n## Übung  12.1\n\nErstelle zwei Listen bestehend aus 3 Hundenamen (`hunde`) und 3 Katzennamen (`katzen`). Erstelle einen verschachtelten *For Loop*, wo jeder Hund jede Katze beisst und jede Katze jeden Hund kratzt.\n\n```python\nBruno beisst Greta und Greta kratzt  Bruno\nBerta beisst Greta und Greta kratzt  Berta\nHelmi beisst Greta und Greta kratzt  Helmi\n....\n```\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nhunde = [\"Bruno\", \"Berta\",\"Helmi\"]\nkatzen = [\"Greta\", \"Xavier\", \"Zachy\"]\n\nfor katze in katzen:\n    for hund in hunde:\n        print(hund, \"beisst\", katze+\" und \"+katze, \"kratzt \", hund)\n```\n:::\n\n\n<!-- % Nested Loop: Multiplikation -->\n## Übung  12.2 \n\nErstelle einen verschachtelten Loop, wo alle Kombinationen von 0 bis 9 miteinander addiert werden.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\naddition = []\n\nwerte = range(10)\n\nfor i in werte:\n    for j in werte:\n        resultat = i+j\n        addition.append(resultat)\n```\n:::\n\n\n## Übung  12.3 \n\nNutze die Funktion `offset_coordinate` (Lösung aus [Übung 8.5](#sec-ex-offset-function)) um einen Punkt in einem Koordinatensystem zu verschieben. Diesmal soll der Punkt aber nicht nur 1x, sondern 100x verschoben werden (100 Simulationen).\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport random\n\ndef offset_coordinate(old, distance = 100):\n    new = old + random.normalvariate(0, distance)\n    return new\n\nx_start = 0\ny_start = 0\n\nx_random = []\ny_random = []\nfor i in range(100):\n    x_new = offset_coordinate(x_start)\n    y_new = offset_coordinate(y_start)\n\n    x_random.append(x_new)\n    y_random.append(y_new)\n```\n:::\n\n\n## Übung  12.4 (fakultativ)\n\nVersuche die Monte Carlo Simulation für die Annäherung an Pi (aus der ersten Übung \"Datenqualität und Unsicherheit) mit einer Funktion und einem For Loop zu lösen.\n\nZur Erinnerung, die Vorgehensweise für die Annäherung an Pi geht folgendermassen:\n\n1. Zufallskoordinaten (`x`, `y`) zwischen 0 und 1 erstellen\n2. Distanz zum Ursprung (0) mit der Formel $\\sqrt(x^2+y^2)$ berechnen\n3. Bestimmen ob sich der Punkt innerhalb des Kreisviertels befindet ($d < 1$)\n4. Schritte 1 & 2 mehrfach wiederholen\n5. Anteil der Punkte *innerhalb* des Kreisviertels mit 4 Multiplizieren\n\nTipps:\n\n- Für die Erstellung der Zufallspunkte brauchst du die Funktion `random()` aus dem modul `random`\n- Schritte 1 - 3 werden am sinnvollsten ein eine Funktion verpakt, welche keine Argumente benötigt\n- Schritt 4 löst du am besten mit einer `For loop` mit `range(100)` (für 100 Wiederholungen)\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nimport random\n\n# erstelle eine Funktion, die zwei Zufallszahlen zwischen 0 und 1 generiert,\n# die Distanz zum Ursprung (0,0) berechnet und True retourniert, wenn der Wert ausserhalb des Kreisviertels liegt\ndef get_pi(): \n    x = random.random()\n    y = random.random()\n    pythagoras = (x**2+y**2)**0.5\n    ausserhalb = pythagoras > 1\n    return ausserhalb\n\nget_pi()\n\n# die Funktion 100x wiederholen und die Anzahl Werte > 1 zählen\nres = [get_pi() for x in range(100)]\n\n# Anteil der Werte > 1 berechnen und mit 4 multiplizieren\n(100-sum(res))/100*4\n```\n:::\n\n\n",
    "supporting": [
      "4_Uebung_12_files"
    ],
    "filters": []
  }
}