{
  "hash": "393585477e91ef738a4500ac16650d80",
  "result": {
    "engine": "jupyter",
    "markdown": "# Räumliche Operationen {#sec-raeumliche-operationen}\n\nWas bringt uns diese *Geo* Erweiterung? Mit *GeoDataFrames* sind nun alle räumliche Operationen möglich, die wir bereits aus ArcGIS kennen aber mit einfachen *DataFrames* noch nicht möglich waren. Ich möchte dies an ein paar Beispielen Demonstrieren. Dazu müssen wir die Zeckenstiche in GeoDataFrame konvertiert und in ein Geopackage exportiert haben, wie in @sec-pythongis beschrieben.\n\n::: {#4db4f011 .cell execution_count=1}\n``` {.python .cell-code}\nimport geopandas as gpd\n\nzeckenstiche = gpd.read_file(\"data/zeckenstiche.gpkg\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nModuleNotFoundError: No module named 'geopandas'\n```\n:::\n:::\n\n\n:::{.callout-note}\n\n- Die verschiedenen räumlichen Operationen in Geopandas erwarten unterschiedlichen Input, deshalb müssen wir manchmal zwischen *Geometrien*, *Geoseries* und *GeoDataFrames* hin- und her konvertieren (siehe @sec-pythongis-datenstruktur). \n- Welcher Datentyp eure Operation *braucht* seht ihr in [der Dokumentation](https://geopandas.org/). Welcher Datentyp ihr *habt* seht ihr mit `type()`.\n- Um ein Objekt von einem Format in das andere zu konvertieren (angenommen das Objekt heisst `x`)\n\n::: {#f9f8895e .cell execution_count=2}\n``` {.python .cell-code}\n# von GeoDataFrame zu Geoseries:\nzecken_geoseries = gpd.GeoSeries(zeckenstiche[\"geometry\"])          \n\n# von GeoSeries zurück zu GeoDataFrame:\nzecken_geodataframe = gpd.GeoDataFrame(geometry = zecken_geoseries) \n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'gpd' is not defined\n```\n:::\n:::\n\n\n:::\n\n## Buffer\n\nEine typische GIS Operation ist das \"Buffern\" von Objekten. Der ArcGIS Befehl [\"Buffer\"](https://pro.arcgis.com/en/pro-app/tool-reference/analysis/buffer.htm) erreichen wir in Geopandas mit `.buffer()`. Folgender Code macht einen Buffer mit einer Distanz von 10m. \n\n::: {#1a895dbe .cell execution_count=3}\n``` {.python .cell-code}\nbuffered = zeckenstiche.buffer(10) \n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'zeckenstiche' is not defined\n```\n:::\n:::\n\n\nUm Geopandas-Objekte zu plotten kann man einfach `.plot()` verwenden. Zudem kann man mit `boundary` die Umrisse eines Polygons extrahieren:\n\n::: {#c8da91b0 .cell execution_count=4}\n``` {.python .cell-code}\nbase = buffered.boundary.plot() # plottet die boundries    \n\nzeckenstiche.plot(ax = base, color = \"black\") # plottet die Punkte\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'buffered' is not defined\n```\n:::\n:::\n\n\n## Union\n\nMit `unary_union` können wir aus unserer *Point*-Geometrie ein *MultiPoint* erstellen (siehe @sec-pythongis-datenstruktur). Dieser Befehl lautet in ArcGIS [Union](https://desktop.arcgis.com/de/arcmap/10.3/tools/analysis-toolbox/union.htm).\n\n::: {#6e4ceb0b .cell execution_count=5}\n``` {.python .cell-code}\nzeckenstiche_union = zeckenstiche[\"geometry\"].unary_union\n\ntype(zeckenstiche_union) # Es handelt sich nun um den Typ \"MultiPoint\"\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'zeckenstiche' is not defined\n```\n:::\n:::\n\n\nWenn wir uns `zeckenstiche_union` nun mit `print` anschauen sehen wir, dass sämtliche Koordinaten in einem Objekt zusammengepackt sind: \n\n::: {#f73a55c7 .cell execution_count=6}\n``` {.python .cell-code}\nprint(zeckenstiche_union)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'zeckenstiche_union' is not defined\n```\n:::\n:::\n\n\n## Minimum Bounding Geometry {#sec-raeumliche-operationen-mbg}\n\nÜber ein *MultiPoint* lassen sich jetzt wunderbar sogenannte (in ESRI Terminologie) [Minimum Bounding Geometries](https://pro.arcgis.com/de/pro-app/tool-reference/data-management/minimum-bounding-geometry.htm) rechnen. Mit den gleichnamigen Funktionen können wir nun eine `convex_hull` [^convex-hull] sowie eine `envelope` [^envelope] über alle Punkte rechnen.\n\n[^convex-hull]:  Convex Hull stellt ein \"Rahmen\" um alle Punkte dar, wo alle Innenwinkel kleiner sind als 180° (*konvex*)\n[^envelope]: Envelope stellt ebenfalls ein \"Rahmen um alle Punkte dar, die aber quadratisch geformt und am Koordiatensystem ausgerichtet ist.\n\n::: {#d8c3dc66 .cell execution_count=7}\n``` {.python .cell-code}\nmy_convex_hull = zeckenstiche_union.convex_hull\nmy_envelope = zeckenstiche_union.envelope\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'zeckenstiche_union' is not defined\n```\n:::\n:::\n\n\nNun konvertiere ich beide Polygon-Geometrien in *GeoSeries*, damit sie einfacher zu visualisieren sind:\n\n::: {#c170af56 .cell execution_count=8}\n``` {.python .cell-code}\nmy_convex_hull = gpd.GeoSeries(my_convex_hull)\nmy_envelope = gpd.GeoSeries(my_envelope)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'gpd' is not defined\n```\n:::\n:::\n\n\nUm die beiden Objekte nebeneinander zu visualisieren importiere ich zuerst `pyplot` aus `matplotlib` (mit dem alias `plt`) und erstelle `subplots`\n\n::: {#e7af5cca .cell execution_count=9}\n``` {.python .cell-code}\nfrom matplotlib import pyplot as plt\nfig, (ax1, ax2) = plt.subplots(1, 2,sharex=True, sharey = True,figsize = (9, 9))\n\n# Erstellt den linken Plot\nmy_convex_hull.plot(ax = ax1)\nax1.set_title(\"Convex Hull\")\nzeckenstiche.plot(ax = ax1, color = \"black\")\n\n# Erstellt den rechten Plot\nmy_envelope.plot(ax = ax2)\nax2.set_title(\"Envelope\")\nzeckenstiche.plot(ax = ax2, color = \"black\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nModuleNotFoundError: No module named 'matplotlib'\n```\n:::\n:::\n\n\n## Overlay\n\nViele der Funktionen aus dem ESRI Toolset [\"Overlay\"](https://pro.arcgis.com/de/pro-app/tool-reference/analysis/an-overview-of-the-overlay-toolset.htm) sind in der *Geopandas* Funktion `overlay` verpackt. Um sie zu demonstrieren nutze ich die Geometrien, die wir in weiter oben erstellt haben (`buffered` und `my_convex_hull`). Zuerst muss ich sie aber noch von *GeoSeries* in *GeoDataFrames* konverieren.\n\n::: {#6fdd5be8 .cell execution_count=10}\n``` {.python .cell-code}\nbuffered_gdf = gpd.GeoDataFrame(geometry = buffered, crs = 2056)               \nmy_convex_hull_gdf = gpd.GeoDataFrame(geometry = my_convex_hull, crs = 2056) \n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'gpd' is not defined\n```\n:::\n:::\n\n\nNun kann ich zum beispielsweise die Overlay-Funktion `difference` ausführen:\n\n::: {#e5a873fe .cell execution_count=11}\n``` {.python .cell-code}\nmy_difference = gpd.overlay(my_convex_hull_gdf,buffered_gdf, how='difference')\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'gpd' is not defined\n```\n:::\n:::\n\n\n::: {#1192a8b1 .cell execution_count=12}\n``` {.python .cell-code}\n# Bereitet die drei Subplots vor ################\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, sharex=True, sharey = True, figsize = (9,9))\n#################################################\n\n# Plot links ####################################\nmy_convex_hull_gdf.plot(ax = ax1)               #\nax1.set_title(\"1. Das Minimum Convex Polygon\")  # \nax1.set_axis_off()                              #\n# Plot mitte ####################################\nbuffered_gdf.plot(ax = ax2)                     #\nax2.set_title(\"2. Die gebufferten Punkte\")      # \nax2.set_axis_off()                              #\n# Plot rechts ###################################\nmy_difference.plot(ax = ax3)                    #\nax3.set_title(\"Differenz aus 1. & 2.\")          # \nax3.set_axis_off()                              #\n#################################################\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'plt' is not defined\n```\n:::\n:::\n\n\n",
    "supporting": [
      "6_Raeumliche_Operationen_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}