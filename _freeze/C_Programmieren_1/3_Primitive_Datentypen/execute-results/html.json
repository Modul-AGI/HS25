{
  "hash": "33bff2863e7163fb730019933db90b64",
  "result": {
    "engine": "jupyter",
    "markdown": "# Primitive Datentypen\n\nBei primitiven Datentypen handelt es sich um die kleinste Einheit der Programmiersprache, sie werden deshalb auch \"atomare Datentypen\" genannt. Alle komplexeren Datentypen (Tabellarische Daten, Bilder, Geodaten) basieren auf diesen einfachen Strukturen. Die für uns wichtigsten Datentypen lauten: *Boolean*, *String*, *Integer* und *Float*. Das sind ähnliche Datentypen wie ihr bereits aus R kennt:\n\n| Python | R | Beschreibung | Beispiel | in Python | \n|:---|:---|:---|:---|:---|\n| Boolean | Logical | Logische Werte ja / nein | Wahr / Falsch | `regen = True` |\n| String | Character | Textinformation | Bern, Luzern | `stadt = \"Bern\"` |\n| Integer | Integer | Zahl ohne Nachkommastelle | Anzahl Einwohner | `bern = 133115` |\n| Float | Double | Zahl mit Nachkommastelle | Temperatur | `temp = 22.5` |\n\n\n:::{#tip-positron-project .callout-tip}\n\n:::\n\n\n## Boolean\n\nHierbei handelt es sich um den einfachsten Datentyp. Er beinhaltet nur zwei Zustände: *Wahr* oder *Falsch*. In Python werden diese mit `True` oder `False` definiert (diese Schreibweise muss genau beachtet werden). Beispielsweise sind das Antworten auf geschlossene Fragen.\n\n::: {#5236b666 .cell execution_count=1}\n``` {.python .cell-code}\nregen = True # \"es regnet\"\n\nsonne = False # \"die Sonne scheint nicht\"\n\ntype(sonne)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nbool\n```\n:::\n:::\n\n\nUm zu prüfen, ob ein bestimmter Wert `True` oder `False` ist, verwendet man `is True`. Will man also fragen, ob es regnet, wird dies folgendermassen formuliert:\n\n::: {#3484e5fb .cell execution_count=2}\n``` {.python .cell-code}\n# regnet es?\nregen is True\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nTrue\n```\n:::\n:::\n\n\nOb die Sonne scheint, lautet folgendermassen (natürlich müssen dazu die Variabel `sonne` bereits existieren):\n\n::: {#d2b5170a .cell execution_count=3}\n``` {.python .cell-code}\n# scheint die Sonne?\nsonne is True\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nFalse\n```\n:::\n:::\n\n\n## String\n\nIn sogenannten *Strings* werden Textinformationen gespeichert. Beispielsweise können das die Namen von Ortschaften sein.\n\n::: {#d83bb189 .cell execution_count=4}\n``` {.python .cell-code}\nstadt = \"Bern\"\nland = \"Schweiz\"\n\ntype(stadt)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nstr\n```\n:::\n:::\n\n\nStrings können mit `+` miteinander verbunden werden\n\n::: {#84858d6f .cell execution_count=5}\n``` {.python .cell-code}\nstadt + \" ist die Hauptstadt der \" + land\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n'Bern ist die Hauptstadt der Schweiz'\n```\n:::\n:::\n\n\n## Integer\n\nIn *Integer* werden ganzzahlige Werte gespeichert, beispielsweise die Anzahl Einwohner einer Stadt. \n\n::: {#9a3bb530 .cell execution_count=6}\n``` {.python .cell-code}\nbern_einwohner = 133115\n\ntype(bern_einwohner)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nint\n```\n:::\n:::\n\n\n## Float\n\nAls *Float* werden Zahlen mit Nachkommastellen gespeichert, wie zum Beispiel die Temperatur in Grad Celsius.\n\n::: {#60c5f21d .cell execution_count=7}\n``` {.python .cell-code}\nbern_flaeche = 51.62\n\ntype(bern_flaeche)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nfloat\n```\n:::\n:::\n\n\n",
    "supporting": [
      "3_Primitive_Datentypen_files"
    ],
    "filters": [],
    "includes": {}
  }
}