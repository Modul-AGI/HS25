{
  "hash": "cf1c465a58022cf9a5ae3914e7f8f848",
  "result": {
    "engine": "jupyter",
    "markdown": "# Komplexe Datentypen\n\nIm letzten Kapitel haben wir primitive Datentypen angeschaut. Diese stellen eine gute Basis dar, in der Praxis haben wir aber meistens nicht *einen* Temperaturwert, sondern eine Liste von Temperaturwerten. Wir haben nicht *einen* Vornamen, sondern eine Tabelle mit Vor- und Nachnamen. Dafür gibt es in Python komplexere Datenstrukturen die als Gefässe für primitive Datentypen betrachtet werden können.  Auch hier finden wir viele Ähnlichkeiten mit R:\n\n| Python | R | Beschreibung | Beispiel | \n|:---|:---|:---|:---|:---|\n| List | (Vector) | werden über die Position abgerufen | Beachtet die eckigen Klammern: `hexerei = [3,2,1]` |\n| Dict | List | werden über ein Schlüsselwort abgerufen | Beachtet die geschweiften Klammern: `langenscheidt = {\"trump\":\"erdichten\"}` |\n| DataFrame | Dataframe | Tabellarische Daten | Spezialfall einer `dict` `pd.DataFrame({\"x\":[1,2,3], \"y\": [3,4,5]}` |\n\nIn Python gibt es noch weitere komplexe Datentypen wie *Tuples* und *Sets*. Diese spielen in unserem Kurs aber eine untergeordnete Rolle. Ich erwähne an dieser Stelle zwei häufig genannte Typen, damit ihr sie schon mal gehört habt:\n\n- *Tuples*: \n  - sind ähnlich wie *Lists*, nur können sie nachträglich nicht verändert werden. Das heisst, es ist nach der Erstellung keine Ergänzung von neuen Werten oder Löschung von bestehenden Werten möglich.\n  - sie werden mit runden Klammern erstellt: `mytuple = (2,2,1)`\n- *Sets*\n  - sind ähnlich wie *Dicts*, verfügen aber nicht über `keys` und `values`\n  - jeder Wert wird nur 1x gespeichert (Duplikate werden automatisch entfernt)\n  - sie werden mit geschweiften Klammern erstellt: `myset = {3,2,2}`\n\nWohl das einfachste Gefäss, um mehrere Werte zu speichern, sind Python-Listen, sogenannte *Lists*. Diese *Lists* werden mit eckigen Klammern erstellt. Die Reihenfolge, in denen die Werte angegeben werden, wird gespeichert. Das erlaubt es uns, bestimmte Werte aufgrund ihrer Position abzurufen. \n\nEine *List* wird folgendermassen erstellt:\n\n::: {#79a2ebdd .cell execution_count=1}\n``` {.python .cell-code}\nhexerei = [3,1,2]\n```\n:::\n\n\nDer erste Wert wird in Python mit `0` (!!!) aufgerufen:\n\n::: {#0606ca2a .cell execution_count=2}\n``` {.python .cell-code}\nhexerei[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n3\n```\n:::\n:::\n\n\n::: {#eab35608 .cell execution_count=3}\n``` {.python .cell-code}\ntype(hexerei)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nlist\n```\n:::\n:::\n\n\nIm Prinzip sind *Lists* ähnlich wie *Vectors* in R, mit dem Unterschied, dass in Python-Lists unterschiedliche Datentypen abgespeichert werden können. Zum Beispiel auch weitere, verschachtelte Lists:\n\n::: {#16c4bfa3 .cell execution_count=4}\n``` {.python .cell-code}\nchaos = [23, \"ja\", [1,2,3]]\n```\n:::\n\n\n::: {#8b4489dc .cell execution_count=5}\n``` {.python .cell-code}\n# Der Inhalt vom ersten Wert ist vom Typ \"Int\"\ntype(chaos[0])\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nint\n```\n:::\n:::\n\n\n::: {#5d5fd828 .cell execution_count=6}\n``` {.python .cell-code}\n# Der Inhalt vom dritten Wert ist vom Typ \"List\"\n\ntype(chaos[2])\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nlist\n```\n:::\n:::\n\n\n",
    "supporting": [
      "5_Komplexe_Datentypen_files"
    ],
    "filters": [],
    "includes": {}
  }
}