{
  "hash": "84f98b12f37b6ab948c89061a461e685",
  "result": {
    "engine": "jupyter",
    "markdown": "---\noutput: false\necho: false                      # set to true to show solution\ncode-fold: true\ncode-summary: \"Musterlösung\"    \n---\n\n# Übung 4\n\n## Übung 4.1\n\nImportiere `pandas` und nutze die Funktion `DataFrame`, um `people` in eine DataFrame umzuwandeln (siehe dazu das Beispiel unten). Weise den Output der Variablen `people_df` zu und schau dir `people_df` an.\n\n::: {#9bd07122 .cell execution_count=1}\n``` {.python .cell-code code-fold=\"false\"}\nimport pandas as pd\n\npeople = {\n  \"vornamen\": [\"Christopher\", \"Henning\", \"Severin\"], \n  \"nachnamen\": [\"Annen\",\"May\", \"Kantereit\"], \n  \"groessen\": [174, 182, 162]\n  }\n\n\npeople_df = pd.DataFrame(people)\n```\n:::\n\n\n## Übung 4.2 {#sec-ex-to-csv}\n\nIn der Praxis kommen tabellarische Daten meist als \"csv\" Dateien daher. Wir können aus unserer eben erstellten DataFrame sehr einfach eine csv-Datei erstellen. Führe das mit folgendem Code aus und suche anschliessend die erstellte csv-Datei.\n\n::: {#a06c8db2 .cell execution_count=2}\n``` {.python .cell-code code-fold=\"false\"}\npeople_df.to_csv(\"people.csv\")\n```\n:::\n\n\n<!-- :::{.callout-note}\n## Achtung!\n\nFalls ihr nicht wisst, wo das csv abgespeichet ist solltet ihr das Kapitel @sec-jupyternotebook nochmals durchlesen. \n\nDie *Working Directory* zu kennen ist wichtig, besonders auch für die nächste Aufgabe. Falls ihr die aktuelle Working Directory neu setzen und dafür JupyterLab schliessen müsst, denkt daran die Notebook vorgängig zu speichern und im File Explorer aufzusuchen.\n::: -->\n\n## Übung 4.3 {#sec-ex-import-zeckenstiche}\n\nGenau so einfach ist es, ein csv zu importieren. Lade die Datei \"zeckenstiche.csv\" (siehe @tbl-datensaetze) herunter und speichere es im aktuellen Arbeitsverzeichnis ab. Importiere mit folgendem Code die Datei \"zeckenstiche.csv\".\n\n::: {#c9a745b0 .cell execution_count=3}\n``` {.python .cell-code code-fold=\"false\"}\n# ich habe die Daten in einem Unterordner \"data\" abgespeichert\nzeckenstiche = pd.read_csv(\"data/zeckenstiche.csv\")\n```\n:::\n\n\n## Übung 4.4 {#sec-ex-scatterplot}\n\nDie *DataFrame* `zeckenstiche` beinhaltet x und y Koordinaten für jeden Unfall in den gleichnamigen Spalten. Wir können die Stiche mit einem Scatterplot räumlich visualisieren. Führe dazu folgenden Code aus. \n\n::: {#beb27e35 .cell execution_count=4}\n``` {.python .cell-code code-fold=\"false\"}\nfig = zeckenstiche.plot.scatter(\"x\",\"y\")\n\nfig.axis(\"equal\")\n# \"equal\" stellt sicher, das die x und y Achsen gleich skaliert sind\n# dies ist sinnvoll, da es sich ja um Schweizer Koordinaten (Meter) handelt\n```\n:::\n\n\n## Übung 4.5 {#sec-ex-sel-col}\n\nUm eine einzelne Spalte zu selektieren (z.B. die Spalte \"ID\"), kann man gleich vorgehen wie bei der Selektion eines Eintrags in einer *Dictionary*. Probiere es aus.\n\n\n\n## Übung 4.6 {#sec-ex-new-col}\n\nAuch das Erstellen einer neuen Spalte ist identisch mit der Erstellung eines neuen *Dictionary* Eintrags. Erstelle eine neue Spalte \"Stichtyp\" mit dem Wert \"Zecke\" auf jeder Zeile (s.u.).\n\n::: {#c283debb .cell execution_count=6}\n``` {.python .cell-code code-fold=\"false\"}\nzeckenstiche[\"Stichtyp\"] = \"Zecke\"\n```\n:::\n\n\n\n\n",
    "supporting": [
      "11_Uebung_4_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}