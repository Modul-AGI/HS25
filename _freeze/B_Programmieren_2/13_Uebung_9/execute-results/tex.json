{
  "hash": "a415501118013ad1a02bf89030f1c499",
  "result": {
    "engine": "jupyter",
    "markdown": "---\noutput: false\necho: true                       # set to true to show solution\ncode-fold: true                  # set to true to show solution\ncode-summary: \"Musterlösung\"    \n---\n\n# Übung 9\n\nFür diese Übung brauchen wir\n\n1. Die Python-Module `pandas` sowie `random`\n2. Die Funktion `offset_coordinate` aus @sec-ex-offset-function\n3. *zeckenstiche.csv* importiert als `pandas DataFrame` in der Variabel `zeckenstiche`\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"false\"}\nimport pandas as pd\nimport random\n\ndef offset_coordinate(old, distance = 100):\n    new = old + random.normalvariate(0, distance)\n    return new\n\nzeckenstiche = pd.read_csv(\"data/zeckenstiche.csv\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nModuleNotFoundError: No module named 'pandas'\n```\n:::\n:::\n\n\n## Übung 9.1\n\nMache dich nochmals damit vertraut, einzelne Spalten zu selektieren. Schau dir @sec-dataframes nochmals an wenn du nicht mehr weisst wie das geht.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nzeckenstiche[\"x\"]\nzeckenstiche[\"y\"]\n```\n:::\n\n\n<!-- % Neue Spalten erstellen -->\n## Übung 9.2\n\nMache dich nochmals damit vertraut, wie man neue Spalten erstellt. Schau dir @sec-dataframes nochmals an wenn du nicht mehr weisst wie das geht. Erstelle ein paar neue Spalten nach dem Beispiel unten um die Hangriffe zu üben. Lösche die Spalten im Anschluss wieder mit `del zeckenstiche['test1']` etc.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nzeckenstiche[\"test1\"] = \"test1\"\n\nzeckenstiche[\"test2\"] = 10\n\nzeckenstiche[\"test3\"] = range(10)\n```\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"false\"}\n# zeckenstiche könnte danach folgendermassen aussehen:\nzeckenstiche\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'zeckenstiche' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"false\"}\n# unnötigen Spalten wieder entfernen:\ndel zeckenstiche['test1']\ndel zeckenstiche['test2']\ndel zeckenstiche['test3']\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'zeckenstiche' is not defined\n```\n:::\n:::\n\n\n## Übung 9.3 {#sec-ex-apply}\n\n`pandas` kennt eine ganze Familie von Methoden, um Spalten zu Manipulieren und Daten zu Aggregieren (`apply`, `map`, `mapapply`, `assign`). Es würde den Rahmen dieses Kurses sprengen, die alle im Detail durchzugehen, es lohnt sich aber sehr sich mit diesen auseinanderzusetzen wenn man sich näher mit Python befassen möchte.\n\nIm unserem Fall brauchen wir lediglich die Methode `apply` um die Funktion `offset_coordinate()` auf die Zeckenstichkoordinaten anzuwenden. Dabei gehen wir wie folgt for:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"false\"}\nzeckenstiche[\"x\"].apply(offset_coordinate)\n#\\______1_______/ \\_2_/\\_______3_________/\n\n# 1. Spalte selektieren ([\"x\"])\n# 2. Methode \"apply\" aufrufen\n# 3. Function übergeben\n```\n:::\n\n\nVerwende dieses Schema um auch `offset_coordinate` auf die `y` Spalte anzuwenden und speichere den Output dieser beiden Operationen als neue Spalten `x_sim` sowie `y_sim`. Die *DataFrame* `zeckenstiche` sollte danach wie folgt aussehen:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nzeckenstiche[\"x_sim\"] = zeckenstiche[\"x\"].apply(offset_coordinate)\nzeckenstiche[\"y_sim\"] = zeckenstiche[\"y\"].apply(offset_coordinate)\n```\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code code-fold=\"false\"}\nzeckenstiche\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'zeckenstiche' is not defined\n```\n:::\n:::\n\n\n## Übung 9.4 {#sec-ex-param}\n\nIn @sec-ex-apply haben wir unsere Funktion `offset_coordinate` aufgerufen, ohne den Parameter `distance` zu spezifizieren. Dies war möglich, weil wir für `distance` einen Defaultwert festgelegt hatten (100 Meter). Wir können aber auch zusätzliche Parameter kommagetrennt nach der Funktion angeben. Dies sieht folgendermassen aus:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code code-fold=\"false\"}\nzeckenstiche[\"x\"].apply(offset_coordinate, distance = 200)\n```\n:::\n\n\nNutze diese Möglichkeit, um den Offset (`distance`) auf maximal 10 Meter zu reduzieren.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nzeckenstiche[\"x_sim\"] = zeckenstiche[\"x\"].apply(offset_coordinate, distance = 10)\nzeckenstiche[\"y_sim\"] = zeckenstiche[\"y\"].apply(offset_coordinate, distance = 10)\n```\n:::\n\n\n## Übung 9.5\n\nUm die Original `x`/`y`-Werte sowie die simulierten Daten im gleichen Plot darzustellen, wird folgendermassen vorgegangen: Der erste Datensatz wird mit `.plot()` visualisiert, wobei der Output einer Variabel  (z.B. `basemap`)  zugewiesen wird. Danach wird der zweite Datensatz ebenfalls mit `.plot()` visualisiert, wobei auf den ersten Plot via dem Argument `ax` verwiesen wird.\n\nBei den roten Punkten handelt es sich um die Original-Zeckenstichen, bei den blauen um die simulierten (leicht verschoben) Zeckenstiche. Visualisiere deine eigenen Zeckenstiche auf diese Weise.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code code-fold=\"false\"}\nfrom matplotlib import pyplot as plt\n\nbasemap = zeckenstiche.plot(\"x\", \"y\", kind = \"scatter\", color = \"red\")\nzeckenstiche.plot(\"x_sim\", \"y_sim\", kind = \"scatter\", ax = basemap, color = \"blue\")\n\nplt.axis(\"equal\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nModuleNotFoundError: No module named 'matplotlib'\n```\n:::\n:::\n\n\n",
    "supporting": [
      "13_Uebung_9_files/figure-pdf"
    ],
    "filters": []
  }
}